// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> ___tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('__tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get __tzname => ___tzname.value;

  set __tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      ___tzname.value = value;

  late final ffi.Pointer<ffi.Int> ___daylight = _lookup<ffi.Int>('__daylight');

  int get __daylight => ___daylight.value;

  set __daylight(int value) => ___daylight.value = value;

  late final ffi.Pointer<ffi.Long> ___timezone =
      _lookup<ffi.Long>('__timezone');

  int get __timezone => ___timezone.value;

  set __timezone(int value) => ___timezone.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) => _tzname.value = value;

  late final ffi.Pointer<ffi.Int> _daylight = _lookup<ffi.Int>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  late final ffi.Pointer<ffi.Long> _timezone = _lookup<ffi.Long>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  late final ffi.Pointer<gboolean> _g_mem_gc_friendly =
      _lookup<gboolean>('g_mem_gc_friendly');

  int get g_mem_gc_friendly => _g_mem_gc_friendly.value;

  set g_mem_gc_friendly(int value) => _g_mem_gc_friendly.value = value;

  late final ffi.Pointer<ffi.Pointer<GMemVTable>> _glib_mem_profiler_table =
      _lookup<ffi.Pointer<GMemVTable>>('glib_mem_profiler_table');

  ffi.Pointer<GMemVTable> get glib_mem_profiler_table =>
      _glib_mem_profiler_table.value;

  set glib_mem_profiler_table(ffi.Pointer<GMemVTable> value) =>
      _glib_mem_profiler_table.value = value;

  late final ffi.Pointer<GSourceFuncs> _g_timeout_funcs =
      _lookup<GSourceFuncs>('g_timeout_funcs');

  GSourceFuncs get g_timeout_funcs => _g_timeout_funcs.ref;

  late final ffi.Pointer<GSourceFuncs> _g_child_watch_funcs =
      _lookup<GSourceFuncs>('g_child_watch_funcs');

  GSourceFuncs get g_child_watch_funcs => _g_child_watch_funcs.ref;

  late final ffi.Pointer<GSourceFuncs> _g_idle_funcs =
      _lookup<GSourceFuncs>('g_idle_funcs');

  GSourceFuncs get g_idle_funcs => _g_idle_funcs.ref;

  late final ffi.Pointer<GSourceFuncs> _g_unix_signal_funcs =
      _lookup<GSourceFuncs>('g_unix_signal_funcs');

  GSourceFuncs get g_unix_signal_funcs => _g_unix_signal_funcs.ref;

  late final ffi.Pointer<GSourceFuncs> _g_unix_fd_source_funcs =
      _lookup<GSourceFuncs>('g_unix_fd_source_funcs');

  GSourceFuncs get g_unix_fd_source_funcs => _g_unix_fd_source_funcs.ref;

  late final ffi.Pointer<ffi.Pointer<gchar>> _g_utf8_skip =
      _lookup<ffi.Pointer<gchar>>('g_utf8_skip');

  ffi.Pointer<gchar> get g_utf8_skip => _g_utf8_skip.value;

  late final ffi.Pointer<GSourceFuncs> _g_io_watch_funcs =
      _lookup<GSourceFuncs>('g_io_watch_funcs');

  GSourceFuncs get g_io_watch_funcs => _g_io_watch_funcs.ref;

  late final ffi.Pointer<ffi.Pointer<guint16>> _g_ascii_table =
      _lookup<ffi.Pointer<guint16>>('g_ascii_table');

  ffi.Pointer<guint16> get g_ascii_table => _g_ascii_table.value;

  late final ffi.Pointer<ffi.Pointer<GTestConfig>> _g_test_config_vars =
      _lookup<ffi.Pointer<GTestConfig>>('g_test_config_vars');

  ffi.Pointer<GTestConfig> get g_test_config_vars => _g_test_config_vars.value;

  late final ffi.Pointer<guint> _glib_major_version =
      _lookup<guint>('glib_major_version');

  int get glib_major_version => _glib_major_version.value;

  late final ffi.Pointer<guint> _glib_minor_version =
      _lookup<guint>('glib_minor_version');

  int get glib_minor_version => _glib_minor_version.value;

  late final ffi.Pointer<guint> _glib_micro_version =
      _lookup<guint>('glib_micro_version');

  int get glib_micro_version => _glib_micro_version.value;

  late final ffi.Pointer<guint> _glib_interface_age =
      _lookup<guint>('glib_interface_age');

  int get glib_interface_age => _glib_interface_age.value;

  late final ffi.Pointer<guint> _glib_binary_age =
      _lookup<guint>('glib_binary_age');

  int get glib_binary_age => _glib_binary_age.value;

  late final ffi.Pointer<GThreadFunctions> _g_thread_functions_for_glib_use =
      _lookup<GThreadFunctions>('g_thread_functions_for_glib_use');

  GThreadFunctions get g_thread_functions_for_glib_use =>
      _g_thread_functions_for_glib_use.ref;

  late final ffi.Pointer<gboolean> _g_thread_use_default_impl =
      _lookup<gboolean>('g_thread_use_default_impl');

  int get g_thread_use_default_impl => _g_thread_use_default_impl.value;

  set g_thread_use_default_impl(int value) =>
      _g_thread_use_default_impl.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.NativeFunction<guint64 Function()>>>
      _g_thread_gettime =
      _lookup<ffi.Pointer<ffi.NativeFunction<guint64 Function()>>>(
          'g_thread_gettime');

  ffi.Pointer<ffi.NativeFunction<guint64 Function()>> get g_thread_gettime =>
      _g_thread_gettime.value;

  set g_thread_gettime(
          ffi.Pointer<ffi.NativeFunction<guint64 Function()>> value) =>
      _g_thread_gettime.value = value;

  late final ffi.Pointer<gboolean> _g_threads_got_initialized =
      _lookup<gboolean>('g_threads_got_initialized');

  int get g_threads_got_initialized => _g_threads_got_initialized.value;

  set g_threads_got_initialized(int value) =>
      _g_threads_got_initialized.value = value;

  late final ffi.Pointer<ffi.Pointer<GType>> _g_param_spec_types =
      _lookup<ffi.Pointer<GType>>('g_param_spec_types');

  ffi.Pointer<GType> get g_param_spec_types => _g_param_spec_types.value;

  set g_param_spec_types(ffi.Pointer<GType> value) =>
      _g_param_spec_types.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> ___environ =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('__environ');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get __environ => ___environ.value;

  set __environ(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      ___environ.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _optarg =
      _lookup<ffi.Pointer<ffi.Char>>('optarg');

  ffi.Pointer<ffi.Char> get optarg => _optarg.value;

  set optarg(ffi.Pointer<ffi.Char> value) => _optarg.value = value;

  late final ffi.Pointer<ffi.Int> _optind = _lookup<ffi.Int>('optind');

  int get optind => _optind.value;

  set optind(int value) => _optind.value = value;

  late final ffi.Pointer<ffi.Int> _opterr = _lookup<ffi.Int>('opterr');

  int get opterr => _opterr.value;

  set opterr(int value) => _opterr.value = value;

  late final ffi.Pointer<ffi.Int> _optopt = _lookup<ffi.Int>('optopt');

  int get optopt => _optopt.value;

  set optopt(int value) => _optopt.value = value;

  int flatpak_error_get_type() {
    return _flatpak_error_get_type();
  }

  late final _flatpak_error_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('flatpak_error_get_type');
  late final _flatpak_error_get_type =
      _flatpak_error_get_typePtr.asFunction<int Function()>();

  int flatpak_update_flags_get_type() {
    return _flatpak_update_flags_get_type();
  }

  late final _flatpak_update_flags_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_update_flags_get_type');
  late final _flatpak_update_flags_get_type =
      _flatpak_update_flags_get_typePtr.asFunction<int Function()>();

  int flatpak_install_flags_get_type() {
    return _flatpak_install_flags_get_type();
  }

  late final _flatpak_install_flags_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_install_flags_get_type');
  late final _flatpak_install_flags_get_type =
      _flatpak_install_flags_get_typePtr.asFunction<int Function()>();

  int flatpak_uninstall_flags_get_type() {
    return _flatpak_uninstall_flags_get_type();
  }

  late final _flatpak_uninstall_flags_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_uninstall_flags_get_type');
  late final _flatpak_uninstall_flags_get_type =
      _flatpak_uninstall_flags_get_typePtr.asFunction<int Function()>();

  int flatpak_launch_flags_get_type() {
    return _flatpak_launch_flags_get_type();
  }

  late final _flatpak_launch_flags_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_launch_flags_get_type');
  late final _flatpak_launch_flags_get_type =
      _flatpak_launch_flags_get_typePtr.asFunction<int Function()>();

  int flatpak_query_flags_get_type() {
    return _flatpak_query_flags_get_type();
  }

  late final _flatpak_query_flags_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_query_flags_get_type');
  late final _flatpak_query_flags_get_type =
      _flatpak_query_flags_get_typePtr.asFunction<int Function()>();

  int flatpak_storage_type_get_type() {
    return _flatpak_storage_type_get_type();
  }

  late final _flatpak_storage_type_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_storage_type_get_type');
  late final _flatpak_storage_type_get_type =
      _flatpak_storage_type_get_typePtr.asFunction<int Function()>();

  int flatpak_portal_error_get_type() {
    return _flatpak_portal_error_get_type();
  }

  late final _flatpak_portal_error_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_portal_error_get_type');
  late final _flatpak_portal_error_get_type =
      _flatpak_portal_error_get_typePtr.asFunction<int Function()>();

  int flatpak_ref_kind_get_type() {
    return _flatpak_ref_kind_get_type();
  }

  late final _flatpak_ref_kind_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_ref_kind_get_type');
  late final _flatpak_ref_kind_get_type =
      _flatpak_ref_kind_get_typePtr.asFunction<int Function()>();

  int flatpak_remote_type_get_type() {
    return _flatpak_remote_type_get_type();
  }

  late final _flatpak_remote_type_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_remote_type_get_type');
  late final _flatpak_remote_type_get_type =
      _flatpak_remote_type_get_typePtr.asFunction<int Function()>();

  int flatpak_transaction_operation_type_get_type() {
    return _flatpak_transaction_operation_type_get_type();
  }

  late final _flatpak_transaction_operation_type_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_transaction_operation_type_get_type');
  late final _flatpak_transaction_operation_type_get_type =
      _flatpak_transaction_operation_type_get_typePtr
          .asFunction<int Function()>();

  int flatpak_transaction_error_details_get_type() {
    return _flatpak_transaction_error_details_get_type();
  }

  late final _flatpak_transaction_error_details_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_transaction_error_details_get_type');
  late final _flatpak_transaction_error_details_get_type =
      _flatpak_transaction_error_details_get_typePtr
          .asFunction<int Function()>();

  int flatpak_transaction_result_get_type() {
    return _flatpak_transaction_result_get_type();
  }

  late final _flatpak_transaction_result_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_transaction_result_get_type');
  late final _flatpak_transaction_result_get_type =
      _flatpak_transaction_result_get_typePtr.asFunction<int Function()>();

  int flatpak_transaction_remote_reason_get_type() {
    return _flatpak_transaction_remote_reason_get_type();
  }

  late final _flatpak_transaction_remote_reason_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_transaction_remote_reason_get_type');
  late final _flatpak_transaction_remote_reason_get_type =
      _flatpak_transaction_remote_reason_get_typePtr
          .asFunction<int Function()>();

  int flatpak_error_quark() {
    return _flatpak_error_quark();
  }

  late final _flatpak_error_quarkPtr =
      _lookup<ffi.NativeFunction<GQuark Function()>>('flatpak_error_quark');
  late final _flatpak_error_quark =
      _flatpak_error_quarkPtr.asFunction<int Function()>();

  int flatpak_portal_error_quark() {
    return _flatpak_portal_error_quark();
  }

  late final _flatpak_portal_error_quarkPtr =
      _lookup<ffi.NativeFunction<GQuark Function()>>(
          'flatpak_portal_error_quark');
  late final _flatpak_portal_error_quark =
      _flatpak_portal_error_quarkPtr.asFunction<int Function()>();

  int flatpak_ref_get_type() {
    return _flatpak_ref_get_type();
  }

  late final _flatpak_ref_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('flatpak_ref_get_type');
  late final _flatpak_ref_get_type =
      _flatpak_ref_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> flatpak_ref_get_name(
    ffi.Pointer<FlatpakRef> self,
  ) {
    return _flatpak_ref_get_name(
      self,
    );
  }

  late final _flatpak_ref_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRef>)>>('flatpak_ref_get_name');
  late final _flatpak_ref_get_name = _flatpak_ref_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRef>)>();

  ffi.Pointer<ffi.Char> flatpak_ref_get_arch(
    ffi.Pointer<FlatpakRef> self,
  ) {
    return _flatpak_ref_get_arch(
      self,
    );
  }

  late final _flatpak_ref_get_archPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRef>)>>('flatpak_ref_get_arch');
  late final _flatpak_ref_get_arch = _flatpak_ref_get_archPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRef>)>();

  ffi.Pointer<ffi.Char> flatpak_ref_get_branch(
    ffi.Pointer<FlatpakRef> self,
  ) {
    return _flatpak_ref_get_branch(
      self,
    );
  }

  late final _flatpak_ref_get_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRef>)>>('flatpak_ref_get_branch');
  late final _flatpak_ref_get_branch = _flatpak_ref_get_branchPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRef>)>();

  ffi.Pointer<ffi.Char> flatpak_ref_get_commit(
    ffi.Pointer<FlatpakRef> self,
  ) {
    return _flatpak_ref_get_commit(
      self,
    );
  }

  late final _flatpak_ref_get_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRef>)>>('flatpak_ref_get_commit');
  late final _flatpak_ref_get_commit = _flatpak_ref_get_commitPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRef>)>();

  int flatpak_ref_get_kind(
    ffi.Pointer<FlatpakRef> self,
  ) {
    return _flatpak_ref_get_kind(
      self,
    );
  }

  late final _flatpak_ref_get_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<FlatpakRef>)>>(
          'flatpak_ref_get_kind');
  late final _flatpak_ref_get_kind = _flatpak_ref_get_kindPtr
      .asFunction<int Function(ffi.Pointer<FlatpakRef>)>();

  ffi.Pointer<ffi.Char> flatpak_ref_format_ref(
    ffi.Pointer<FlatpakRef> self,
  ) {
    return _flatpak_ref_format_ref(
      self,
    );
  }

  late final _flatpak_ref_format_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRef>)>>('flatpak_ref_format_ref');
  late final _flatpak_ref_format_ref = _flatpak_ref_format_refPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRef>)>();

  ffi.Pointer<ffi.Char> flatpak_ref_format_ref_cached(
    ffi.Pointer<FlatpakRef> self,
  ) {
    return _flatpak_ref_format_ref_cached(
      self,
    );
  }

  late final _flatpak_ref_format_ref_cachedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRef>)>>('flatpak_ref_format_ref_cached');
  late final _flatpak_ref_format_ref_cached = _flatpak_ref_format_ref_cachedPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRef>)>();

  ffi.Pointer<FlatpakRef> flatpak_ref_parse(
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_ref_parse(
      ref,
      error,
    );
  }

  late final _flatpak_ref_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FlatpakRef> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('flatpak_ref_parse');
  late final _flatpak_ref_parse = _flatpak_ref_parsePtr.asFunction<
      ffi.Pointer<FlatpakRef> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> flatpak_ref_get_collection_id(
    ffi.Pointer<FlatpakRef> self,
  ) {
    return _flatpak_ref_get_collection_id(
      self,
    );
  }

  late final _flatpak_ref_get_collection_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRef>)>>('flatpak_ref_get_collection_id');
  late final _flatpak_ref_get_collection_id = _flatpak_ref_get_collection_idPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRef>)>();

  int flatpak_installed_ref_get_type() {
    return _flatpak_installed_ref_get_type();
  }

  late final _flatpak_installed_ref_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_installed_ref_get_type');
  late final _flatpak_installed_ref_get_type =
      _flatpak_installed_ref_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_origin(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_origin(
      self,
    );
  }

  late final _flatpak_installed_ref_get_originPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_origin');
  late final _flatpak_installed_ref_get_origin =
      _flatpak_installed_ref_get_originPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Pointer<ffi.Char>> flatpak_installed_ref_get_subpaths(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_subpaths(
      self,
    );
  }

  late final _flatpak_installed_ref_get_subpathsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_subpaths');
  late final _flatpak_installed_ref_get_subpaths =
      _flatpak_installed_ref_get_subpathsPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<FlatpakInstalledRef>)>();

  int flatpak_installed_ref_get_installed_size(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_installed_size(
      self,
    );
  }

  late final _flatpak_installed_ref_get_installed_sizePtr = _lookup<
          ffi
          .NativeFunction<guint64 Function(ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_installed_size');
  late final _flatpak_installed_ref_get_installed_size =
      _flatpak_installed_ref_get_installed_sizePtr
          .asFunction<int Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_deploy_dir(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_deploy_dir(
      self,
    );
  }

  late final _flatpak_installed_ref_get_deploy_dirPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_deploy_dir');
  late final _flatpak_installed_ref_get_deploy_dir =
      _flatpak_installed_ref_get_deploy_dirPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_latest_commit(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_latest_commit(
      self,
    );
  }

  late final _flatpak_installed_ref_get_latest_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_latest_commit');
  late final _flatpak_installed_ref_get_latest_commit =
      _flatpak_installed_ref_get_latest_commitPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_appdata_name(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_appdata_name(
      self,
    );
  }

  late final _flatpak_installed_ref_get_appdata_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_appdata_name');
  late final _flatpak_installed_ref_get_appdata_name =
      _flatpak_installed_ref_get_appdata_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_appdata_summary(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_appdata_summary(
      self,
    );
  }

  late final _flatpak_installed_ref_get_appdata_summaryPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_appdata_summary');
  late final _flatpak_installed_ref_get_appdata_summary =
      _flatpak_installed_ref_get_appdata_summaryPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_appdata_version(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_appdata_version(
      self,
    );
  }

  late final _flatpak_installed_ref_get_appdata_versionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_appdata_version');
  late final _flatpak_installed_ref_get_appdata_version =
      _flatpak_installed_ref_get_appdata_versionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_appdata_license(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_appdata_license(
      self,
    );
  }

  late final _flatpak_installed_ref_get_appdata_licensePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_appdata_license');
  late final _flatpak_installed_ref_get_appdata_license =
      _flatpak_installed_ref_get_appdata_licensePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_appdata_content_rating_type(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_appdata_content_rating_type(
      self,
    );
  }

  late final _flatpak_installed_ref_get_appdata_content_rating_typePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Char> Function(
                      ffi.Pointer<FlatpakInstalledRef>)>>(
          'flatpak_installed_ref_get_appdata_content_rating_type');
  late final _flatpak_installed_ref_get_appdata_content_rating_type =
      _flatpak_installed_ref_get_appdata_content_rating_typePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<GHashTable> flatpak_installed_ref_get_appdata_content_rating(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_appdata_content_rating(
      self,
    );
  }

  late final _flatpak_installed_ref_get_appdata_content_ratingPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GHashTable> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_appdata_content_rating');
  late final _flatpak_installed_ref_get_appdata_content_rating =
      _flatpak_installed_ref_get_appdata_content_ratingPtr.asFunction<
          ffi.Pointer<GHashTable> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  int flatpak_installed_ref_get_is_current(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_is_current(
      self,
    );
  }

  late final _flatpak_installed_ref_get_is_currentPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_is_current');
  late final _flatpak_installed_ref_get_is_current =
      _flatpak_installed_ref_get_is_currentPtr
          .asFunction<int Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<GBytes> flatpak_installed_ref_load_metadata(
    ffi.Pointer<FlatpakInstalledRef> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installed_ref_load_metadata(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installed_ref_load_metadataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GBytes> Function(
                  ffi.Pointer<FlatpakInstalledRef>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installed_ref_load_metadata');
  late final _flatpak_installed_ref_load_metadata =
      _flatpak_installed_ref_load_metadataPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakInstalledRef>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GBytes> flatpak_installed_ref_load_appdata(
    ffi.Pointer<FlatpakInstalledRef> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installed_ref_load_appdata(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installed_ref_load_appdataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GBytes> Function(
                  ffi.Pointer<FlatpakInstalledRef>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installed_ref_load_appdata');
  late final _flatpak_installed_ref_load_appdata =
      _flatpak_installed_ref_load_appdataPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakInstalledRef>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_eol(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_eol(
      self,
    );
  }

  late final _flatpak_installed_ref_get_eolPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_eol');
  late final _flatpak_installed_ref_get_eol =
      _flatpak_installed_ref_get_eolPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  ffi.Pointer<ffi.Char> flatpak_installed_ref_get_eol_rebase(
    ffi.Pointer<FlatpakInstalledRef> self,
  ) {
    return _flatpak_installed_ref_get_eol_rebase(
      self,
    );
  }

  late final _flatpak_installed_ref_get_eol_rebasePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstalledRef>)>>(
      'flatpak_installed_ref_get_eol_rebase');
  late final _flatpak_installed_ref_get_eol_rebase =
      _flatpak_installed_ref_get_eol_rebasePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstalledRef>)>();

  int flatpak_remote_ref_get_type() {
    return _flatpak_remote_ref_get_type();
  }

  late final _flatpak_remote_ref_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_remote_ref_get_type');
  late final _flatpak_remote_ref_get_type =
      _flatpak_remote_ref_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> flatpak_remote_ref_get_remote_name(
    ffi.Pointer<FlatpakRemoteRef> self,
  ) {
    return _flatpak_remote_ref_get_remote_name(
      self,
    );
  }

  late final _flatpak_remote_ref_get_remote_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemoteRef>)>>(
      'flatpak_remote_ref_get_remote_name');
  late final _flatpak_remote_ref_get_remote_name =
      _flatpak_remote_ref_get_remote_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemoteRef>)>();

  int flatpak_remote_ref_get_installed_size(
    ffi.Pointer<FlatpakRemoteRef> self,
  ) {
    return _flatpak_remote_ref_get_installed_size(
      self,
    );
  }

  late final _flatpak_remote_ref_get_installed_sizePtr = _lookup<
          ffi.NativeFunction<guint64 Function(ffi.Pointer<FlatpakRemoteRef>)>>(
      'flatpak_remote_ref_get_installed_size');
  late final _flatpak_remote_ref_get_installed_size =
      _flatpak_remote_ref_get_installed_sizePtr
          .asFunction<int Function(ffi.Pointer<FlatpakRemoteRef>)>();

  int flatpak_remote_ref_get_download_size(
    ffi.Pointer<FlatpakRemoteRef> self,
  ) {
    return _flatpak_remote_ref_get_download_size(
      self,
    );
  }

  late final _flatpak_remote_ref_get_download_sizePtr = _lookup<
          ffi.NativeFunction<guint64 Function(ffi.Pointer<FlatpakRemoteRef>)>>(
      'flatpak_remote_ref_get_download_size');
  late final _flatpak_remote_ref_get_download_size =
      _flatpak_remote_ref_get_download_sizePtr
          .asFunction<int Function(ffi.Pointer<FlatpakRemoteRef>)>();

  ffi.Pointer<GBytes> flatpak_remote_ref_get_metadata(
    ffi.Pointer<FlatpakRemoteRef> self,
  ) {
    return _flatpak_remote_ref_get_metadata(
      self,
    );
  }

  late final _flatpak_remote_ref_get_metadataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakRemoteRef>)>>(
      'flatpak_remote_ref_get_metadata');
  late final _flatpak_remote_ref_get_metadata =
      _flatpak_remote_ref_get_metadataPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakRemoteRef>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_ref_get_eol(
    ffi.Pointer<FlatpakRemoteRef> self,
  ) {
    return _flatpak_remote_ref_get_eol(
      self,
    );
  }

  late final _flatpak_remote_ref_get_eolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemoteRef>)>>('flatpak_remote_ref_get_eol');
  late final _flatpak_remote_ref_get_eol =
      _flatpak_remote_ref_get_eolPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemoteRef>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_ref_get_eol_rebase(
    ffi.Pointer<FlatpakRemoteRef> self,
  ) {
    return _flatpak_remote_ref_get_eol_rebase(
      self,
    );
  }

  late final _flatpak_remote_ref_get_eol_rebasePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemoteRef>)>>(
      'flatpak_remote_ref_get_eol_rebase');
  late final _flatpak_remote_ref_get_eol_rebase =
      _flatpak_remote_ref_get_eol_rebasePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemoteRef>)>();

  int flatpak_related_ref_get_type() {
    return _flatpak_related_ref_get_type();
  }

  late final _flatpak_related_ref_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_related_ref_get_type');
  late final _flatpak_related_ref_get_type =
      _flatpak_related_ref_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Pointer<ffi.Char>> flatpak_related_ref_get_subpaths(
    ffi.Pointer<FlatpakRelatedRef> self,
  ) {
    return _flatpak_related_ref_get_subpaths(
      self,
    );
  }

  late final _flatpak_related_ref_get_subpathsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
                  ffi.Pointer<FlatpakRelatedRef>)>>(
      'flatpak_related_ref_get_subpaths');
  late final _flatpak_related_ref_get_subpaths =
      _flatpak_related_ref_get_subpathsPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<FlatpakRelatedRef>)>();

  int flatpak_related_ref_should_download(
    ffi.Pointer<FlatpakRelatedRef> self,
  ) {
    return _flatpak_related_ref_should_download(
      self,
    );
  }

  late final _flatpak_related_ref_should_downloadPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakRelatedRef>)>>(
      'flatpak_related_ref_should_download');
  late final _flatpak_related_ref_should_download =
      _flatpak_related_ref_should_downloadPtr
          .asFunction<int Function(ffi.Pointer<FlatpakRelatedRef>)>();

  int flatpak_related_ref_should_delete(
    ffi.Pointer<FlatpakRelatedRef> self,
  ) {
    return _flatpak_related_ref_should_delete(
      self,
    );
  }

  late final _flatpak_related_ref_should_deletePtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakRelatedRef>)>>(
      'flatpak_related_ref_should_delete');
  late final _flatpak_related_ref_should_delete =
      _flatpak_related_ref_should_deletePtr
          .asFunction<int Function(ffi.Pointer<FlatpakRelatedRef>)>();

  int flatpak_related_ref_should_autoprune(
    ffi.Pointer<FlatpakRelatedRef> self,
  ) {
    return _flatpak_related_ref_should_autoprune(
      self,
    );
  }

  late final _flatpak_related_ref_should_autoprunePtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakRelatedRef>)>>(
      'flatpak_related_ref_should_autoprune');
  late final _flatpak_related_ref_should_autoprune =
      _flatpak_related_ref_should_autoprunePtr
          .asFunction<int Function(ffi.Pointer<FlatpakRelatedRef>)>();

  int flatpak_bundle_ref_get_type() {
    return _flatpak_bundle_ref_get_type();
  }

  late final _flatpak_bundle_ref_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_bundle_ref_get_type');
  late final _flatpak_bundle_ref_get_type =
      _flatpak_bundle_ref_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<FlatpakBundleRef> flatpak_bundle_ref_new(
    ffi.Pointer<GFile> file,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_bundle_ref_new(
      file,
      error,
    );
  }

  late final _flatpak_bundle_ref_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FlatpakBundleRef> Function(ffi.Pointer<GFile>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('flatpak_bundle_ref_new');
  late final _flatpak_bundle_ref_new = _flatpak_bundle_ref_newPtr.asFunction<
      ffi.Pointer<FlatpakBundleRef> Function(
          ffi.Pointer<GFile>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GFile> flatpak_bundle_ref_get_file(
    ffi.Pointer<FlatpakBundleRef> self,
  ) {
    return _flatpak_bundle_ref_get_file(
      self,
    );
  }

  late final _flatpak_bundle_ref_get_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GFile> Function(
              ffi.Pointer<FlatpakBundleRef>)>>('flatpak_bundle_ref_get_file');
  late final _flatpak_bundle_ref_get_file = _flatpak_bundle_ref_get_filePtr
      .asFunction<ffi.Pointer<GFile> Function(ffi.Pointer<FlatpakBundleRef>)>();

  ffi.Pointer<GBytes> flatpak_bundle_ref_get_metadata(
    ffi.Pointer<FlatpakBundleRef> self,
  ) {
    return _flatpak_bundle_ref_get_metadata(
      self,
    );
  }

  late final _flatpak_bundle_ref_get_metadataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakBundleRef>)>>(
      'flatpak_bundle_ref_get_metadata');
  late final _flatpak_bundle_ref_get_metadata =
      _flatpak_bundle_ref_get_metadataPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakBundleRef>)>();

  ffi.Pointer<GBytes> flatpak_bundle_ref_get_appstream(
    ffi.Pointer<FlatpakBundleRef> self,
  ) {
    return _flatpak_bundle_ref_get_appstream(
      self,
    );
  }

  late final _flatpak_bundle_ref_get_appstreamPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakBundleRef>)>>(
      'flatpak_bundle_ref_get_appstream');
  late final _flatpak_bundle_ref_get_appstream =
      _flatpak_bundle_ref_get_appstreamPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakBundleRef>)>();

  ffi.Pointer<GBytes> flatpak_bundle_ref_get_icon(
    ffi.Pointer<FlatpakBundleRef> self,
    int size,
  ) {
    return _flatpak_bundle_ref_get_icon(
      self,
      size,
    );
  }

  late final _flatpak_bundle_ref_get_iconPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakBundleRef>,
              ffi.Int)>>('flatpak_bundle_ref_get_icon');
  late final _flatpak_bundle_ref_get_icon =
      _flatpak_bundle_ref_get_iconPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<FlatpakBundleRef>, int)>();

  ffi.Pointer<ffi.Char> flatpak_bundle_ref_get_origin(
    ffi.Pointer<FlatpakBundleRef> self,
  ) {
    return _flatpak_bundle_ref_get_origin(
      self,
    );
  }

  late final _flatpak_bundle_ref_get_originPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakBundleRef>)>>('flatpak_bundle_ref_get_origin');
  late final _flatpak_bundle_ref_get_origin =
      _flatpak_bundle_ref_get_originPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakBundleRef>)>();

  int flatpak_bundle_ref_get_installed_size(
    ffi.Pointer<FlatpakBundleRef> self,
  ) {
    return _flatpak_bundle_ref_get_installed_size(
      self,
    );
  }

  late final _flatpak_bundle_ref_get_installed_sizePtr = _lookup<
          ffi.NativeFunction<guint64 Function(ffi.Pointer<FlatpakBundleRef>)>>(
      'flatpak_bundle_ref_get_installed_size');
  late final _flatpak_bundle_ref_get_installed_size =
      _flatpak_bundle_ref_get_installed_sizePtr
          .asFunction<int Function(ffi.Pointer<FlatpakBundleRef>)>();

  ffi.Pointer<ffi.Char> flatpak_bundle_ref_get_runtime_repo_url(
    ffi.Pointer<FlatpakBundleRef> self,
  ) {
    return _flatpak_bundle_ref_get_runtime_repo_url(
      self,
    );
  }

  late final _flatpak_bundle_ref_get_runtime_repo_urlPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakBundleRef>)>>(
      'flatpak_bundle_ref_get_runtime_repo_url');
  late final _flatpak_bundle_ref_get_runtime_repo_url =
      _flatpak_bundle_ref_get_runtime_repo_urlPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakBundleRef>)>();

  int flatpak_remote_get_type() {
    return _flatpak_remote_get_type();
  }

  late final _flatpak_remote_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('flatpak_remote_get_type');
  late final _flatpak_remote_get_type =
      _flatpak_remote_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<FlatpakRemote> flatpak_remote_new(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _flatpak_remote_new(
      name,
    );
  }

  late final _flatpak_remote_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FlatpakRemote> Function(
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_new');
  late final _flatpak_remote_new = _flatpak_remote_newPtr
      .asFunction<ffi.Pointer<FlatpakRemote> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FlatpakRemote> flatpak_remote_new_from_file(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<GBytes> data,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_remote_new_from_file(
      name,
      data,
      error,
    );
  }

  late final _flatpak_remote_new_from_filePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakRemote> Function(ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GBytes>, ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_remote_new_from_file');
  late final _flatpak_remote_new_from_file =
      _flatpak_remote_new_from_filePtr.asFunction<
          ffi.Pointer<FlatpakRemote> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<GBytes>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_name(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_name(
      self,
    );
  }

  late final _flatpak_remote_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_name');
  late final _flatpak_remote_get_name = _flatpak_remote_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  ffi.Pointer<GFile> flatpak_remote_get_appstream_dir(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> arch,
  ) {
    return _flatpak_remote_get_appstream_dir(
      self,
      arch,
    );
  }

  late final _flatpak_remote_get_appstream_dirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GFile> Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_get_appstream_dir');
  late final _flatpak_remote_get_appstream_dir =
      _flatpak_remote_get_appstream_dirPtr.asFunction<
          ffi.Pointer<GFile> Function(
              ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<GFile> flatpak_remote_get_appstream_timestamp(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> arch,
  ) {
    return _flatpak_remote_get_appstream_timestamp(
      self,
      arch,
    );
  }

  late final _flatpak_remote_get_appstream_timestampPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(
                  ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>>(
      'flatpak_remote_get_appstream_timestamp');
  late final _flatpak_remote_get_appstream_timestamp =
      _flatpak_remote_get_appstream_timestampPtr.asFunction<
          ffi.Pointer<GFile> Function(
              ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_url(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_url(
      self,
    );
  }

  late final _flatpak_remote_get_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_url');
  late final _flatpak_remote_get_url = _flatpak_remote_get_urlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_url(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _flatpak_remote_set_url(
      self,
      url,
    );
  }

  late final _flatpak_remote_set_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_url');
  late final _flatpak_remote_set_url = _flatpak_remote_set_urlPtr.asFunction<
      void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_collection_id(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_collection_id(
      self,
    );
  }

  late final _flatpak_remote_get_collection_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_collection_id');
  late final _flatpak_remote_get_collection_id =
      _flatpak_remote_get_collection_idPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_collection_id(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> collection_id,
  ) {
    return _flatpak_remote_set_collection_id(
      self,
      collection_id,
    );
  }

  late final _flatpak_remote_set_collection_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_collection_id');
  late final _flatpak_remote_set_collection_id =
      _flatpak_remote_set_collection_idPtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_title(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_title(
      self,
    );
  }

  late final _flatpak_remote_get_titlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_title');
  late final _flatpak_remote_get_title = _flatpak_remote_get_titlePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_title(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> title,
  ) {
    return _flatpak_remote_set_title(
      self,
      title,
    );
  }

  late final _flatpak_remote_set_titlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_title');
  late final _flatpak_remote_set_title =
      _flatpak_remote_set_titlePtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_comment(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_comment(
      self,
    );
  }

  late final _flatpak_remote_get_commentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_comment');
  late final _flatpak_remote_get_comment = _flatpak_remote_get_commentPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_comment(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> comment,
  ) {
    return _flatpak_remote_set_comment(
      self,
      comment,
    );
  }

  late final _flatpak_remote_set_commentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_comment');
  late final _flatpak_remote_set_comment =
      _flatpak_remote_set_commentPtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_description(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_description(
      self,
    );
  }

  late final _flatpak_remote_get_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_description');
  late final _flatpak_remote_get_description =
      _flatpak_remote_get_descriptionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_description(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _flatpak_remote_set_description(
      self,
      description,
    );
  }

  late final _flatpak_remote_set_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_description');
  late final _flatpak_remote_set_description =
      _flatpak_remote_set_descriptionPtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_homepage(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_homepage(
      self,
    );
  }

  late final _flatpak_remote_get_homepagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_homepage');
  late final _flatpak_remote_get_homepage = _flatpak_remote_get_homepagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_homepage(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> homepage,
  ) {
    return _flatpak_remote_set_homepage(
      self,
      homepage,
    );
  }

  late final _flatpak_remote_set_homepagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_homepage');
  late final _flatpak_remote_set_homepage =
      _flatpak_remote_set_homepagePtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_icon(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_icon(
      self,
    );
  }

  late final _flatpak_remote_get_iconPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_icon');
  late final _flatpak_remote_get_icon = _flatpak_remote_get_iconPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_icon(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> icon,
  ) {
    return _flatpak_remote_set_icon(
      self,
      icon,
    );
  }

  late final _flatpak_remote_set_iconPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_icon');
  late final _flatpak_remote_set_icon = _flatpak_remote_set_iconPtr.asFunction<
      void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_default_branch(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_default_branch(
      self,
    );
  }

  late final _flatpak_remote_get_default_branchPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>>(
      'flatpak_remote_get_default_branch');
  late final _flatpak_remote_get_default_branch =
      _flatpak_remote_get_default_branchPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_default_branch(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> default_branch,
  ) {
    return _flatpak_remote_set_default_branch(
      self,
      default_branch,
    );
  }

  late final _flatpak_remote_set_default_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_default_branch');
  late final _flatpak_remote_set_default_branch =
      _flatpak_remote_set_default_branchPtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_main_ref(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_main_ref(
      self,
    );
  }

  late final _flatpak_remote_get_main_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_main_ref');
  late final _flatpak_remote_get_main_ref = _flatpak_remote_get_main_refPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_main_ref(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> main_ref,
  ) {
    return _flatpak_remote_set_main_ref(
      self,
      main_ref,
    );
  }

  late final _flatpak_remote_set_main_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_main_ref');
  late final _flatpak_remote_set_main_ref =
      _flatpak_remote_set_main_refPtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  int flatpak_remote_get_gpg_verify(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_gpg_verify(
      self,
    );
  }

  late final _flatpak_remote_get_gpg_verifyPtr = _lookup<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<FlatpakRemote>)>>(
      'flatpak_remote_get_gpg_verify');
  late final _flatpak_remote_get_gpg_verify = _flatpak_remote_get_gpg_verifyPtr
      .asFunction<int Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_gpg_verify(
    ffi.Pointer<FlatpakRemote> self,
    int gpg_verify,
  ) {
    return _flatpak_remote_set_gpg_verify(
      self,
      gpg_verify,
    );
  }

  late final _flatpak_remote_set_gpg_verifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              gboolean)>>('flatpak_remote_set_gpg_verify');
  late final _flatpak_remote_set_gpg_verify = _flatpak_remote_set_gpg_verifyPtr
      .asFunction<void Function(ffi.Pointer<FlatpakRemote>, int)>();

  void flatpak_remote_set_gpg_key(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<GBytes> gpg_key,
  ) {
    return _flatpak_remote_set_gpg_key(
      self,
      gpg_key,
    );
  }

  late final _flatpak_remote_set_gpg_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<GBytes>)>>('flatpak_remote_set_gpg_key');
  late final _flatpak_remote_set_gpg_key =
      _flatpak_remote_set_gpg_keyPtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<GBytes>)>();

  int flatpak_remote_get_noenumerate(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_noenumerate(
      self,
    );
  }

  late final _flatpak_remote_get_noenumeratePtr = _lookup<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<FlatpakRemote>)>>(
      'flatpak_remote_get_noenumerate');
  late final _flatpak_remote_get_noenumerate =
      _flatpak_remote_get_noenumeratePtr
          .asFunction<int Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_noenumerate(
    ffi.Pointer<FlatpakRemote> self,
    int noenumerate,
  ) {
    return _flatpak_remote_set_noenumerate(
      self,
      noenumerate,
    );
  }

  late final _flatpak_remote_set_noenumeratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              gboolean)>>('flatpak_remote_set_noenumerate');
  late final _flatpak_remote_set_noenumerate =
      _flatpak_remote_set_noenumeratePtr
          .asFunction<void Function(ffi.Pointer<FlatpakRemote>, int)>();

  int flatpak_remote_get_nodeps(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_nodeps(
      self,
    );
  }

  late final _flatpak_remote_get_nodepsPtr = _lookup<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<FlatpakRemote>)>>(
      'flatpak_remote_get_nodeps');
  late final _flatpak_remote_get_nodeps = _flatpak_remote_get_nodepsPtr
      .asFunction<int Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_nodeps(
    ffi.Pointer<FlatpakRemote> self,
    int nodeps,
  ) {
    return _flatpak_remote_set_nodeps(
      self,
      nodeps,
    );
  }

  late final _flatpak_remote_set_nodepsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              gboolean)>>('flatpak_remote_set_nodeps');
  late final _flatpak_remote_set_nodeps = _flatpak_remote_set_nodepsPtr
      .asFunction<void Function(ffi.Pointer<FlatpakRemote>, int)>();

  int flatpak_remote_get_disabled(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_disabled(
      self,
    );
  }

  late final _flatpak_remote_get_disabledPtr = _lookup<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<FlatpakRemote>)>>(
      'flatpak_remote_get_disabled');
  late final _flatpak_remote_get_disabled = _flatpak_remote_get_disabledPtr
      .asFunction<int Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_disabled(
    ffi.Pointer<FlatpakRemote> self,
    int disabled,
  ) {
    return _flatpak_remote_set_disabled(
      self,
      disabled,
    );
  }

  late final _flatpak_remote_set_disabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              gboolean)>>('flatpak_remote_set_disabled');
  late final _flatpak_remote_set_disabled = _flatpak_remote_set_disabledPtr
      .asFunction<void Function(ffi.Pointer<FlatpakRemote>, int)>();

  int flatpak_remote_get_prio(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_prio(
      self,
    );
  }

  late final _flatpak_remote_get_prioPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FlatpakRemote>)>>(
          'flatpak_remote_get_prio');
  late final _flatpak_remote_get_prio = _flatpak_remote_get_prioPtr
      .asFunction<int Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_prio(
    ffi.Pointer<FlatpakRemote> self,
    int prio,
  ) {
    return _flatpak_remote_set_prio(
      self,
      prio,
    );
  }

  late final _flatpak_remote_set_prioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FlatpakRemote>, ffi.Int)>>('flatpak_remote_set_prio');
  late final _flatpak_remote_set_prio = _flatpak_remote_set_prioPtr
      .asFunction<void Function(ffi.Pointer<FlatpakRemote>, int)>();

  ffi.Pointer<ffi.Char> flatpak_remote_get_filter(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_filter(
      self,
    );
  }

  late final _flatpak_remote_get_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakRemote>)>>('flatpak_remote_get_filter');
  late final _flatpak_remote_get_filter = _flatpak_remote_get_filterPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakRemote>)>();

  void flatpak_remote_set_filter(
    ffi.Pointer<FlatpakRemote> self,
    ffi.Pointer<ffi.Char> filter_path,
  ) {
    return _flatpak_remote_set_filter(
      self,
      filter_path,
    );
  }

  late final _flatpak_remote_set_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<ffi.Char>)>>('flatpak_remote_set_filter');
  late final _flatpak_remote_set_filter =
      _flatpak_remote_set_filterPtr.asFunction<
          void Function(ffi.Pointer<FlatpakRemote>, ffi.Pointer<ffi.Char>)>();

  int flatpak_remote_get_remote_type(
    ffi.Pointer<FlatpakRemote> self,
  ) {
    return _flatpak_remote_get_remote_type(
      self,
    );
  }

  late final _flatpak_remote_get_remote_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<FlatpakRemote>)>>(
      'flatpak_remote_get_remote_type');
  late final _flatpak_remote_get_remote_type =
      _flatpak_remote_get_remote_typePtr
          .asFunction<int Function(ffi.Pointer<FlatpakRemote>)>();

  int flatpak_instance_get_type() {
    return _flatpak_instance_get_type();
  }

  late final _flatpak_instance_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_instance_get_type');
  late final _flatpak_instance_get_type =
      _flatpak_instance_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GPtrArray> flatpak_instance_get_all() {
    return _flatpak_instance_get_all();
  }

  late final _flatpak_instance_get_allPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GPtrArray> Function()>>(
          'flatpak_instance_get_all');
  late final _flatpak_instance_get_all = _flatpak_instance_get_allPtr
      .asFunction<ffi.Pointer<GPtrArray> Function()>();

  ffi.Pointer<ffi.Char> flatpak_instance_get_id(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_id(
      self,
    );
  }

  late final _flatpak_instance_get_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakInstance>)>>('flatpak_instance_get_id');
  late final _flatpak_instance_get_id = _flatpak_instance_get_idPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstance>)>();

  ffi.Pointer<ffi.Char> flatpak_instance_get_app(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_app(
      self,
    );
  }

  late final _flatpak_instance_get_appPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakInstance>)>>('flatpak_instance_get_app');
  late final _flatpak_instance_get_app =
      _flatpak_instance_get_appPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstance>)>();

  ffi.Pointer<ffi.Char> flatpak_instance_get_arch(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_arch(
      self,
    );
  }

  late final _flatpak_instance_get_archPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakInstance>)>>('flatpak_instance_get_arch');
  late final _flatpak_instance_get_arch =
      _flatpak_instance_get_archPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstance>)>();

  ffi.Pointer<ffi.Char> flatpak_instance_get_branch(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_branch(
      self,
    );
  }

  late final _flatpak_instance_get_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakInstance>)>>('flatpak_instance_get_branch');
  late final _flatpak_instance_get_branch =
      _flatpak_instance_get_branchPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstance>)>();

  ffi.Pointer<ffi.Char> flatpak_instance_get_commit(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_commit(
      self,
    );
  }

  late final _flatpak_instance_get_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakInstance>)>>('flatpak_instance_get_commit');
  late final _flatpak_instance_get_commit =
      _flatpak_instance_get_commitPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstance>)>();

  ffi.Pointer<ffi.Char> flatpak_instance_get_runtime(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_runtime(
      self,
    );
  }

  late final _flatpak_instance_get_runtimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakInstance>)>>('flatpak_instance_get_runtime');
  late final _flatpak_instance_get_runtime =
      _flatpak_instance_get_runtimePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstance>)>();

  ffi.Pointer<ffi.Char> flatpak_instance_get_runtime_commit(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_runtime_commit(
      self,
    );
  }

  late final _flatpak_instance_get_runtime_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstance>)>>(
      'flatpak_instance_get_runtime_commit');
  late final _flatpak_instance_get_runtime_commit =
      _flatpak_instance_get_runtime_commitPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstance>)>();

  int flatpak_instance_get_pid(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_pid(
      self,
    );
  }

  late final _flatpak_instance_get_pidPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FlatpakInstance>)>>(
      'flatpak_instance_get_pid');
  late final _flatpak_instance_get_pid = _flatpak_instance_get_pidPtr
      .asFunction<int Function(ffi.Pointer<FlatpakInstance>)>();

  int flatpak_instance_get_child_pid(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_child_pid(
      self,
    );
  }

  late final _flatpak_instance_get_child_pidPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FlatpakInstance>)>>(
      'flatpak_instance_get_child_pid');
  late final _flatpak_instance_get_child_pid =
      _flatpak_instance_get_child_pidPtr
          .asFunction<int Function(ffi.Pointer<FlatpakInstance>)>();

  ffi.Pointer<GKeyFile> flatpak_instance_get_info(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_get_info(
      self,
    );
  }

  late final _flatpak_instance_get_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GKeyFile> Function(
              ffi.Pointer<FlatpakInstance>)>>('flatpak_instance_get_info');
  late final _flatpak_instance_get_info =
      _flatpak_instance_get_infoPtr.asFunction<
          ffi.Pointer<GKeyFile> Function(ffi.Pointer<FlatpakInstance>)>();

  int flatpak_instance_is_running(
    ffi.Pointer<FlatpakInstance> self,
  ) {
    return _flatpak_instance_is_running(
      self,
    );
  }

  late final _flatpak_instance_is_runningPtr = _lookup<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<FlatpakInstance>)>>(
      'flatpak_instance_is_running');
  late final _flatpak_instance_is_running = _flatpak_instance_is_runningPtr
      .asFunction<int Function(ffi.Pointer<FlatpakInstance>)>();

  int flatpak_installation_get_type() {
    return _flatpak_installation_get_type();
  }

  late final _flatpak_installation_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_installation_get_type');
  late final _flatpak_installation_get_type =
      _flatpak_installation_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> flatpak_get_default_arch() {
    return _flatpak_get_default_arch();
  }

  late final _flatpak_get_default_archPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'flatpak_get_default_arch');
  late final _flatpak_get_default_arch = _flatpak_get_default_archPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Pointer<ffi.Char>> flatpak_get_supported_arches() {
    return _flatpak_get_supported_arches();
  }

  late final _flatpak_get_supported_archesPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Pointer<ffi.Char>> Function()>>(
      'flatpak_get_supported_arches');
  late final _flatpak_get_supported_arches = _flatpak_get_supported_archesPtr
      .asFunction<ffi.Pointer<ffi.Pointer<ffi.Char>> Function()>();

  ffi.Pointer<GPtrArray> flatpak_get_system_installations(
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_get_system_installations(
      cancellable,
      error,
    );
  }

  late final _flatpak_get_system_installationsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_get_system_installations');
  late final _flatpak_get_system_installations =
      _flatpak_get_system_installationsPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstallation> flatpak_installation_new_system(
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_new_system(
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_new_systemPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstallation> Function(
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_new_system');
  late final _flatpak_installation_new_system =
      _flatpak_installation_new_systemPtr.asFunction<
          ffi.Pointer<FlatpakInstallation> Function(
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstallation> flatpak_installation_new_system_with_id(
    ffi.Pointer<ffi.Char> id,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_new_system_with_id(
      id,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_new_system_with_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstallation> Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_new_system_with_id');
  late final _flatpak_installation_new_system_with_id =
      _flatpak_installation_new_system_with_idPtr.asFunction<
          ffi.Pointer<FlatpakInstallation> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstallation> flatpak_installation_new_user(
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_new_user(
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_new_userPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstallation> Function(
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_new_user');
  late final _flatpak_installation_new_user =
      _flatpak_installation_new_userPtr.asFunction<
          ffi.Pointer<FlatpakInstallation> Function(
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstallation> flatpak_installation_new_for_path(
    ffi.Pointer<GFile> path,
    int user,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_new_for_path(
      path,
      user,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_new_for_pathPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstallation> Function(
                  ffi.Pointer<GFile>,
                  gboolean,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_new_for_path');
  late final _flatpak_installation_new_for_path =
      _flatpak_installation_new_for_pathPtr.asFunction<
          ffi.Pointer<FlatpakInstallation> Function(ffi.Pointer<GFile>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void flatpak_installation_set_no_interaction(
    ffi.Pointer<FlatpakInstallation> self,
    int no_interaction,
  ) {
    return _flatpak_installation_set_no_interaction(
      self,
      no_interaction,
    );
  }

  late final _flatpak_installation_set_no_interactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakInstallation>,
              gboolean)>>('flatpak_installation_set_no_interaction');
  late final _flatpak_installation_set_no_interaction =
      _flatpak_installation_set_no_interactionPtr
          .asFunction<void Function(ffi.Pointer<FlatpakInstallation>, int)>();

  int flatpak_installation_get_no_interaction(
    ffi.Pointer<FlatpakInstallation> self,
  ) {
    return _flatpak_installation_get_no_interaction(
      self,
    );
  }

  late final _flatpak_installation_get_no_interactionPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakInstallation>)>>(
      'flatpak_installation_get_no_interaction');
  late final _flatpak_installation_get_no_interaction =
      _flatpak_installation_get_no_interactionPtr
          .asFunction<int Function(ffi.Pointer<FlatpakInstallation>)>();

  int flatpak_installation_drop_caches(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_drop_caches(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_drop_cachesPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_drop_caches');
  late final _flatpak_installation_drop_caches =
      _flatpak_installation_drop_cachesPtr.asFunction<
          int Function(ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_get_is_user(
    ffi.Pointer<FlatpakInstallation> self,
  ) {
    return _flatpak_installation_get_is_user(
      self,
    );
  }

  late final _flatpak_installation_get_is_userPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakInstallation>)>>(
      'flatpak_installation_get_is_user');
  late final _flatpak_installation_get_is_user =
      _flatpak_installation_get_is_userPtr
          .asFunction<int Function(ffi.Pointer<FlatpakInstallation>)>();

  ffi.Pointer<GFile> flatpak_installation_get_path(
    ffi.Pointer<FlatpakInstallation> self,
  ) {
    return _flatpak_installation_get_path(
      self,
    );
  }

  late final _flatpak_installation_get_pathPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(ffi.Pointer<FlatpakInstallation>)>>(
      'flatpak_installation_get_path');
  late final _flatpak_installation_get_path =
      _flatpak_installation_get_pathPtr.asFunction<
          ffi.Pointer<GFile> Function(ffi.Pointer<FlatpakInstallation>)>();

  ffi.Pointer<ffi.Char> flatpak_installation_get_id(
    ffi.Pointer<FlatpakInstallation> self,
  ) {
    return _flatpak_installation_get_id(
      self,
    );
  }

  late final _flatpak_installation_get_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstallation>)>>(
      'flatpak_installation_get_id');
  late final _flatpak_installation_get_id =
      _flatpak_installation_get_idPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstallation>)>();

  ffi.Pointer<ffi.Char> flatpak_installation_get_display_name(
    ffi.Pointer<FlatpakInstallation> self,
  ) {
    return _flatpak_installation_get_display_name(
      self,
    );
  }

  late final _flatpak_installation_get_display_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstallation>)>>(
      'flatpak_installation_get_display_name');
  late final _flatpak_installation_get_display_name =
      _flatpak_installation_get_display_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakInstallation>)>();

  int flatpak_installation_get_priority(
    ffi.Pointer<FlatpakInstallation> self,
  ) {
    return _flatpak_installation_get_priority(
      self,
    );
  }

  late final _flatpak_installation_get_priorityPtr = _lookup<
          ffi.NativeFunction<gint Function(ffi.Pointer<FlatpakInstallation>)>>(
      'flatpak_installation_get_priority');
  late final _flatpak_installation_get_priority =
      _flatpak_installation_get_priorityPtr
          .asFunction<int Function(ffi.Pointer<FlatpakInstallation>)>();

  int flatpak_installation_get_storage_type(
    ffi.Pointer<FlatpakInstallation> self,
  ) {
    return _flatpak_installation_get_storage_type(
      self,
    );
  }

  late final _flatpak_installation_get_storage_typePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<FlatpakInstallation>)>>(
      'flatpak_installation_get_storage_type');
  late final _flatpak_installation_get_storage_type =
      _flatpak_installation_get_storage_typePtr
          .asFunction<int Function(ffi.Pointer<FlatpakInstallation>)>();

  int flatpak_installation_launch(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    ffi.Pointer<ffi.Char> commit,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_launch(
      self,
      name,
      arch,
      branch,
      commit,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_launchPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_launch');
  late final _flatpak_installation_launch =
      _flatpak_installation_launchPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_launch_full(
    ffi.Pointer<FlatpakInstallation> self,
    int flags,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    ffi.Pointer<ffi.Char> commit,
    ffi.Pointer<ffi.Pointer<FlatpakInstance>> instance_out,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_launch_full(
      self,
      flags,
      name,
      arch,
      branch,
      commit,
      instance_out,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_launch_fullPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<FlatpakInstance>>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_launch_full');
  late final _flatpak_installation_launch_full =
      _flatpak_installation_launch_fullPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<FlatpakInstance>>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GFileMonitor> flatpak_installation_create_monitor(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_create_monitor(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_create_monitorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFileMonitor> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_create_monitor');
  late final _flatpak_installation_create_monitor =
      _flatpak_installation_create_monitorPtr.asFunction<
          ffi.Pointer<GFileMonitor> Function(ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_installed_refs(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_installed_refs(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_installed_refsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_installed_refs');
  late final _flatpak_installation_list_installed_refs =
      _flatpak_installation_list_installed_refsPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_installed_refs_by_kind(
    ffi.Pointer<FlatpakInstallation> self,
    int kind,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_installed_refs_by_kind(
      self,
      kind,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_installed_refs_by_kindPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Int32,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_installed_refs_by_kind');
  late final _flatpak_installation_list_installed_refs_by_kind =
      _flatpak_installation_list_installed_refs_by_kindPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(ffi.Pointer<FlatpakInstallation>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_installed_refs_for_update(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_installed_refs_for_update(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_installed_refs_for_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_installed_refs_for_update');
  late final _flatpak_installation_list_installed_refs_for_update =
      _flatpak_installation_list_installed_refs_for_updatePtr.asFunction<
          ffi.Pointer<GPtrArray> Function(ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_unused_refs(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_unused_refs(
      self,
      arch,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_unused_refsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_unused_refs');
  late final _flatpak_installation_list_unused_refs =
      _flatpak_installation_list_unused_refsPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_unused_refs_with_options(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<GHashTable> metadata_injection,
    ffi.Pointer<GVariant> options,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_unused_refs_with_options(
      self,
      arch,
      metadata_injection,
      options,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_unused_refs_with_optionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GHashTable>,
                  ffi.Pointer<GVariant>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_unused_refs_with_options');
  late final _flatpak_installation_list_unused_refs_with_options =
      _flatpak_installation_list_unused_refs_with_optionsPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GHashTable>,
              ffi.Pointer<GVariant>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_pinned_refs(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_pinned_refs(
      self,
      arch,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_pinned_refsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_pinned_refs');
  late final _flatpak_installation_list_pinned_refs =
      _flatpak_installation_list_pinned_refsPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstalledRef> flatpak_installation_get_installed_ref(
    ffi.Pointer<FlatpakInstallation> self,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_get_installed_ref(
      self,
      kind,
      name,
      arch,
      branch,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_get_installed_refPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstalledRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_get_installed_ref');
  late final _flatpak_installation_get_installed_ref =
      _flatpak_installation_get_installed_refPtr.asFunction<
          ffi.Pointer<FlatpakInstalledRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstalledRef>
      flatpak_installation_get_current_installed_app(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_get_current_installed_app(
      self,
      name,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_get_current_installed_appPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstalledRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_get_current_installed_app');
  late final _flatpak_installation_get_current_installed_app =
      _flatpak_installation_get_current_installed_appPtr.asFunction<
          ffi.Pointer<FlatpakInstalledRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_remotes(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_remotes(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_remotesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_remotes');
  late final _flatpak_installation_list_remotes =
      _flatpak_installation_list_remotesPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_remotes_by_type(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Int32> types,
    int num_types,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_remotes_by_type(
      self,
      types,
      num_types,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_remotes_by_typePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Int32>,
                  gsize,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_remotes_by_type');
  late final _flatpak_installation_list_remotes_by_type =
      _flatpak_installation_list_remotes_by_typePtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Int32>,
              int,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakRemote> flatpak_installation_get_remote_by_name(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<gchar> name,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_get_remote_by_name(
      self,
      name,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_get_remote_by_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakRemote> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<gchar>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_get_remote_by_name');
  late final _flatpak_installation_get_remote_by_name =
      _flatpak_installation_get_remote_by_namePtr.asFunction<
          ffi.Pointer<FlatpakRemote> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<gchar>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_add_remote(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<FlatpakRemote> remote,
    int if_needed,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_add_remote(
      self,
      remote,
      if_needed,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_add_remotePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<FlatpakRemote>,
                  gboolean,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_add_remote');
  late final _flatpak_installation_add_remote =
      _flatpak_installation_add_remotePtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<FlatpakRemote>,
              int,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_modify_remote(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<FlatpakRemote> remote,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_modify_remote(
      self,
      remote,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_modify_remotePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<FlatpakRemote>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_modify_remote');
  late final _flatpak_installation_modify_remote =
      _flatpak_installation_modify_remotePtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<FlatpakRemote>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_remove_remote(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_remove_remote(
      self,
      name,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_remove_remotePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_remove_remote');
  late final _flatpak_installation_remove_remote =
      _flatpak_installation_remove_remotePtr.asFunction<
          int Function(ffi.Pointer<FlatpakInstallation>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_update_remote_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_update_remote_sync(
      self,
      name,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_update_remote_syncPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_update_remote_sync');
  late final _flatpak_installation_update_remote_sync =
      _flatpak_installation_update_remote_syncPtr.asFunction<
          int Function(ffi.Pointer<FlatpakInstallation>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_set_config_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_set_config_sync(
      self,
      key,
      value,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_set_config_syncPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_set_config_sync');
  late final _flatpak_installation_set_config_sync =
      _flatpak_installation_set_config_syncPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_get_min_free_space_bytes(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<guint64> out_bytes,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_get_min_free_space_bytes(
      self,
      out_bytes,
      error,
    );
  }

  late final _flatpak_installation_get_min_free_space_bytesPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<guint64>, ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_get_min_free_space_bytes');
  late final _flatpak_installation_get_min_free_space_bytes =
      _flatpak_installation_get_min_free_space_bytesPtr.asFunction<
          int Function(ffi.Pointer<FlatpakInstallation>, ffi.Pointer<guint64>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> flatpak_installation_get_config(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_get_config(
      self,
      key,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_get_configPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_get_config');
  late final _flatpak_installation_get_config =
      _flatpak_installation_get_configPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Pointer<ffi.Char>> flatpak_installation_get_default_languages(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_get_default_languages(
      self,
      error,
    );
  }

  late final _flatpak_installation_get_default_languagesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_get_default_languages');
  late final _flatpak_installation_get_default_languages =
      _flatpak_installation_get_default_languagesPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Pointer<ffi.Char>> flatpak_installation_get_default_locales(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_get_default_locales(
      self,
      error,
    );
  }

  late final _flatpak_installation_get_default_localesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_get_default_locales');
  late final _flatpak_installation_get_default_locales =
      _flatpak_installation_get_default_localesPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> flatpak_installation_load_app_overrides(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> app_id,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_load_app_overrides(
      self,
      app_id,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_load_app_overridesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_load_app_overrides');
  late final _flatpak_installation_load_app_overrides =
      _flatpak_installation_load_app_overridesPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstalledRef> flatpak_installation_install(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    FlatpakProgressCallback progress,
    gpointer progress_data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_install(
      self,
      remote_name,
      kind,
      name,
      arch,
      branch,
      progress,
      progress_data,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_installPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstalledRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  FlatpakProgressCallback,
                  gpointer,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_install');
  late final _flatpak_installation_install =
      _flatpak_installation_installPtr.asFunction<
          ffi.Pointer<FlatpakInstalledRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              FlatpakProgressCallback,
              gpointer,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstalledRef> flatpak_installation_install_full(
    ffi.Pointer<FlatpakInstallation> self,
    int flags,
    ffi.Pointer<ffi.Char> remote_name,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    ffi.Pointer<ffi.Pointer<ffi.Char>> subpaths,
    FlatpakProgressCallback progress,
    gpointer progress_data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_install_full(
      self,
      flags,
      remote_name,
      kind,
      name,
      arch,
      branch,
      subpaths,
      progress,
      progress_data,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_install_fullPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstalledRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  FlatpakProgressCallback,
                  gpointer,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_install_full');
  late final _flatpak_installation_install_full =
      _flatpak_installation_install_fullPtr.asFunction<
          ffi.Pointer<FlatpakInstalledRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              FlatpakProgressCallback,
              gpointer,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstalledRef> flatpak_installation_update(
    ffi.Pointer<FlatpakInstallation> self,
    int flags,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    FlatpakProgressCallback progress,
    gpointer progress_data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_update(
      self,
      flags,
      kind,
      name,
      arch,
      branch,
      progress,
      progress_data,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstalledRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  FlatpakProgressCallback,
                  gpointer,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_update');
  late final _flatpak_installation_update =
      _flatpak_installation_updatePtr.asFunction<
          ffi.Pointer<FlatpakInstalledRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              int,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              FlatpakProgressCallback,
              gpointer,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstalledRef> flatpak_installation_update_full(
    ffi.Pointer<FlatpakInstallation> self,
    int flags,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    ffi.Pointer<ffi.Pointer<ffi.Char>> subpaths,
    FlatpakProgressCallback progress,
    gpointer progress_data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_update_full(
      self,
      flags,
      kind,
      name,
      arch,
      branch,
      subpaths,
      progress,
      progress_data,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_update_fullPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstalledRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  FlatpakProgressCallback,
                  gpointer,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_update_full');
  late final _flatpak_installation_update_full =
      _flatpak_installation_update_fullPtr.asFunction<
          ffi.Pointer<FlatpakInstalledRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              int,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              FlatpakProgressCallback,
              gpointer,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakInstalledRef> flatpak_installation_install_bundle(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GFile> file,
    FlatpakProgressCallback progress,
    gpointer progress_data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_install_bundle(
      self,
      file,
      progress,
      progress_data,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_install_bundlePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstalledRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GFile>,
                  FlatpakProgressCallback,
                  gpointer,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_install_bundle');
  late final _flatpak_installation_install_bundle =
      _flatpak_installation_install_bundlePtr.asFunction<
          ffi.Pointer<FlatpakInstalledRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GFile>,
              FlatpakProgressCallback,
              gpointer,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakRemoteRef> flatpak_installation_install_ref_file(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GBytes> ref_file_data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_install_ref_file(
      self,
      ref_file_data,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_install_ref_filePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakRemoteRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GBytes>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_install_ref_file');
  late final _flatpak_installation_install_ref_file =
      _flatpak_installation_install_ref_filePtr.asFunction<
          ffi.Pointer<FlatpakRemoteRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GBytes>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_uninstall(
    ffi.Pointer<FlatpakInstallation> self,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    FlatpakProgressCallback progress,
    gpointer progress_data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_uninstall(
      self,
      kind,
      name,
      arch,
      branch,
      progress,
      progress_data,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_uninstallPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  FlatpakProgressCallback,
                  gpointer,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_uninstall');
  late final _flatpak_installation_uninstall =
      _flatpak_installation_uninstallPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              FlatpakProgressCallback,
              gpointer,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_uninstall_full(
    ffi.Pointer<FlatpakInstallation> self,
    int flags,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    FlatpakProgressCallback progress,
    gpointer progress_data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_uninstall_full(
      self,
      flags,
      kind,
      name,
      arch,
      branch,
      progress,
      progress_data,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_uninstall_fullPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  FlatpakProgressCallback,
                  gpointer,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_uninstall_full');
  late final _flatpak_installation_uninstall_full =
      _flatpak_installation_uninstall_fullPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              int,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              FlatpakProgressCallback,
              gpointer,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_fetch_remote_size_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    ffi.Pointer<FlatpakRef> ref,
    ffi.Pointer<guint64> download_size,
    ffi.Pointer<guint64> installed_size,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_fetch_remote_size_sync(
      self,
      remote_name,
      ref,
      download_size,
      installed_size,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_fetch_remote_size_syncPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<FlatpakRef>,
                  ffi.Pointer<guint64>,
                  ffi.Pointer<guint64>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_fetch_remote_size_sync');
  late final _flatpak_installation_fetch_remote_size_sync =
      _flatpak_installation_fetch_remote_size_syncPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<FlatpakRef>,
              ffi.Pointer<guint64>,
              ffi.Pointer<guint64>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GBytes> flatpak_installation_fetch_remote_metadata_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    ffi.Pointer<FlatpakRef> ref,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_fetch_remote_metadata_sync(
      self,
      remote_name,
      ref,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_fetch_remote_metadata_syncPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GBytes> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<FlatpakRef>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_fetch_remote_metadata_sync');
  late final _flatpak_installation_fetch_remote_metadata_sync =
      _flatpak_installation_fetch_remote_metadata_syncPtr.asFunction<
          ffi.Pointer<GBytes> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<FlatpakRef>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_remote_refs_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_or_uri,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_remote_refs_sync(
      self,
      remote_or_uri,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_remote_refs_syncPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_remote_refs_sync');
  late final _flatpak_installation_list_remote_refs_sync =
      _flatpak_installation_list_remote_refs_syncPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_remote_refs_sync_full(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_or_uri,
    int flags,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_remote_refs_sync_full(
      self,
      remote_or_uri,
      flags,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_remote_refs_sync_fullPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int32,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_remote_refs_sync_full');
  late final _flatpak_installation_list_remote_refs_sync_full =
      _flatpak_installation_list_remote_refs_sync_fullPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakRemoteRef> flatpak_installation_fetch_remote_ref_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_fetch_remote_ref_sync(
      self,
      remote_name,
      kind,
      name,
      arch,
      branch,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_fetch_remote_ref_syncPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakRemoteRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_fetch_remote_ref_sync');
  late final _flatpak_installation_fetch_remote_ref_sync =
      _flatpak_installation_fetch_remote_ref_syncPtr.asFunction<
          ffi.Pointer<FlatpakRemoteRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakRemoteRef> flatpak_installation_fetch_remote_ref_sync_full(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    int kind,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<ffi.Char> branch,
    int flags,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_fetch_remote_ref_sync_full(
      self,
      remote_name,
      kind,
      name,
      arch,
      branch,
      flags,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_fetch_remote_ref_sync_fullPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakRemoteRef> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int32,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_fetch_remote_ref_sync_full');
  late final _flatpak_installation_fetch_remote_ref_sync_full =
      _flatpak_installation_fetch_remote_ref_sync_fullPtr.asFunction<
          ffi.Pointer<FlatpakRemoteRef> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_update_appstream_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    ffi.Pointer<ffi.Char> arch,
    ffi.Pointer<gboolean> out_changed,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_update_appstream_sync(
      self,
      remote_name,
      arch,
      out_changed,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_update_appstream_syncPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<gboolean>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_update_appstream_sync');
  late final _flatpak_installation_update_appstream_sync =
      _flatpak_installation_update_appstream_syncPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<gboolean>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_update_appstream_full_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    ffi.Pointer<ffi.Char> arch,
    FlatpakProgressCallback progress,
    gpointer progress_data,
    ffi.Pointer<gboolean> out_changed,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_update_appstream_full_sync(
      self,
      remote_name,
      arch,
      progress,
      progress_data,
      out_changed,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_update_appstream_full_syncPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  FlatpakProgressCallback,
                  gpointer,
                  ffi.Pointer<gboolean>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_update_appstream_full_sync');
  late final _flatpak_installation_update_appstream_full_sync =
      _flatpak_installation_update_appstream_full_syncPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              FlatpakProgressCallback,
              gpointer,
              ffi.Pointer<gboolean>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_remote_related_refs_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_remote_related_refs_sync(
      self,
      remote_name,
      ref,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_remote_related_refs_syncPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_list_remote_related_refs_sync');
  late final _flatpak_installation_list_remote_related_refs_sync =
      _flatpak_installation_list_remote_related_refs_syncPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray>
      flatpak_installation_list_remote_related_refs_for_installed_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_remote_related_refs_for_installed_sync(
      self,
      remote_name,
      ref,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_remote_related_refs_for_installed_syncPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Pointer<GPtrArray> Function(
                      ffi.Pointer<FlatpakInstallation>,
                      ffi.Pointer<ffi.Char>,
                      ffi.Pointer<ffi.Char>,
                      ffi.Pointer<GCancellable>,
                      ffi.Pointer<ffi.Pointer<GError>>)>>(
          'flatpak_installation_list_remote_related_refs_for_installed_sync');
  late final _flatpak_installation_list_remote_related_refs_for_installed_sync =
      _flatpak_installation_list_remote_related_refs_for_installed_syncPtr
          .asFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GPtrArray> flatpak_installation_list_installed_related_refs_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_list_installed_related_refs_sync(
      self,
      remote_name,
      ref,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_list_installed_related_refs_syncPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Pointer<GPtrArray> Function(
                      ffi.Pointer<FlatpakInstallation>,
                      ffi.Pointer<ffi.Char>,
                      ffi.Pointer<ffi.Char>,
                      ffi.Pointer<GCancellable>,
                      ffi.Pointer<ffi.Pointer<GError>>)>>(
          'flatpak_installation_list_installed_related_refs_sync');
  late final _flatpak_installation_list_installed_related_refs_sync =
      _flatpak_installation_list_installed_related_refs_syncPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_remove_local_ref_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<ffi.Char> remote_name,
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_remove_local_ref_sync(
      self,
      remote_name,
      ref,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_remove_local_ref_syncPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_remove_local_ref_sync');
  late final _flatpak_installation_remove_local_ref_sync =
      _flatpak_installation_remove_local_ref_syncPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_cleanup_local_refs_sync(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_cleanup_local_refs_sync(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_cleanup_local_refs_syncPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_cleanup_local_refs_sync');
  late final _flatpak_installation_cleanup_local_refs_sync =
      _flatpak_installation_cleanup_local_refs_syncPtr.asFunction<
          int Function(ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_prune_local_repo(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_prune_local_repo(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_prune_local_repoPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_prune_local_repo');
  late final _flatpak_installation_prune_local_repo =
      _flatpak_installation_prune_local_repoPtr.asFunction<
          int Function(ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_installation_run_triggers(
    ffi.Pointer<FlatpakInstallation> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_installation_run_triggers(
      self,
      cancellable,
      error,
    );
  }

  late final _flatpak_installation_run_triggersPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_installation_run_triggers');
  late final _flatpak_installation_run_triggers =
      _flatpak_installation_run_triggersPtr.asFunction<
          int Function(ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_transaction_progress_get_type() {
    return _flatpak_transaction_progress_get_type();
  }

  late final _flatpak_transaction_progress_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_transaction_progress_get_type');
  late final _flatpak_transaction_progress_get_type =
      _flatpak_transaction_progress_get_typePtr.asFunction<int Function()>();

  int flatpak_transaction_operation_get_type() {
    return _flatpak_transaction_operation_get_type();
  }

  late final _flatpak_transaction_operation_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_transaction_operation_get_type');
  late final _flatpak_transaction_operation_get_type =
      _flatpak_transaction_operation_get_typePtr.asFunction<int Function()>();

  int flatpak_transaction_get_type() {
    return _flatpak_transaction_get_type();
  }

  late final _flatpak_transaction_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'flatpak_transaction_get_type');
  late final _flatpak_transaction_get_type =
      _flatpak_transaction_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<FlatpakTransaction> flatpak_transaction_new_for_installation(
    ffi.Pointer<FlatpakInstallation> installation,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_transaction_new_for_installation(
      installation,
      cancellable,
      error,
    );
  }

  late final _flatpak_transaction_new_for_installationPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakTransaction> Function(
                  ffi.Pointer<FlatpakInstallation>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_transaction_new_for_installation');
  late final _flatpak_transaction_new_for_installation =
      _flatpak_transaction_new_for_installationPtr.asFunction<
          ffi.Pointer<FlatpakTransaction> Function(
              ffi.Pointer<FlatpakInstallation>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void flatpak_transaction_progress_set_update_frequency(
    ffi.Pointer<FlatpakTransactionProgress> self,
    int update_interval,
  ) {
    return _flatpak_transaction_progress_set_update_frequency(
      self,
      update_interval,
    );
  }

  late final _flatpak_transaction_progress_set_update_frequencyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransactionProgress>,
              guint)>>('flatpak_transaction_progress_set_update_frequency');
  late final _flatpak_transaction_progress_set_update_frequency =
      _flatpak_transaction_progress_set_update_frequencyPtr.asFunction<
          void Function(ffi.Pointer<FlatpakTransactionProgress>, int)>();

  ffi.Pointer<ffi.Char> flatpak_transaction_progress_get_status(
    ffi.Pointer<FlatpakTransactionProgress> self,
  ) {
    return _flatpak_transaction_progress_get_status(
      self,
    );
  }

  late final _flatpak_transaction_progress_get_statusPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakTransactionProgress>)>>(
      'flatpak_transaction_progress_get_status');
  late final _flatpak_transaction_progress_get_status =
      _flatpak_transaction_progress_get_statusPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakTransactionProgress>)>();

  int flatpak_transaction_progress_get_is_estimating(
    ffi.Pointer<FlatpakTransactionProgress> self,
  ) {
    return _flatpak_transaction_progress_get_is_estimating(
      self,
    );
  }

  late final _flatpak_transaction_progress_get_is_estimatingPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<FlatpakTransactionProgress>)>>(
      'flatpak_transaction_progress_get_is_estimating');
  late final _flatpak_transaction_progress_get_is_estimating =
      _flatpak_transaction_progress_get_is_estimatingPtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionProgress>)>();

  int flatpak_transaction_progress_get_progress(
    ffi.Pointer<FlatpakTransactionProgress> self,
  ) {
    return _flatpak_transaction_progress_get_progress(
      self,
    );
  }

  late final _flatpak_transaction_progress_get_progressPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<FlatpakTransactionProgress>)>>(
      'flatpak_transaction_progress_get_progress');
  late final _flatpak_transaction_progress_get_progress =
      _flatpak_transaction_progress_get_progressPtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionProgress>)>();

  int flatpak_transaction_progress_get_bytes_transferred(
    ffi.Pointer<FlatpakTransactionProgress> self,
  ) {
    return _flatpak_transaction_progress_get_bytes_transferred(
      self,
    );
  }

  late final _flatpak_transaction_progress_get_bytes_transferredPtr = _lookup<
          ffi.NativeFunction<
              guint64 Function(ffi.Pointer<FlatpakTransactionProgress>)>>(
      'flatpak_transaction_progress_get_bytes_transferred');
  late final _flatpak_transaction_progress_get_bytes_transferred =
      _flatpak_transaction_progress_get_bytes_transferredPtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionProgress>)>();

  int flatpak_transaction_progress_get_start_time(
    ffi.Pointer<FlatpakTransactionProgress> self,
  ) {
    return _flatpak_transaction_progress_get_start_time(
      self,
    );
  }

  late final _flatpak_transaction_progress_get_start_timePtr = _lookup<
          ffi.NativeFunction<
              guint64 Function(ffi.Pointer<FlatpakTransactionProgress>)>>(
      'flatpak_transaction_progress_get_start_time');
  late final _flatpak_transaction_progress_get_start_time =
      _flatpak_transaction_progress_get_start_timePtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionProgress>)>();

  int flatpak_transaction_operation_get_operation_type(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_operation_type(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_operation_typePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_operation_type');
  late final _flatpak_transaction_operation_get_operation_type =
      _flatpak_transaction_operation_get_operation_typePtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<ffi.Char> flatpak_transaction_operation_get_ref(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_ref(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_refPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_ref');
  late final _flatpak_transaction_operation_get_ref =
      _flatpak_transaction_operation_get_refPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<GPtrArray> flatpak_transaction_operation_get_related_to_ops(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_related_to_ops(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_related_to_opsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GPtrArray> Function(
                  ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_related_to_ops');
  late final _flatpak_transaction_operation_get_related_to_ops =
      _flatpak_transaction_operation_get_related_to_opsPtr.asFunction<
          ffi.Pointer<GPtrArray> Function(
              ffi.Pointer<FlatpakTransactionOperation>)>();

  int flatpak_transaction_operation_get_is_skipped(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_is_skipped(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_is_skippedPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_is_skipped');
  late final _flatpak_transaction_operation_get_is_skipped =
      _flatpak_transaction_operation_get_is_skippedPtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<ffi.Char> flatpak_transaction_operation_get_remote(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_remote(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_remotePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_remote');
  late final _flatpak_transaction_operation_get_remote =
      _flatpak_transaction_operation_get_remotePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<GFile> flatpak_transaction_operation_get_bundle_path(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_bundle_path(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_bundle_pathPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(
                  ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_bundle_path');
  late final _flatpak_transaction_operation_get_bundle_path =
      _flatpak_transaction_operation_get_bundle_pathPtr.asFunction<
          ffi.Pointer<GFile> Function(
              ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<ffi.Char> flatpak_transaction_operation_get_commit(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_commit(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_commit');
  late final _flatpak_transaction_operation_get_commit =
      _flatpak_transaction_operation_get_commitPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FlatpakTransactionOperation>)>();

  int flatpak_transaction_operation_get_download_size(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_download_size(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_download_sizePtr = _lookup<
          ffi.NativeFunction<
              guint64 Function(ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_download_size');
  late final _flatpak_transaction_operation_get_download_size =
      _flatpak_transaction_operation_get_download_sizePtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionOperation>)>();

  int flatpak_transaction_operation_get_installed_size(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_installed_size(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_installed_sizePtr = _lookup<
          ffi.NativeFunction<
              guint64 Function(ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_installed_size');
  late final _flatpak_transaction_operation_get_installed_size =
      _flatpak_transaction_operation_get_installed_sizePtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<GKeyFile> flatpak_transaction_operation_get_metadata(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_metadata(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_metadataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GKeyFile> Function(
                  ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_metadata');
  late final _flatpak_transaction_operation_get_metadata =
      _flatpak_transaction_operation_get_metadataPtr.asFunction<
          ffi.Pointer<GKeyFile> Function(
              ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<GKeyFile> flatpak_transaction_operation_get_old_metadata(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_old_metadata(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_old_metadataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GKeyFile> Function(
                  ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_old_metadata');
  late final _flatpak_transaction_operation_get_old_metadata =
      _flatpak_transaction_operation_get_old_metadataPtr.asFunction<
          ffi.Pointer<GKeyFile> Function(
              ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<ffi.Pointer<ffi.Char>> flatpak_transaction_operation_get_subpaths(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_subpaths(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_subpathsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
                  ffi.Pointer<FlatpakTransactionOperation>)>>(
      'flatpak_transaction_operation_get_subpaths');
  late final _flatpak_transaction_operation_get_subpaths =
      _flatpak_transaction_operation_get_subpathsPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<FlatpakTransactionOperation>)>();

  int flatpak_transaction_operation_get_requires_authentication(
    ffi.Pointer<FlatpakTransactionOperation> self,
  ) {
    return _flatpak_transaction_operation_get_requires_authentication(
      self,
    );
  }

  late final _flatpak_transaction_operation_get_requires_authenticationPtr =
      _lookup<
              ffi.NativeFunction<
                  gboolean Function(ffi.Pointer<FlatpakTransactionOperation>)>>(
          'flatpak_transaction_operation_get_requires_authentication');
  late final _flatpak_transaction_operation_get_requires_authentication =
      _flatpak_transaction_operation_get_requires_authenticationPtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransactionOperation>)>();

  ffi.Pointer<ffi.Char> flatpak_transaction_operation_type_to_string(
    int kind,
  ) {
    return _flatpak_transaction_operation_type_to_string(
      kind,
    );
  }

  late final _flatpak_transaction_operation_type_to_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'flatpak_transaction_operation_type_to_string');
  late final _flatpak_transaction_operation_type_to_string =
      _flatpak_transaction_operation_type_to_stringPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void flatpak_transaction_set_no_pull(
    ffi.Pointer<FlatpakTransaction> self,
    int no_pull,
  ) {
    return _flatpak_transaction_set_no_pull(
      self,
      no_pull,
    );
  }

  late final _flatpak_transaction_set_no_pullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_no_pull');
  late final _flatpak_transaction_set_no_pull =
      _flatpak_transaction_set_no_pullPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  int flatpak_transaction_get_no_pull(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_get_no_pull(
      self,
    );
  }

  late final _flatpak_transaction_get_no_pullPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_get_no_pull');
  late final _flatpak_transaction_get_no_pull =
      _flatpak_transaction_get_no_pullPtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransaction>)>();

  void flatpak_transaction_set_no_deploy(
    ffi.Pointer<FlatpakTransaction> self,
    int no_deploy,
  ) {
    return _flatpak_transaction_set_no_deploy(
      self,
      no_deploy,
    );
  }

  late final _flatpak_transaction_set_no_deployPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_no_deploy');
  late final _flatpak_transaction_set_no_deploy =
      _flatpak_transaction_set_no_deployPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  int flatpak_transaction_get_no_deploy(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_get_no_deploy(
      self,
    );
  }

  late final _flatpak_transaction_get_no_deployPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_get_no_deploy');
  late final _flatpak_transaction_get_no_deploy =
      _flatpak_transaction_get_no_deployPtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransaction>)>();

  void flatpak_transaction_set_disable_static_deltas(
    ffi.Pointer<FlatpakTransaction> self,
    int disable_static_deltas,
  ) {
    return _flatpak_transaction_set_disable_static_deltas(
      self,
      disable_static_deltas,
    );
  }

  late final _flatpak_transaction_set_disable_static_deltasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_disable_static_deltas');
  late final _flatpak_transaction_set_disable_static_deltas =
      _flatpak_transaction_set_disable_static_deltasPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_set_disable_prune(
    ffi.Pointer<FlatpakTransaction> self,
    int disable_prune,
  ) {
    return _flatpak_transaction_set_disable_prune(
      self,
      disable_prune,
    );
  }

  late final _flatpak_transaction_set_disable_prunePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_disable_prune');
  late final _flatpak_transaction_set_disable_prune =
      _flatpak_transaction_set_disable_prunePtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_set_disable_dependencies(
    ffi.Pointer<FlatpakTransaction> self,
    int disable_dependencies,
  ) {
    return _flatpak_transaction_set_disable_dependencies(
      self,
      disable_dependencies,
    );
  }

  late final _flatpak_transaction_set_disable_dependenciesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_disable_dependencies');
  late final _flatpak_transaction_set_disable_dependencies =
      _flatpak_transaction_set_disable_dependenciesPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_set_disable_related(
    ffi.Pointer<FlatpakTransaction> self,
    int disable_related,
  ) {
    return _flatpak_transaction_set_disable_related(
      self,
      disable_related,
    );
  }

  late final _flatpak_transaction_set_disable_relatedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_disable_related');
  late final _flatpak_transaction_set_disable_related =
      _flatpak_transaction_set_disable_relatedPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_set_disable_auto_pin(
    ffi.Pointer<FlatpakTransaction> self,
    int disable_pin,
  ) {
    return _flatpak_transaction_set_disable_auto_pin(
      self,
      disable_pin,
    );
  }

  late final _flatpak_transaction_set_disable_auto_pinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_disable_auto_pin');
  late final _flatpak_transaction_set_disable_auto_pin =
      _flatpak_transaction_set_disable_auto_pinPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_set_reinstall(
    ffi.Pointer<FlatpakTransaction> self,
    int reinstall,
  ) {
    return _flatpak_transaction_set_reinstall(
      self,
      reinstall,
    );
  }

  late final _flatpak_transaction_set_reinstallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_reinstall');
  late final _flatpak_transaction_set_reinstall =
      _flatpak_transaction_set_reinstallPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_set_no_interaction(
    ffi.Pointer<FlatpakTransaction> self,
    int no_interaction,
  ) {
    return _flatpak_transaction_set_no_interaction(
      self,
      no_interaction,
    );
  }

  late final _flatpak_transaction_set_no_interactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_no_interaction');
  late final _flatpak_transaction_set_no_interaction =
      _flatpak_transaction_set_no_interactionPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_set_force_uninstall(
    ffi.Pointer<FlatpakTransaction> self,
    int force_uninstall,
  ) {
    return _flatpak_transaction_set_force_uninstall(
      self,
      force_uninstall,
    );
  }

  late final _flatpak_transaction_set_force_uninstallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              gboolean)>>('flatpak_transaction_set_force_uninstall');
  late final _flatpak_transaction_set_force_uninstall =
      _flatpak_transaction_set_force_uninstallPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_set_default_arch(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<ffi.Char> arch,
  ) {
    return _flatpak_transaction_set_default_arch(
      self,
      arch,
    );
  }

  late final _flatpak_transaction_set_default_archPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              ffi.Pointer<ffi.Char>)>>('flatpak_transaction_set_default_arch');
  late final _flatpak_transaction_set_default_arch =
      _flatpak_transaction_set_default_archPtr.asFunction<
          void Function(
              ffi.Pointer<FlatpakTransaction>, ffi.Pointer<ffi.Char>)>();

  void flatpak_transaction_set_parent_window(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<ffi.Char> parent_window,
  ) {
    return _flatpak_transaction_set_parent_window(
      self,
      parent_window,
    );
  }

  late final _flatpak_transaction_set_parent_windowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              ffi.Pointer<ffi.Char>)>>('flatpak_transaction_set_parent_window');
  late final _flatpak_transaction_set_parent_window =
      _flatpak_transaction_set_parent_windowPtr.asFunction<
          void Function(
              ffi.Pointer<FlatpakTransaction>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> flatpak_transaction_get_parent_window(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_get_parent_window(
      self,
    );
  }

  late final _flatpak_transaction_get_parent_windowPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_get_parent_window');
  late final _flatpak_transaction_get_parent_window =
      _flatpak_transaction_get_parent_windowPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<FlatpakTransaction>)>();

  void flatpak_transaction_set_include_unused_uninstall_ops(
    ffi.Pointer<FlatpakTransaction> self,
    int include_unused_uninstall_ops,
  ) {
    return _flatpak_transaction_set_include_unused_uninstall_ops(
      self,
      include_unused_uninstall_ops,
    );
  }

  late final _flatpak_transaction_set_include_unused_uninstall_opsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<FlatpakTransaction>, gboolean)>>(
      'flatpak_transaction_set_include_unused_uninstall_ops');
  late final _flatpak_transaction_set_include_unused_uninstall_ops =
      _flatpak_transaction_set_include_unused_uninstall_opsPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  int flatpak_transaction_get_include_unused_uninstall_ops(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_get_include_unused_uninstall_ops(
      self,
    );
  }

  late final _flatpak_transaction_get_include_unused_uninstall_opsPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_get_include_unused_uninstall_ops');
  late final _flatpak_transaction_get_include_unused_uninstall_ops =
      _flatpak_transaction_get_include_unused_uninstall_opsPtr
          .asFunction<int Function(ffi.Pointer<FlatpakTransaction>)>();

  void flatpak_transaction_add_dependency_source(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<FlatpakInstallation> installation,
  ) {
    return _flatpak_transaction_add_dependency_source(
      self,
      installation,
    );
  }

  late final _flatpak_transaction_add_dependency_sourcePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
                  ffi.Pointer<FlatpakInstallation>)>>(
      'flatpak_transaction_add_dependency_source');
  late final _flatpak_transaction_add_dependency_source =
      _flatpak_transaction_add_dependency_sourcePtr.asFunction<
          void Function(ffi.Pointer<FlatpakTransaction>,
              ffi.Pointer<FlatpakInstallation>)>();

  void flatpak_transaction_add_sideload_repo(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _flatpak_transaction_add_sideload_repo(
      self,
      path,
    );
  }

  late final _flatpak_transaction_add_sideload_repoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              ffi.Pointer<ffi.Char>)>>('flatpak_transaction_add_sideload_repo');
  late final _flatpak_transaction_add_sideload_repo =
      _flatpak_transaction_add_sideload_repoPtr.asFunction<
          void Function(
              ffi.Pointer<FlatpakTransaction>, ffi.Pointer<ffi.Char>)>();

  void flatpak_transaction_add_default_dependency_sources(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_add_default_dependency_sources(
      self,
    );
  }

  late final _flatpak_transaction_add_default_dependency_sourcesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_add_default_dependency_sources');
  late final _flatpak_transaction_add_default_dependency_sources =
      _flatpak_transaction_add_default_dependency_sourcesPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>)>();

  int flatpak_transaction_run(
    ffi.Pointer<FlatpakTransaction> transaction,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_transaction_run(
      transaction,
      cancellable,
      error,
    );
  }

  late final _flatpak_transaction_runPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<FlatpakTransaction>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('flatpak_transaction_run');
  late final _flatpak_transaction_run = _flatpak_transaction_runPtr.asFunction<
      int Function(ffi.Pointer<FlatpakTransaction>, ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<FlatpakTransactionOperation>
      flatpak_transaction_get_current_operation(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_get_current_operation(
      self,
    );
  }

  late final _flatpak_transaction_get_current_operationPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakTransactionOperation> Function(
                  ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_get_current_operation');
  late final _flatpak_transaction_get_current_operation =
      _flatpak_transaction_get_current_operationPtr.asFunction<
          ffi.Pointer<FlatpakTransactionOperation> Function(
              ffi.Pointer<FlatpakTransaction>)>();

  ffi.Pointer<FlatpakInstallation> flatpak_transaction_get_installation(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_get_installation(
      self,
    );
  }

  late final _flatpak_transaction_get_installationPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FlatpakInstallation> Function(
                  ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_get_installation');
  late final _flatpak_transaction_get_installation =
      _flatpak_transaction_get_installationPtr.asFunction<
          ffi.Pointer<FlatpakInstallation> Function(
              ffi.Pointer<FlatpakTransaction>)>();

  ffi.Pointer<GList> flatpak_transaction_get_operations(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_get_operations(
      self,
    );
  }

  late final _flatpak_transaction_get_operationsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GList> Function(ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_get_operations');
  late final _flatpak_transaction_get_operations =
      _flatpak_transaction_get_operationsPtr.asFunction<
          ffi.Pointer<GList> Function(ffi.Pointer<FlatpakTransaction>)>();

  void flatpak_transaction_abort_webflow(
    ffi.Pointer<FlatpakTransaction> self,
    int id,
  ) {
    return _flatpak_transaction_abort_webflow(
      self,
      id,
    );
  }

  late final _flatpak_transaction_abort_webflowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction>,
              guint)>>('flatpak_transaction_abort_webflow');
  late final _flatpak_transaction_abort_webflow =
      _flatpak_transaction_abort_webflowPtr
          .asFunction<void Function(ffi.Pointer<FlatpakTransaction>, int)>();

  void flatpak_transaction_complete_basic_auth(
    ffi.Pointer<FlatpakTransaction> self,
    int id,
    ffi.Pointer<ffi.Char> user,
    ffi.Pointer<ffi.Char> password,
    ffi.Pointer<GVariant> options,
  ) {
    return _flatpak_transaction_complete_basic_auth(
      self,
      id,
      user,
      password,
      options,
    );
  }

  late final _flatpak_transaction_complete_basic_authPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<FlatpakTransaction>,
                  guint,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GVariant>)>>(
      'flatpak_transaction_complete_basic_auth');
  late final _flatpak_transaction_complete_basic_auth =
      _flatpak_transaction_complete_basic_authPtr.asFunction<
          void Function(
              ffi.Pointer<FlatpakTransaction>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GVariant>)>();

  int flatpak_transaction_add_install(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<ffi.Pointer<ffi.Char>> subpaths,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_transaction_add_install(
      self,
      remote,
      ref,
      subpaths,
      error,
    );
  }

  late final _flatpak_transaction_add_installPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakTransaction>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_transaction_add_install');
  late final _flatpak_transaction_add_install =
      _flatpak_transaction_add_installPtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakTransaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_transaction_add_rebase(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<ffi.Pointer<ffi.Char>> subpaths,
    ffi.Pointer<ffi.Pointer<ffi.Char>> previous_ids,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_transaction_add_rebase(
      self,
      remote,
      ref,
      subpaths,
      previous_ids,
      error,
    );
  }

  late final _flatpak_transaction_add_rebasePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakTransaction>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_transaction_add_rebase');
  late final _flatpak_transaction_add_rebase =
      _flatpak_transaction_add_rebasePtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakTransaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_transaction_add_install_bundle(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<GFile> file,
    ffi.Pointer<GBytes> gpg_data,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_transaction_add_install_bundle(
      self,
      file,
      gpg_data,
      error,
    );
  }

  late final _flatpak_transaction_add_install_bundlePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakTransaction>,
                  ffi.Pointer<GFile>,
                  ffi.Pointer<GBytes>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_transaction_add_install_bundle');
  late final _flatpak_transaction_add_install_bundle =
      _flatpak_transaction_add_install_bundlePtr.asFunction<
          int Function(ffi.Pointer<FlatpakTransaction>, ffi.Pointer<GFile>,
              ffi.Pointer<GBytes>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_transaction_add_install_flatpakref(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<GBytes> flatpakref_data,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_transaction_add_install_flatpakref(
      self,
      flatpakref_data,
      error,
    );
  }

  late final _flatpak_transaction_add_install_flatpakrefPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<FlatpakTransaction>,
                  ffi.Pointer<GBytes>, ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_transaction_add_install_flatpakref');
  late final _flatpak_transaction_add_install_flatpakref =
      _flatpak_transaction_add_install_flatpakrefPtr.asFunction<
          int Function(ffi.Pointer<FlatpakTransaction>, ffi.Pointer<GBytes>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_transaction_add_update(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<ffi.Pointer<ffi.Char>> subpaths,
    ffi.Pointer<ffi.Char> commit,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_transaction_add_update(
      self,
      ref,
      subpaths,
      commit,
      error,
    );
  }

  late final _flatpak_transaction_add_updatePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakTransaction>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_transaction_add_update');
  late final _flatpak_transaction_add_update =
      _flatpak_transaction_add_updatePtr.asFunction<
          int Function(
              ffi.Pointer<FlatpakTransaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_transaction_add_uninstall(
    ffi.Pointer<FlatpakTransaction> self,
    ffi.Pointer<ffi.Char> ref,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _flatpak_transaction_add_uninstall(
      self,
      ref,
      error,
    );
  }

  late final _flatpak_transaction_add_uninstallPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<FlatpakTransaction>,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<GError>>)>>(
      'flatpak_transaction_add_uninstall');
  late final _flatpak_transaction_add_uninstall =
      _flatpak_transaction_add_uninstallPtr.asFunction<
          int Function(ffi.Pointer<FlatpakTransaction>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int flatpak_transaction_is_empty(
    ffi.Pointer<FlatpakTransaction> self,
  ) {
    return _flatpak_transaction_is_empty(
      self,
    );
  }

  late final _flatpak_transaction_is_emptyPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<FlatpakTransaction>)>>(
      'flatpak_transaction_is_empty');
  late final _flatpak_transaction_is_empty = _flatpak_transaction_is_emptyPtr
      .asFunction<int Function(ffi.Pointer<FlatpakTransaction>)>();
}

final class max_align_t extends ffi.Opaque {}

final class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

final class tm extends ffi.Struct {
  @ffi.Int()
  external int tm_sec;

  @ffi.Int()
  external int tm_min;

  @ffi.Int()
  external int tm_hour;

  @ffi.Int()
  external int tm_mday;

  @ffi.Int()
  external int tm_mon;

  @ffi.Int()
  external int tm_year;

  @ffi.Int()
  external int tm_wday;

  @ffi.Int()
  external int tm_yday;

  @ffi.Int()
  external int tm_isdst;

  @ffi.Long()
  external int tm_gmtoff;

  external ffi.Pointer<ffi.Char> tm_zone;
}

final class timespec extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__syscall_slong_t()
  external int tv_nsec;
}

typedef __time_t = ffi.Long;
typedef Dart__time_t = int;
typedef __syscall_slong_t = ffi.Long;
typedef Dart__syscall_slong_t = int;

final class itimerspec extends ffi.Struct {
  external timespec it_interval;

  external timespec it_value;
}

final class sigevent extends ffi.Struct {
  external __sigval_t sigev_value;

  @ffi.Int()
  external int sigev_signo;

  @ffi.Int()
  external int sigev_notify;

  external UnnamedUnion1 _sigev_un;
}

typedef __sigval_t = sigval;

final class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Int> _pad;

  @__pid_t()
  external int _tid;

  external UnnamedStruct1 _sigev_thread;
}

typedef __pid_t = ffi.Int;
typedef Dart__pid_t = int;

final class UnnamedStruct1 extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(__sigval_t)>>
      _function;

  external ffi.Pointer<pthread_attr_t> _attribute;
}

final class pthread_attr_t extends ffi.Union {
  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class __locale_struct extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<__locale_data>> __locales;

  external ffi.Pointer<ffi.UnsignedShort> __ctype_b;

  external ffi.Pointer<ffi.Int> __ctype_tolower;

  external ffi.Pointer<ffi.Int> __ctype_toupper;

  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<ffi.Char>> __names;
}

final class __locale_data extends ffi.Opaque {}

final class _GDoubleIEEE754 extends ffi.Opaque {}

final class _GFloatIEEE754 extends ffi.Opaque {}

final class _GTimeVal extends ffi.Struct {
  @glong()
  external int tv_sec;

  @glong()
  external int tv_usec;
}

typedef glong = ffi.Long;
typedef Dartglong = int;

final class _GBytes extends ffi.Opaque {}

final class _GArray extends ffi.Struct {
  external ffi.Pointer<gchar> data;

  @guint()
  external int len;
}

typedef gchar = ffi.Char;
typedef Dartgchar = int;
typedef guint = ffi.UnsignedInt;
typedef Dartguint = int;

final class _GByteArray extends ffi.Struct {
  external ffi.Pointer<guint8> data;

  @guint()
  external int len;
}

typedef guint8 = ffi.UnsignedChar;
typedef Dartguint8 = int;

final class _GPtrArray extends ffi.Struct {
  external ffi.Pointer<gpointer> pdata;

  @guint()
  external int len;
}

typedef gpointer = ffi.Pointer<ffi.Void>;

final class _GError extends ffi.Struct {
  @GQuark()
  external int domain;

  @gint()
  external int code;

  external ffi.Pointer<gchar> message;
}

typedef GQuark = guint32;
typedef guint32 = ffi.UnsignedInt;
typedef Dartguint32 = int;
typedef gint = ffi.Int;
typedef Dartgint = int;

/// GUserDirectory:
/// @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory
/// @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory
/// @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory
/// @G_USER_DIRECTORY_MUSIC: the user's Music directory
/// @G_USER_DIRECTORY_PICTURES: the user's Pictures directory
/// @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory
/// @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory
/// @G_USER_DIRECTORY_VIDEOS: the user's Movies directory
/// @G_USER_N_DIRECTORIES: the number of enum values
///
/// These are logical ids for special directories which are defined
/// depending on the platform used. You should use g_get_user_special_dir()
/// to retrieve the full path associated to the logical id.
///
/// The #GUserDirectory enumeration can be extended at later date. Not
/// every platform has a directory for every logical id in this
/// enumeration.
///
/// Since: 2.14
abstract class GUserDirectory {
  static const int G_USER_DIRECTORY_DESKTOP = 0;
  static const int G_USER_DIRECTORY_DOCUMENTS = 1;
  static const int G_USER_DIRECTORY_DOWNLOAD = 2;
  static const int G_USER_DIRECTORY_MUSIC = 3;
  static const int G_USER_DIRECTORY_PICTURES = 4;
  static const int G_USER_DIRECTORY_PUBLIC_SHARE = 5;
  static const int G_USER_DIRECTORY_TEMPLATES = 6;
  static const int G_USER_DIRECTORY_VIDEOS = 7;
  static const int G_USER_N_DIRECTORIES = 8;
}

final class _GDebugKey extends ffi.Struct {
  external ffi.Pointer<gchar> key;

  @guint()
  external int value;
}

abstract class GFormatSizeFlags {
  static const int G_FORMAT_SIZE_DEFAULT = 0;
  static const int G_FORMAT_SIZE_LONG_FORMAT = 1;
  static const int G_FORMAT_SIZE_IEC_UNITS = 2;
  static const int G_FORMAT_SIZE_BITS = 4;
}

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

final class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedLong> __val;
}

final class timeval extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__suseconds_t()
  external int tv_usec;
}

typedef __suseconds_t = ffi.Long;
typedef Dart__suseconds_t = int;

final class fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__fd_mask> __fds_bits;
}

typedef __fd_mask = ffi.Long;
typedef Dart__fd_mask = int;

final class __atomic_wide_counter extends ffi.Union {
  @ffi.UnsignedLongLong()
  external int __value64;

  external UnnamedStruct4 __value32;
}

final class UnnamedStruct4 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __low;

  @ffi.UnsignedInt()
  external int __high;
}

final class __pthread_internal_list extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_list> __prev;

  external ffi.Pointer<__pthread_internal_list> __next;
}

final class __pthread_internal_slist extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_slist> __next;
}

final class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int()
  external int __lock;

  @ffi.UnsignedInt()
  external int __count;

  @ffi.Int()
  external int __owner;

  @ffi.UnsignedInt()
  external int __nusers;

  @ffi.Int()
  external int __kind;

  @ffi.Short()
  external int __spins;

  @ffi.Short()
  external int __elision;

  external __pthread_list_t __list;
}

typedef __pthread_list_t = __pthread_internal_list;

final class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __readers;

  @ffi.UnsignedInt()
  external int __writers;

  @ffi.UnsignedInt()
  external int __wrphase_futex;

  @ffi.UnsignedInt()
  external int __writers_futex;

  @ffi.UnsignedInt()
  external int __pad3;

  @ffi.UnsignedInt()
  external int __pad4;

  @ffi.Int()
  external int __cur_writer;

  @ffi.Int()
  external int __shared;

  @ffi.SignedChar()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedChar> __pad1;

  @ffi.UnsignedLong()
  external int __pad2;

  @ffi.UnsignedInt()
  external int __flags;
}

final class __pthread_cond_s extends ffi.Struct {
  external __atomic_wide_counter __wseq;

  external __atomic_wide_counter __g1_start;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_size;

  @ffi.UnsignedInt()
  external int __g1_orig_size;

  @ffi.UnsignedInt()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_signals;
}

final class __once_flag extends ffi.Struct {
  @ffi.Int()
  external int __data;
}

final class pthread_mutexattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class pthread_condattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class pthread_mutex_t extends ffi.Union {
  external __pthread_mutex_s __data;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_cond_t extends ffi.Union {
  external __pthread_cond_s __data;

  @ffi.Array.multi([48])
  external ffi.Array<ffi.Char> __size;

  @ffi.LongLong()
  external int __align;
}

final class pthread_rwlock_t extends ffi.Union {
  external __pthread_rwlock_arch_t __data;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_rwlockattr_t extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_barrier_t extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_barrierattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class random_data extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> fptr;

  external ffi.Pointer<ffi.Int32> rptr;

  external ffi.Pointer<ffi.Int32> state;

  @ffi.Int()
  external int rand_type;

  @ffi.Int()
  external int rand_deg;

  @ffi.Int()
  external int rand_sep;

  external ffi.Pointer<ffi.Int32> end_ptr;
}

final class drand48_data extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __x;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __old_x;

  @ffi.UnsignedShort()
  external int __c;

  @ffi.UnsignedShort()
  external int __init;

  @ffi.UnsignedLongLong()
  external int __a;
}

abstract class GThreadError {
  static const int G_THREAD_ERROR_AGAIN = 0;
}

final class _GThread extends ffi.Struct {
  external GThreadFunc func;

  external gpointer data;

  @gboolean()
  external int joinable;

  @ffi.Int32()
  external int priority;
}

typedef GThreadFunc = ffi.Pointer<ffi.NativeFunction<GThreadFuncFunction>>;
typedef GThreadFuncFunction = gpointer Function(gpointer data);
typedef gboolean = gint;

abstract class GThreadPriority {
  static const int G_THREAD_PRIORITY_LOW = 0;
  static const int G_THREAD_PRIORITY_NORMAL = 1;
  static const int G_THREAD_PRIORITY_HIGH = 2;
  static const int G_THREAD_PRIORITY_URGENT = 3;
}

final class _GMutex extends ffi.Union {
  external gpointer p;

  @ffi.Array.multi([2])
  external ffi.Array<guint> i;
}

final class _GRecMutex extends ffi.Struct {
  external gpointer p;

  @ffi.Array.multi([2])
  external ffi.Array<guint> i;
}

final class _GRWLock extends ffi.Struct {
  external gpointer p;

  @ffi.Array.multi([2])
  external ffi.Array<guint> i;
}

final class _GCond extends ffi.Struct {
  external gpointer p;

  @ffi.Array.multi([2])
  external ffi.Array<guint> i;
}

final class _GPrivate extends ffi.Struct {
  external gpointer p;

  external GDestroyNotify notify;

  @ffi.Array.multi([2])
  external ffi.Array<gpointer> future;
}

typedef GDestroyNotify
    = ffi.Pointer<ffi.NativeFunction<GDestroyNotifyFunction>>;
typedef GDestroyNotifyFunction = ffi.Void Function(gpointer data);
typedef DartGDestroyNotifyFunction = void Function(gpointer data);

final class _GOnce extends ffi.Struct {
  @ffi.Int32()
  external int status;

  external gpointer retval;
}

abstract class GOnceStatus {
  static const int G_ONCE_STATUS_NOTCALLED = 0;
  static const int G_ONCE_STATUS_PROGRESS = 1;
  static const int G_ONCE_STATUS_READY = 2;
}

final class _GAsyncQueue extends ffi.Opaque {}

final class siginfo_t extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @ffi.Int()
  external int __pad0;

  external UnnamedUnion2 _sifields;
}

final class UnnamedUnion2 extends ffi.Union {
  @ffi.Array.multi([28])
  external ffi.Array<ffi.Int> _pad;

  external UnnamedStruct5 _kill;

  external UnnamedStruct6 _timer;

  external UnnamedStruct7 _rt;

  external UnnamedStruct8 _sigchld;

  external UnnamedStruct9 _sigfault;

  external UnnamedStruct11 _sigpoll;

  external UnnamedStruct12 _sigsys;
}

final class UnnamedStruct5 extends ffi.Struct {
  @__pid_t()
  external int si_pid;

  @__uid_t()
  external int si_uid;
}

typedef __uid_t = ffi.UnsignedInt;
typedef Dart__uid_t = int;

final class UnnamedStruct6 extends ffi.Struct {
  @ffi.Int()
  external int si_tid;

  @ffi.Int()
  external int si_overrun;

  external __sigval_t si_sigval;
}

final class UnnamedStruct7 extends ffi.Struct {
  @__pid_t()
  external int si_pid;

  @__uid_t()
  external int si_uid;

  external __sigval_t si_sigval;
}

final class UnnamedStruct8 extends ffi.Struct {
  @__pid_t()
  external int si_pid;

  @__uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  @__clock_t()
  external int si_utime;

  @__clock_t()
  external int si_stime;
}

typedef __clock_t = ffi.Long;
typedef Dart__clock_t = int;

final class UnnamedStruct9 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> si_addr;

  @ffi.Short()
  external int si_addr_lsb;

  external UnnamedUnion3 _bounds;
}

final class UnnamedUnion3 extends ffi.Union {
  external UnnamedStruct10 _addr_bnd;

  @__uint32_t()
  external int _pkey;
}

final class UnnamedStruct10 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _lower;

  external ffi.Pointer<ffi.Void> _upper;
}

typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;

final class UnnamedStruct11 extends ffi.Struct {
  @ffi.Long()
  external int si_band;

  @ffi.Int()
  external int si_fd;
}

final class UnnamedStruct12 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _call_addr;

  @ffi.Int()
  external int _syscall;

  @ffi.UnsignedInt()
  external int _arch;
}

final class sigaction extends ffi.Struct {
  external UnnamedUnion4 __sigaction_handler;

  external __sigset_t sa_mask;

  @ffi.Int()
  external int sa_flags;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> sa_restorer;
}

final class UnnamedUnion4 extends ffi.Union {
  external __sighandler_t sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>>
      sa_sigaction;
}

typedef __sighandler_t
    = ffi.Pointer<ffi.NativeFunction<__sighandler_tFunction>>;
typedef __sighandler_tFunction = ffi.Void Function(ffi.Int);
typedef Dart__sighandler_tFunction = void Function(int);

final class _fpx_sw_bytes extends ffi.Struct {
  @__uint32_t()
  external int magic1;

  @__uint32_t()
  external int extended_size;

  @__uint64_t()
  external int xstate_bv;

  @__uint32_t()
  external int xstate_size;

  @ffi.Array.multi([7])
  external ffi.Array<__uint32_t> __glibc_reserved1;
}

typedef __uint64_t = ffi.UnsignedLong;
typedef Dart__uint64_t = int;

final class _fpreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> significand;

  @ffi.UnsignedShort()
  external int exponent;
}

final class _fpxreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> significand;

  @ffi.UnsignedShort()
  external int exponent;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __glibc_reserved1;
}

final class _xmmreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__uint32_t> element;
}

final class _fpstate extends ffi.Struct {
  @__uint16_t()
  external int cwd;

  @__uint16_t()
  external int swd;

  @__uint16_t()
  external int ftw;

  @__uint16_t()
  external int fop;

  @__uint64_t()
  external int rip;

  @__uint64_t()
  external int rdp;

  @__uint32_t()
  external int mxcsr;

  @__uint32_t()
  external int mxcr_mask;

  @ffi.Array.multi([8])
  external ffi.Array<_fpxreg> _st;

  @ffi.Array.multi([16])
  external ffi.Array<_xmmreg> _xmm;

  @ffi.Array.multi([24])
  external ffi.Array<__uint32_t> __glibc_reserved1;
}

typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;

final class sigcontext extends ffi.Struct {
  @__uint64_t()
  external int r8;

  @__uint64_t()
  external int r9;

  @__uint64_t()
  external int r10;

  @__uint64_t()
  external int r11;

  @__uint64_t()
  external int r12;

  @__uint64_t()
  external int r13;

  @__uint64_t()
  external int r14;

  @__uint64_t()
  external int r15;

  @__uint64_t()
  external int rdi;

  @__uint64_t()
  external int rsi;

  @__uint64_t()
  external int rbp;

  @__uint64_t()
  external int rbx;

  @__uint64_t()
  external int rdx;

  @__uint64_t()
  external int rax;

  @__uint64_t()
  external int rcx;

  @__uint64_t()
  external int rsp;

  @__uint64_t()
  external int rip;

  @__uint64_t()
  external int eflags;

  @ffi.UnsignedShort()
  external int cs;

  @ffi.UnsignedShort()
  external int gs;

  @ffi.UnsignedShort()
  external int fs;

  @ffi.UnsignedShort()
  external int __pad0;

  @__uint64_t()
  external int err;

  @__uint64_t()
  external int trapno;

  @__uint64_t()
  external int oldmask;

  @__uint64_t()
  external int cr2;

  external UnnamedUnion5 unnamed;

  @ffi.Array.multi([8])
  external ffi.Array<__uint64_t> __reserved1;
}

final class UnnamedUnion5 extends ffi.Union {
  external ffi.Pointer<_fpstate> fpstate;

  @__uint64_t()
  external int __fpstate_word;
}

final class _xsave_hdr extends ffi.Struct {
  @__uint64_t()
  external int xstate_bv;

  @ffi.Array.multi([2])
  external ffi.Array<__uint64_t> __glibc_reserved1;

  @ffi.Array.multi([5])
  external ffi.Array<__uint64_t> __glibc_reserved2;
}

final class _ymmh_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> ymmh_space;
}

final class _xstate extends ffi.Struct {
  external _fpstate fpstate;

  external _xsave_hdr xstate_hdr;

  external _ymmh_state ymmh;
}

final class stack_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @ffi.Int()
  external int ss_flags;

  @ffi.Size()
  external int ss_size;
}

final class _libc_fpxreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> significand;

  @ffi.UnsignedShort()
  external int exponent;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __glibc_reserved1;
}

final class _libc_xmmreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__uint32_t> element;
}

final class _libc_fpstate extends ffi.Struct {
  @__uint16_t()
  external int cwd;

  @__uint16_t()
  external int swd;

  @__uint16_t()
  external int ftw;

  @__uint16_t()
  external int fop;

  @__uint64_t()
  external int rip;

  @__uint64_t()
  external int rdp;

  @__uint32_t()
  external int mxcsr;

  @__uint32_t()
  external int mxcr_mask;

  @ffi.Array.multi([8])
  external ffi.Array<_libc_fpxreg> _st;

  @ffi.Array.multi([16])
  external ffi.Array<_libc_xmmreg> _xmm;

  @ffi.Array.multi([24])
  external ffi.Array<__uint32_t> __glibc_reserved1;
}

final class mcontext_t extends ffi.Struct {
  @ffi.Array.multi([23])
  external ffi.Array<greg_t> gregs;

  external fpregset_t fpregs;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedLongLong> __reserved1;
}

typedef greg_t = ffi.LongLong;
typedef Dartgreg_t = int;
typedef fpregset_t = ffi.Pointer<_libc_fpstate>;

final class ucontext_t extends ffi.Struct {
  @ffi.UnsignedLong()
  external int uc_flags;

  external ffi.Pointer<ucontext_t> uc_link;

  external stack_t uc_stack;

  external mcontext_t uc_mcontext;

  external sigset_t uc_sigmask;

  external _libc_fpstate __fpregs_mem;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedLongLong> __ssp;
}

typedef sigset_t = __sigset_t;

final class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

final class _GTimeZone extends ffi.Opaque {}

/// GTimeType:
/// @G_TIME_TYPE_STANDARD: the time is in local standard time
/// @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time
/// @G_TIME_TYPE_UNIVERSAL: the time is in UTC
///
/// Disambiguates a given time in two ways.
///
/// First, specifies if the given time is in universal or local time.
///
/// Second, if the time is in local time, specifies if it is local
/// standard time or local daylight time.  This is important for the case
/// where the same local time occurs twice (during daylight savings time
/// transitions, for example).
abstract class GTimeType {
  static const int G_TIME_TYPE_STANDARD = 0;
  static const int G_TIME_TYPE_DAYLIGHT = 1;
  static const int G_TIME_TYPE_UNIVERSAL = 2;
}

final class _GDateTime extends ffi.Opaque {}

/// GBookmarkFileError:
/// @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed
/// @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found
/// @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did
/// not register a bookmark
/// @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found
/// @G_BOOKMARK_FILE_ERROR_READ: document was ill formed
/// @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was
/// in an unknown encoding
/// @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing
/// @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found
///
/// Error codes returned by bookmark file parsing.
abstract class GBookmarkFileError {
  static const int G_BOOKMARK_FILE_ERROR_INVALID_URI = 0;
  static const int G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1;
  static const int G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2;
  static const int G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3;
  static const int G_BOOKMARK_FILE_ERROR_READ = 4;
  static const int G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5;
  static const int G_BOOKMARK_FILE_ERROR_WRITE = 6;
  static const int G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7;
}

final class _GBookmarkFile extends ffi.Opaque {}

/// GChecksumType:
/// @G_CHECKSUM_MD5: Use the MD5 hashing algorithm
/// @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm
/// @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm
/// @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)
/// @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)
///
/// The hashing algorithm to be used by #GChecksum when performing the
/// digest of some data.
///
/// Note that the #GChecksumType enumeration may be extended at a later
/// date to include new hashing algorithm types.
///
/// Since: 2.16
abstract class GChecksumType {
  static const int G_CHECKSUM_MD5 = 0;
  static const int G_CHECKSUM_SHA1 = 1;
  static const int G_CHECKSUM_SHA256 = 2;
  static const int G_CHECKSUM_SHA512 = 3;
  static const int G_CHECKSUM_SHA384 = 4;
}

final class _GChecksum extends ffi.Opaque {}

/// GConvertError:
/// @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character
/// sets is not supported.
/// @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;
/// or the character sequence could not be represented in the target
/// character set.
/// @G_CONVERT_ERROR_FAILED: Conversion failed for some reason.
/// @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.
/// @G_CONVERT_ERROR_BAD_URI: URI is invalid.
/// @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.
/// @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40
/// @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in
/// conversion output where a NUL-terminated string is expected.
/// Since: 2.56
///
/// Error codes returned by character set conversion routines.
abstract class GConvertError {
  static const int G_CONVERT_ERROR_NO_CONVERSION = 0;
  static const int G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1;
  static const int G_CONVERT_ERROR_FAILED = 2;
  static const int G_CONVERT_ERROR_PARTIAL_INPUT = 3;
  static const int G_CONVERT_ERROR_BAD_URI = 4;
  static const int G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5;
  static const int G_CONVERT_ERROR_NO_MEMORY = 6;
  static const int G_CONVERT_ERROR_EMBEDDED_NUL = 7;
}

final class _GIConv extends ffi.Opaque {}

final class _GData extends ffi.Opaque {}

final class _GDate extends ffi.Opaque {}

abstract class GDateDMY {
  static const int G_DATE_DAY = 0;
  static const int G_DATE_MONTH = 1;
  static const int G_DATE_YEAR = 2;
}

abstract class GDateWeekday {
  static const int G_DATE_BAD_WEEKDAY = 0;
  static const int G_DATE_MONDAY = 1;
  static const int G_DATE_TUESDAY = 2;
  static const int G_DATE_WEDNESDAY = 3;
  static const int G_DATE_THURSDAY = 4;
  static const int G_DATE_FRIDAY = 5;
  static const int G_DATE_SATURDAY = 6;
  static const int G_DATE_SUNDAY = 7;
}

abstract class GDateMonth {
  static const int G_DATE_BAD_MONTH = 0;
  static const int G_DATE_JANUARY = 1;
  static const int G_DATE_FEBRUARY = 2;
  static const int G_DATE_MARCH = 3;
  static const int G_DATE_APRIL = 4;
  static const int G_DATE_MAY = 5;
  static const int G_DATE_JUNE = 6;
  static const int G_DATE_JULY = 7;
  static const int G_DATE_AUGUST = 8;
  static const int G_DATE_SEPTEMBER = 9;
  static const int G_DATE_OCTOBER = 10;
  static const int G_DATE_NOVEMBER = 11;
  static const int G_DATE_DECEMBER = 12;
}

final class dirent extends ffi.Struct {
  @__ino_t()
  external int d_ino;

  @__off_t()
  external int d_off;

  @ffi.UnsignedShort()
  external int d_reclen;

  @ffi.UnsignedChar()
  external int d_type;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> d_name;
}

typedef __ino_t = ffi.UnsignedLong;
typedef Dart__ino_t = int;
typedef __off_t = ffi.Long;
typedef Dart__off_t = int;

final class __dirstream extends ffi.Opaque {}

final class _GDir extends ffi.Opaque {}

abstract class GFileError {
  static const int G_FILE_ERROR_EXIST = 0;
  static const int G_FILE_ERROR_ISDIR = 1;
  static const int G_FILE_ERROR_ACCES = 2;
  static const int G_FILE_ERROR_NAMETOOLONG = 3;
  static const int G_FILE_ERROR_NOENT = 4;
  static const int G_FILE_ERROR_NOTDIR = 5;
  static const int G_FILE_ERROR_NXIO = 6;
  static const int G_FILE_ERROR_NODEV = 7;
  static const int G_FILE_ERROR_ROFS = 8;
  static const int G_FILE_ERROR_TXTBSY = 9;
  static const int G_FILE_ERROR_FAULT = 10;
  static const int G_FILE_ERROR_LOOP = 11;
  static const int G_FILE_ERROR_NOSPC = 12;
  static const int G_FILE_ERROR_NOMEM = 13;
  static const int G_FILE_ERROR_MFILE = 14;
  static const int G_FILE_ERROR_NFILE = 15;
  static const int G_FILE_ERROR_BADF = 16;
  static const int G_FILE_ERROR_INVAL = 17;
  static const int G_FILE_ERROR_PIPE = 18;
  static const int G_FILE_ERROR_AGAIN = 19;
  static const int G_FILE_ERROR_INTR = 20;
  static const int G_FILE_ERROR_IO = 21;
  static const int G_FILE_ERROR_PERM = 22;
  static const int G_FILE_ERROR_NOSYS = 23;
  static const int G_FILE_ERROR_FAILED = 24;
}

abstract class GFileTest {
  static const int G_FILE_TEST_IS_REGULAR = 1;
  static const int G_FILE_TEST_IS_SYMLINK = 2;
  static const int G_FILE_TEST_IS_DIR = 4;
  static const int G_FILE_TEST_IS_EXECUTABLE = 8;
  static const int G_FILE_TEST_EXISTS = 16;
}

/// GFileSetContentsFlags:
/// @G_FILE_SET_CONTENTS_NONE: No guarantees about file consistency or durability.
/// The most dangerous setting, which is slightly faster than other settings.
/// @G_FILE_SET_CONTENTS_CONSISTENT: Guarantee file consistency: after a crash,
/// either the old version of the file or the new version of the file will be
/// available, but not a mixture. On Unix systems this equates to an `fsync()`
/// on the file and use of an atomic `rename()` of the new version of the file
/// over the old.
/// @G_FILE_SET_CONTENTS_DURABLE: Guarantee file durability: after a crash, the
/// new version of the file will be available. On Unix systems this equates to
/// an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or
/// the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the
/// directory containing the file after calling `rename()`.
/// @G_FILE_SET_CONTENTS_ONLY_EXISTING: Only apply consistency and durability
/// guarantees if the file already exists. This may speed up file operations
/// if the file doesn’t currently exist, but may result in a corrupted version
/// of the new file if the system crashes while writing it.
///
/// Flags to pass to g_file_set_contents_full() to affect its safety and
/// performance.
///
/// Since: 2.66
abstract class GFileSetContentsFlags {
  static const int G_FILE_SET_CONTENTS_NONE = 0;
  static const int G_FILE_SET_CONTENTS_CONSISTENT = 1;
  static const int G_FILE_SET_CONTENTS_DURABLE = 2;
  static const int G_FILE_SET_CONTENTS_ONLY_EXISTING = 4;
}

final class _GMemVTable extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<gpointer Function(gsize n_bytes)>>
      malloc;

  external ffi.Pointer<
          ffi.NativeFunction<gpointer Function(gpointer mem, gsize n_bytes)>>
      realloc;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(gpointer mem)>>
      free;

  external ffi.Pointer<
      ffi.NativeFunction<
          gpointer Function(gsize n_blocks, gsize n_block_bytes)>> calloc;

  external ffi.Pointer<ffi.NativeFunction<gpointer Function(gsize n_bytes)>>
      try_malloc;

  external ffi.Pointer<
          ffi.NativeFunction<gpointer Function(gpointer mem, gsize n_bytes)>>
      try_realloc;
}

typedef gsize = ffi.UnsignedLong;
typedef Dartgsize = int;

/// GMemVTable:
/// @malloc: function to use for allocating memory.
/// @realloc: function to use for reallocating memory.
/// @free: function to use to free memory.
/// @calloc: function to use for allocating zero-filled memory.
/// @try_malloc: function to use for allocating memory without a default error handler.
/// @try_realloc: function to use for reallocating memory without a default error handler.
///
/// A set of functions used to perform memory allocation. The same #GMemVTable must
/// be used for all allocations in the same program; a call to g_mem_set_vtable(),
/// if it exists, should be prior to any use of GLib.
///
/// This functions related to this has been deprecated in 2.46, and no longer work.
typedef GMemVTable = _GMemVTable;

final class _GNode extends ffi.Struct {
  external gpointer data;

  external ffi.Pointer<GNode> next;

  external ffi.Pointer<GNode> prev;

  external ffi.Pointer<GNode> parent;

  external ffi.Pointer<GNode> children;
}

typedef GNode = _GNode;

abstract class GTraverseFlags {
  static const int G_TRAVERSE_LEAVES = 1;
  static const int G_TRAVERSE_NON_LEAVES = 2;
  static const int G_TRAVERSE_ALL = 3;
  static const int G_TRAVERSE_MASK = 3;
  static const int G_TRAVERSE_LEAFS = 1;
  static const int G_TRAVERSE_NON_LEAFS = 2;
}

abstract class GTraverseType {
  static const int G_IN_ORDER = 0;
  static const int G_PRE_ORDER = 1;
  static const int G_POST_ORDER = 2;
  static const int G_LEVEL_ORDER = 3;
}

final class _GList extends ffi.Struct {
  external gpointer data;

  external ffi.Pointer<GList> next;

  external ffi.Pointer<GList> prev;
}

typedef GList = _GList;

final class _GHashTable extends ffi.Opaque {}

final class _GHashTableIter extends ffi.Struct {
  external gpointer dummy1;

  external gpointer dummy2;

  external gpointer dummy3;

  @ffi.Int()
  external int dummy4;

  @gboolean()
  external int dummy5;

  external gpointer dummy6;
}

final class _GHmac extends ffi.Opaque {}

final class _GHook extends ffi.Struct {
  external gpointer data;

  external ffi.Pointer<GHook> next;

  external ffi.Pointer<GHook> prev;

  @guint()
  external int ref_count;

  @gulong()
  external int hook_id;

  @guint()
  external int flags;

  external gpointer func;

  external GDestroyNotify destroy;
}

typedef GHook = _GHook;
typedef gulong = ffi.UnsignedLong;
typedef Dartgulong = int;

final class _GHookList extends ffi.Opaque {}

abstract class GHookFlagMask {
  static const int G_HOOK_FLAG_ACTIVE = 1;
  static const int G_HOOK_FLAG_IN_CALL = 2;
  static const int G_HOOK_FLAG_MASK = 15;
}

/// GPollFD:
/// @fd: the file descriptor to poll (or a HANDLE on Win32)
/// @events: a bitwise combination from #GIOCondition, specifying which
/// events should be polled for. Typically for reading from a file
/// descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and
/// for writing you would use %G_IO_OUT | %G_IO_ERR.
/// @revents: a bitwise combination of flags from #GIOCondition, returned
/// from the poll() function to indicate which events occurred.
///
/// Represents a file descriptor, which events to poll for, and which events
/// occurred.
final class _GPollFD extends ffi.Struct {
  @gint()
  external int fd;

  @gushort()
  external int events;

  @gushort()
  external int revents;
}

typedef gushort = ffi.UnsignedShort;
typedef Dartgushort = int;

final class _GSList extends ffi.Struct {
  external gpointer data;

  external ffi.Pointer<GSList> next;
}

typedef GSList = _GSList;

abstract class GIOCondition {
  static const int G_IO_IN = 1;
  static const int G_IO_OUT = 4;
  static const int G_IO_PRI = 2;
  static const int G_IO_ERR = 8;
  static const int G_IO_HUP = 16;
  static const int G_IO_NVAL = 32;
}

/// GMainContextFlags:
/// @G_MAIN_CONTEXT_FLAGS_NONE: Default behaviour.
/// @G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: Assume that polling for events will
/// free the thread to process other jobs. That's useful if you're using
/// `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in
/// other event loops.
///
/// Flags to pass to g_main_context_new_with_flags() which affect the behaviour
/// of a #GMainContext.
///
/// Since: 2.72
abstract class GMainContextFlags {
  static const int G_MAIN_CONTEXT_FLAGS_NONE = 0;
  static const int G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING = 1;
}

final class _GMainContext extends ffi.Opaque {}

final class _GMainLoop extends ffi.Opaque {}

final class _GSource extends ffi.Struct {
  external gpointer callback_data;

  external ffi.Pointer<GSourceCallbackFuncs> callback_funcs;

  external ffi.Pointer<GSourceFuncs> source_funcs;

  @guint()
  external int ref_count;

  external ffi.Pointer<GMainContext> context;

  @gint()
  external int priority;

  @guint()
  external int flags;

  @guint()
  external int source_id;

  external ffi.Pointer<GSList> poll_fds;

  external ffi.Pointer<GSource> prev;

  external ffi.Pointer<GSource> next;

  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<GSourcePrivate> priv;
}

/// GSourceCallbackFuncs:
/// @ref: Called when a reference is added to the callback object
/// @unref: Called when a reference to the callback object is dropped
/// @get: Called to extract the callback function and data from the
/// callback object.
///
/// The `GSourceCallbackFuncs` struct contains
/// functions for managing callback objects.
typedef GSourceCallbackFuncs = _GSourceCallbackFuncs;

final class _GSourceCallbackFuncs extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(gpointer cb_data)>>
      ref;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(gpointer cb_data)>>
      unref;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(gpointer cb_data, ffi.Pointer<GSource> source,
              ffi.Pointer<GSourceFunc> func, ffi.Pointer<gpointer> data)>> get1;
}

/// GSource:
///
/// The `GSource` struct is an opaque data type
/// representing an event source.
typedef GSource = _GSource;

/// GSourceFunc:
/// @user_data: data passed to the function, set when the source was
/// created with one of the above functions
///
/// Specifies the type of function passed to g_timeout_add(),
/// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
///
/// When calling g_source_set_callback(), you may need to cast a function of a
/// different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
/// incompatible function types.
///
/// Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and
/// %G_SOURCE_REMOVE are more memorable names for the return value.
typedef GSourceFunc = ffi.Pointer<ffi.NativeFunction<GSourceFuncFunction>>;
typedef GSourceFuncFunction = gboolean Function(gpointer user_data);
typedef DartGSourceFuncFunction = Dartgint Function(gpointer user_data);

/// GSourceFuncs:
/// @prepare: Called before all the file descriptors are polled. If the
/// source can determine that it is ready here (without waiting for the
/// results of the poll() call) it should return %TRUE. It can also return
/// a @timeout_ value which should be the maximum timeout (in milliseconds)
/// which should be passed to the poll() call. The actual timeout used will
/// be -1 if all sources returned -1, or it will be the minimum of all
/// the @timeout_ values returned which were >= 0.  Since 2.36 this may
/// be %NULL, in which case the effect is as if the function always returns
/// %FALSE with a timeout of -1.  If @prepare returns a
/// timeout and the source also has a ready time set, then the
/// lower of the two will be used.
/// @check: Called after all the file descriptors are polled. The source
/// should return %TRUE if it is ready to be dispatched. Note that some
/// time may have passed since the previous prepare function was called,
/// so the source should be checked again here.  Since 2.36 this may
/// be %NULL, in which case the effect is as if the function always returns
/// %FALSE.
/// @dispatch: Called to dispatch the event source, after it has returned
/// %TRUE in either its @prepare or its @check function, or if a ready time
/// has been reached. The @dispatch function receives a callback function and
/// user data. The callback function may be %NULL if the source was never
/// connected to a callback using g_source_set_callback(). The @dispatch
/// function should call the callback function with @user_data and whatever
/// additional parameters are needed for this type of event source. The
/// return value of the @dispatch function should be %G_SOURCE_REMOVE if the
/// source should be removed or %G_SOURCE_CONTINUE to keep it.
/// @finalize: Called when the source is finalized. At this point, the source
/// will have been destroyed, had its callback cleared, and have been removed
/// from its #GMainContext, but it will still have its final reference count,
/// so methods can be called on it from within this function.
///
/// The `GSourceFuncs` struct contains a table of
/// functions used to handle event sources in a generic manner.
///
/// For idle sources, the prepare and check functions always return %TRUE
/// to indicate that the source is always ready to be processed. The prepare
/// function also returns a timeout value of 0 to ensure that the poll() call
/// doesn't block (since that would be time wasted which could have been spent
/// running the idle function).
///
/// For timeout sources, the prepare and check functions both return %TRUE
/// if the timeout interval has expired. The prepare function also returns
/// a timeout value to ensure that the poll() call doesn't block too long
/// and miss the next timeout.
///
/// For file descriptor sources, the prepare function typically returns %FALSE,
/// since it must wait until poll() has been called before it knows whether
/// any events need to be processed. It sets the returned timeout to -1 to
/// indicate that it doesn't mind how long the poll() call blocks. In the
/// check function, it tests the results of the poll() call to see if the
/// required condition has been met, and returns %TRUE if so.
typedef GSourceFuncs = _GSourceFuncs;

final class _GSourceFuncs extends ffi.Struct {
  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GSource> source, ffi.Pointer<gint> timeout_)>>
      prepare;

  external ffi.Pointer<
      ffi.NativeFunction<gboolean Function(ffi.Pointer<GSource> source)>> check;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GSource> source, GSourceFunc callback,
              gpointer user_data)>> dispatch;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GSource> source)>>
      finalize;

  external GSourceFunc closure_callback;

  external GSourceDummyMarshal closure_marshal;
}

/// GSourceDummyMarshal:
///
/// This is just a placeholder for #GClosureMarshal,
/// which cannot be used here for dependency reasons.
typedef GSourceDummyMarshal
    = ffi.Pointer<ffi.NativeFunction<GSourceDummyMarshalFunction>>;
typedef GSourceDummyMarshalFunction = ffi.Void Function();
typedef DartGSourceDummyMarshalFunction = void Function();

/// GMainContext:
///
/// The `GMainContext` struct is an opaque data
/// type representing a set of sources to be handled in a main loop.
typedef GMainContext = _GMainContext;
typedef GSourcePrivate = _GSourcePrivate;

final class _GSourcePrivate extends ffi.Opaque {}

/// GUnicodeType:
/// @G_UNICODE_CONTROL: General category "Other, Control" (Cc)
/// @G_UNICODE_FORMAT: General category "Other, Format" (Cf)
/// @G_UNICODE_UNASSIGNED: General category "Other, Not Assigned" (Cn)
/// @G_UNICODE_PRIVATE_USE: General category "Other, Private Use" (Co)
/// @G_UNICODE_SURROGATE: General category "Other, Surrogate" (Cs)
/// @G_UNICODE_LOWERCASE_LETTER: General category "Letter, Lowercase" (Ll)
/// @G_UNICODE_MODIFIER_LETTER: General category "Letter, Modifier" (Lm)
/// @G_UNICODE_OTHER_LETTER: General category "Letter, Other" (Lo)
/// @G_UNICODE_TITLECASE_LETTER: General category "Letter, Titlecase" (Lt)
/// @G_UNICODE_UPPERCASE_LETTER: General category "Letter, Uppercase" (Lu)
/// @G_UNICODE_SPACING_MARK: General category "Mark, Spacing" (Mc)
/// @G_UNICODE_ENCLOSING_MARK: General category "Mark, Enclosing" (Me)
/// @G_UNICODE_NON_SPACING_MARK: General category "Mark, Nonspacing" (Mn)
/// @G_UNICODE_DECIMAL_NUMBER: General category "Number, Decimal Digit" (Nd)
/// @G_UNICODE_LETTER_NUMBER: General category "Number, Letter" (Nl)
/// @G_UNICODE_OTHER_NUMBER: General category "Number, Other" (No)
/// @G_UNICODE_CONNECT_PUNCTUATION: General category "Punctuation, Connector" (Pc)
/// @G_UNICODE_DASH_PUNCTUATION: General category "Punctuation, Dash" (Pd)
/// @G_UNICODE_CLOSE_PUNCTUATION: General category "Punctuation, Close" (Pe)
/// @G_UNICODE_FINAL_PUNCTUATION: General category "Punctuation, Final quote" (Pf)
/// @G_UNICODE_INITIAL_PUNCTUATION: General category "Punctuation, Initial quote" (Pi)
/// @G_UNICODE_OTHER_PUNCTUATION: General category "Punctuation, Other" (Po)
/// @G_UNICODE_OPEN_PUNCTUATION: General category "Punctuation, Open" (Ps)
/// @G_UNICODE_CURRENCY_SYMBOL: General category "Symbol, Currency" (Sc)
/// @G_UNICODE_MODIFIER_SYMBOL: General category "Symbol, Modifier" (Sk)
/// @G_UNICODE_MATH_SYMBOL: General category "Symbol, Math" (Sm)
/// @G_UNICODE_OTHER_SYMBOL: General category "Symbol, Other" (So)
/// @G_UNICODE_LINE_SEPARATOR: General category "Separator, Line" (Zl)
/// @G_UNICODE_PARAGRAPH_SEPARATOR: General category "Separator, Paragraph" (Zp)
/// @G_UNICODE_SPACE_SEPARATOR: General category "Separator, Space" (Zs)
///
/// These are the possible character classifications from the
/// Unicode specification.
/// See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values).
abstract class GUnicodeType {
  static const int G_UNICODE_CONTROL = 0;
  static const int G_UNICODE_FORMAT = 1;
  static const int G_UNICODE_UNASSIGNED = 2;
  static const int G_UNICODE_PRIVATE_USE = 3;
  static const int G_UNICODE_SURROGATE = 4;
  static const int G_UNICODE_LOWERCASE_LETTER = 5;
  static const int G_UNICODE_MODIFIER_LETTER = 6;
  static const int G_UNICODE_OTHER_LETTER = 7;
  static const int G_UNICODE_TITLECASE_LETTER = 8;
  static const int G_UNICODE_UPPERCASE_LETTER = 9;
  static const int G_UNICODE_SPACING_MARK = 10;
  static const int G_UNICODE_ENCLOSING_MARK = 11;
  static const int G_UNICODE_NON_SPACING_MARK = 12;
  static const int G_UNICODE_DECIMAL_NUMBER = 13;
  static const int G_UNICODE_LETTER_NUMBER = 14;
  static const int G_UNICODE_OTHER_NUMBER = 15;
  static const int G_UNICODE_CONNECT_PUNCTUATION = 16;
  static const int G_UNICODE_DASH_PUNCTUATION = 17;
  static const int G_UNICODE_CLOSE_PUNCTUATION = 18;
  static const int G_UNICODE_FINAL_PUNCTUATION = 19;
  static const int G_UNICODE_INITIAL_PUNCTUATION = 20;
  static const int G_UNICODE_OTHER_PUNCTUATION = 21;
  static const int G_UNICODE_OPEN_PUNCTUATION = 22;
  static const int G_UNICODE_CURRENCY_SYMBOL = 23;
  static const int G_UNICODE_MODIFIER_SYMBOL = 24;
  static const int G_UNICODE_MATH_SYMBOL = 25;
  static const int G_UNICODE_OTHER_SYMBOL = 26;
  static const int G_UNICODE_LINE_SEPARATOR = 27;
  static const int G_UNICODE_PARAGRAPH_SEPARATOR = 28;
  static const int G_UNICODE_SPACE_SEPARATOR = 29;
}

/// GUnicodeBreakType:
/// @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)
/// @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)
/// @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)
/// @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)
/// @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)
/// @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)
/// @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)
/// @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking ("Glue") (GL)
/// @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)
/// @G_UNICODE_BREAK_SPACE: Space (SP)
/// @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)
/// @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)
/// @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)
/// @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)
/// @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)
/// @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)
/// @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)
/// @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)
/// @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)
/// @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)
/// @G_UNICODE_BREAK_NUMERIC: Numeric (NU)
/// @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)
/// @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)
/// @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)
/// @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)
/// @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)
/// @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)
/// @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)
/// @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)
/// @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)
/// @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)
/// @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)
/// @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)
/// @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)
/// @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)
/// @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)
/// @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.
/// @G_UNICODE_BREAK_CLOSE_PARENTHESIS: Closing Parenthesis (CP). Since 2.70
/// @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32
/// @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32
/// @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36
/// @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50
/// @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50
/// @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50
///
/// These are the possible line break classifications.
///
/// Since new unicode versions may add new types here, applications should be ready
/// to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.
///
/// See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/).
abstract class GUnicodeBreakType {
  static const int G_UNICODE_BREAK_MANDATORY = 0;
  static const int G_UNICODE_BREAK_CARRIAGE_RETURN = 1;
  static const int G_UNICODE_BREAK_LINE_FEED = 2;
  static const int G_UNICODE_BREAK_COMBINING_MARK = 3;
  static const int G_UNICODE_BREAK_SURROGATE = 4;
  static const int G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5;
  static const int G_UNICODE_BREAK_INSEPARABLE = 6;
  static const int G_UNICODE_BREAK_NON_BREAKING_GLUE = 7;
  static const int G_UNICODE_BREAK_CONTINGENT = 8;
  static const int G_UNICODE_BREAK_SPACE = 9;
  static const int G_UNICODE_BREAK_AFTER = 10;
  static const int G_UNICODE_BREAK_BEFORE = 11;
  static const int G_UNICODE_BREAK_BEFORE_AND_AFTER = 12;
  static const int G_UNICODE_BREAK_HYPHEN = 13;
  static const int G_UNICODE_BREAK_NON_STARTER = 14;
  static const int G_UNICODE_BREAK_OPEN_PUNCTUATION = 15;
  static const int G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16;
  static const int G_UNICODE_BREAK_QUOTATION = 17;
  static const int G_UNICODE_BREAK_EXCLAMATION = 18;
  static const int G_UNICODE_BREAK_IDEOGRAPHIC = 19;
  static const int G_UNICODE_BREAK_NUMERIC = 20;
  static const int G_UNICODE_BREAK_INFIX_SEPARATOR = 21;
  static const int G_UNICODE_BREAK_SYMBOL = 22;
  static const int G_UNICODE_BREAK_ALPHABETIC = 23;
  static const int G_UNICODE_BREAK_PREFIX = 24;
  static const int G_UNICODE_BREAK_POSTFIX = 25;
  static const int G_UNICODE_BREAK_COMPLEX_CONTEXT = 26;
  static const int G_UNICODE_BREAK_AMBIGUOUS = 27;
  static const int G_UNICODE_BREAK_UNKNOWN = 28;
  static const int G_UNICODE_BREAK_NEXT_LINE = 29;
  static const int G_UNICODE_BREAK_WORD_JOINER = 30;
  static const int G_UNICODE_BREAK_HANGUL_L_JAMO = 31;
  static const int G_UNICODE_BREAK_HANGUL_V_JAMO = 32;
  static const int G_UNICODE_BREAK_HANGUL_T_JAMO = 33;
  static const int G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34;
  static const int G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35;
  static const int G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36;
  static const int G_UNICODE_BREAK_CLOSE_PARENTHESIS = 36;
  static const int G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37;
  static const int G_UNICODE_BREAK_HEBREW_LETTER = 38;
  static const int G_UNICODE_BREAK_REGIONAL_INDICATOR = 39;
  static const int G_UNICODE_BREAK_EMOJI_BASE = 40;
  static const int G_UNICODE_BREAK_EMOJI_MODIFIER = 41;
  static const int G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42;
}

/// GUnicodeScript:
/// @G_UNICODE_SCRIPT_INVALID_CODE:
/// a value never returned from g_unichar_get_script()
/// @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts
/// @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the
/// base glyph to which it is attached
/// @G_UNICODE_SCRIPT_ARABIC:     Arabic
/// @G_UNICODE_SCRIPT_ARMENIAN:   Armenian
/// @G_UNICODE_SCRIPT_BENGALI:    Bengali
/// @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo
/// @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee
/// @G_UNICODE_SCRIPT_COPTIC:     Coptic
/// @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic
/// @G_UNICODE_SCRIPT_DESERET:    Deseret
/// @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari
/// @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic
/// @G_UNICODE_SCRIPT_GEORGIAN:   Georgian
/// @G_UNICODE_SCRIPT_GOTHIC:     Gothic
/// @G_UNICODE_SCRIPT_GREEK:      Greek
/// @G_UNICODE_SCRIPT_GUJARATI:   Gujarati
/// @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi
/// @G_UNICODE_SCRIPT_HAN:        Han
/// @G_UNICODE_SCRIPT_HANGUL:     Hangul
/// @G_UNICODE_SCRIPT_HEBREW:     Hebrew
/// @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana
/// @G_UNICODE_SCRIPT_KANNADA:    Kannada
/// @G_UNICODE_SCRIPT_KATAKANA:   Katakana
/// @G_UNICODE_SCRIPT_KHMER:      Khmer
/// @G_UNICODE_SCRIPT_LAO:        Lao
/// @G_UNICODE_SCRIPT_LATIN:      Latin
/// @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam
/// @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian
/// @G_UNICODE_SCRIPT_MYANMAR:    Myanmar
/// @G_UNICODE_SCRIPT_OGHAM:      Ogham
/// @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic
/// @G_UNICODE_SCRIPT_ORIYA:      Oriya
/// @G_UNICODE_SCRIPT_RUNIC:      Runic
/// @G_UNICODE_SCRIPT_SINHALA:    Sinhala
/// @G_UNICODE_SCRIPT_SYRIAC:     Syriac
/// @G_UNICODE_SCRIPT_TAMIL:      Tamil
/// @G_UNICODE_SCRIPT_TELUGU:     Telugu
/// @G_UNICODE_SCRIPT_THAANA:     Thaana
/// @G_UNICODE_SCRIPT_THAI:       Thai
/// @G_UNICODE_SCRIPT_TIBETAN:    Tibetan
/// @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:
/// Canadian Aboriginal
/// @G_UNICODE_SCRIPT_YI:         Yi
/// @G_UNICODE_SCRIPT_TAGALOG:    Tagalog
/// @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo
/// @G_UNICODE_SCRIPT_BUHID:      Buhid
/// @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa
/// @G_UNICODE_SCRIPT_BRAILLE:    Braille
/// @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot
/// @G_UNICODE_SCRIPT_LIMBU:      Limbu
/// @G_UNICODE_SCRIPT_OSMANYA:    Osmanya
/// @G_UNICODE_SCRIPT_SHAVIAN:    Shavian
/// @G_UNICODE_SCRIPT_LINEAR_B:   Linear B
/// @G_UNICODE_SCRIPT_TAI_LE:     Tai Le
/// @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic
/// @G_UNICODE_SCRIPT_NEW_TAI_LUE:
/// New Tai Lue
/// @G_UNICODE_SCRIPT_BUGINESE:   Buginese
/// @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic
/// @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh
/// @G_UNICODE_SCRIPT_SYLOTI_NAGRI:
/// Syloti Nagri
/// @G_UNICODE_SCRIPT_OLD_PERSIAN:
/// Old Persian
/// @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi
/// @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point
/// @G_UNICODE_SCRIPT_BALINESE:   Balinese
/// @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform
/// @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician
/// @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa
/// @G_UNICODE_SCRIPT_NKO:        N'Ko
/// @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3
/// @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3
/// @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3
/// @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3
/// @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3
/// @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3
/// @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3
/// @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3
/// @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3
/// @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3
/// @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3
/// @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26
/// @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26
/// @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:
/// Egyptian Hieroglpyhs. Since 2.26
/// @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:
/// Imperial Aramaic. Since 2.26
/// @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:
/// Inscriptional Pahlavi. Since 2.26
/// @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:
/// Inscriptional Parthian. Since 2.26
/// @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26
/// @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26
/// @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26
/// @G_UNICODE_SCRIPT_MEETEI_MAYEK:
/// Meetei Mayek. Since 2.26
/// @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:
/// Old South Arabian. Since 2.26
/// @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28
/// @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26
/// @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26
/// @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26
/// @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28
/// @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28
/// @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28
/// @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32
/// @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32
/// @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32
/// @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32
/// @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32
/// @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32
/// @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32
/// @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42
/// @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42
/// @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42
/// @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42
/// @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42
/// @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42
/// @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42
/// @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42
/// @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42
/// @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42
/// @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42
/// @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42
/// @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42
/// @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42
/// @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42
/// @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42
/// @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42
/// @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42
/// @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42
/// @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42
/// @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42
/// @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42
/// @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42
/// @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48
/// @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48
/// @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48
/// @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48
/// @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48
/// @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48
/// @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50
/// @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50
/// @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50
/// @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50
/// @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50
/// @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50
/// @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54
/// @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54
/// @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54
/// @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54
/// @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58
/// @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58
/// @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58
/// @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58
/// @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58
/// @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58
/// @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58
/// @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62
/// @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62
/// @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62
/// @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62
/// @G_UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66
/// @G_UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66
/// @G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66
/// @G_UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66
/// @G_UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72
/// @G_UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72
/// @G_UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72
/// @G_UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72
/// @G_UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72
/// @G_UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72
///
/// The #GUnicodeScript enumeration identifies different writing
/// systems. The values correspond to the names as defined in the
/// Unicode standard. The enumeration has been added in GLib 2.14,
/// and is interchangeable with #PangoScript.
///
/// Note that new types may be added in the future. Applications
/// should be ready to handle unknown values.
/// See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/).
abstract class GUnicodeScript {
  static const int G_UNICODE_SCRIPT_INVALID_CODE = -1;
  static const int G_UNICODE_SCRIPT_COMMON = 0;
  static const int G_UNICODE_SCRIPT_INHERITED = 1;
  static const int G_UNICODE_SCRIPT_ARABIC = 2;
  static const int G_UNICODE_SCRIPT_ARMENIAN = 3;
  static const int G_UNICODE_SCRIPT_BENGALI = 4;
  static const int G_UNICODE_SCRIPT_BOPOMOFO = 5;
  static const int G_UNICODE_SCRIPT_CHEROKEE = 6;
  static const int G_UNICODE_SCRIPT_COPTIC = 7;
  static const int G_UNICODE_SCRIPT_CYRILLIC = 8;
  static const int G_UNICODE_SCRIPT_DESERET = 9;
  static const int G_UNICODE_SCRIPT_DEVANAGARI = 10;
  static const int G_UNICODE_SCRIPT_ETHIOPIC = 11;
  static const int G_UNICODE_SCRIPT_GEORGIAN = 12;
  static const int G_UNICODE_SCRIPT_GOTHIC = 13;
  static const int G_UNICODE_SCRIPT_GREEK = 14;
  static const int G_UNICODE_SCRIPT_GUJARATI = 15;
  static const int G_UNICODE_SCRIPT_GURMUKHI = 16;
  static const int G_UNICODE_SCRIPT_HAN = 17;
  static const int G_UNICODE_SCRIPT_HANGUL = 18;
  static const int G_UNICODE_SCRIPT_HEBREW = 19;
  static const int G_UNICODE_SCRIPT_HIRAGANA = 20;
  static const int G_UNICODE_SCRIPT_KANNADA = 21;
  static const int G_UNICODE_SCRIPT_KATAKANA = 22;
  static const int G_UNICODE_SCRIPT_KHMER = 23;
  static const int G_UNICODE_SCRIPT_LAO = 24;
  static const int G_UNICODE_SCRIPT_LATIN = 25;
  static const int G_UNICODE_SCRIPT_MALAYALAM = 26;
  static const int G_UNICODE_SCRIPT_MONGOLIAN = 27;
  static const int G_UNICODE_SCRIPT_MYANMAR = 28;
  static const int G_UNICODE_SCRIPT_OGHAM = 29;
  static const int G_UNICODE_SCRIPT_OLD_ITALIC = 30;
  static const int G_UNICODE_SCRIPT_ORIYA = 31;
  static const int G_UNICODE_SCRIPT_RUNIC = 32;
  static const int G_UNICODE_SCRIPT_SINHALA = 33;
  static const int G_UNICODE_SCRIPT_SYRIAC = 34;
  static const int G_UNICODE_SCRIPT_TAMIL = 35;
  static const int G_UNICODE_SCRIPT_TELUGU = 36;
  static const int G_UNICODE_SCRIPT_THAANA = 37;
  static const int G_UNICODE_SCRIPT_THAI = 38;
  static const int G_UNICODE_SCRIPT_TIBETAN = 39;
  static const int G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40;
  static const int G_UNICODE_SCRIPT_YI = 41;
  static const int G_UNICODE_SCRIPT_TAGALOG = 42;
  static const int G_UNICODE_SCRIPT_HANUNOO = 43;
  static const int G_UNICODE_SCRIPT_BUHID = 44;
  static const int G_UNICODE_SCRIPT_TAGBANWA = 45;
  static const int G_UNICODE_SCRIPT_BRAILLE = 46;
  static const int G_UNICODE_SCRIPT_CYPRIOT = 47;
  static const int G_UNICODE_SCRIPT_LIMBU = 48;
  static const int G_UNICODE_SCRIPT_OSMANYA = 49;
  static const int G_UNICODE_SCRIPT_SHAVIAN = 50;
  static const int G_UNICODE_SCRIPT_LINEAR_B = 51;
  static const int G_UNICODE_SCRIPT_TAI_LE = 52;
  static const int G_UNICODE_SCRIPT_UGARITIC = 53;
  static const int G_UNICODE_SCRIPT_NEW_TAI_LUE = 54;
  static const int G_UNICODE_SCRIPT_BUGINESE = 55;
  static const int G_UNICODE_SCRIPT_GLAGOLITIC = 56;
  static const int G_UNICODE_SCRIPT_TIFINAGH = 57;
  static const int G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58;
  static const int G_UNICODE_SCRIPT_OLD_PERSIAN = 59;
  static const int G_UNICODE_SCRIPT_KHAROSHTHI = 60;
  static const int G_UNICODE_SCRIPT_UNKNOWN = 61;
  static const int G_UNICODE_SCRIPT_BALINESE = 62;
  static const int G_UNICODE_SCRIPT_CUNEIFORM = 63;
  static const int G_UNICODE_SCRIPT_PHOENICIAN = 64;
  static const int G_UNICODE_SCRIPT_PHAGS_PA = 65;
  static const int G_UNICODE_SCRIPT_NKO = 66;
  static const int G_UNICODE_SCRIPT_KAYAH_LI = 67;
  static const int G_UNICODE_SCRIPT_LEPCHA = 68;
  static const int G_UNICODE_SCRIPT_REJANG = 69;
  static const int G_UNICODE_SCRIPT_SUNDANESE = 70;
  static const int G_UNICODE_SCRIPT_SAURASHTRA = 71;
  static const int G_UNICODE_SCRIPT_CHAM = 72;
  static const int G_UNICODE_SCRIPT_OL_CHIKI = 73;
  static const int G_UNICODE_SCRIPT_VAI = 74;
  static const int G_UNICODE_SCRIPT_CARIAN = 75;
  static const int G_UNICODE_SCRIPT_LYCIAN = 76;
  static const int G_UNICODE_SCRIPT_LYDIAN = 77;
  static const int G_UNICODE_SCRIPT_AVESTAN = 78;
  static const int G_UNICODE_SCRIPT_BAMUM = 79;
  static const int G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80;
  static const int G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81;
  static const int G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82;
  static const int G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83;
  static const int G_UNICODE_SCRIPT_JAVANESE = 84;
  static const int G_UNICODE_SCRIPT_KAITHI = 85;
  static const int G_UNICODE_SCRIPT_LISU = 86;
  static const int G_UNICODE_SCRIPT_MEETEI_MAYEK = 87;
  static const int G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88;
  static const int G_UNICODE_SCRIPT_OLD_TURKIC = 89;
  static const int G_UNICODE_SCRIPT_SAMARITAN = 90;
  static const int G_UNICODE_SCRIPT_TAI_THAM = 91;
  static const int G_UNICODE_SCRIPT_TAI_VIET = 92;
  static const int G_UNICODE_SCRIPT_BATAK = 93;
  static const int G_UNICODE_SCRIPT_BRAHMI = 94;
  static const int G_UNICODE_SCRIPT_MANDAIC = 95;
  static const int G_UNICODE_SCRIPT_CHAKMA = 96;
  static const int G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97;
  static const int G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98;
  static const int G_UNICODE_SCRIPT_MIAO = 99;
  static const int G_UNICODE_SCRIPT_SHARADA = 100;
  static const int G_UNICODE_SCRIPT_SORA_SOMPENG = 101;
  static const int G_UNICODE_SCRIPT_TAKRI = 102;
  static const int G_UNICODE_SCRIPT_BASSA_VAH = 103;
  static const int G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104;
  static const int G_UNICODE_SCRIPT_DUPLOYAN = 105;
  static const int G_UNICODE_SCRIPT_ELBASAN = 106;
  static const int G_UNICODE_SCRIPT_GRANTHA = 107;
  static const int G_UNICODE_SCRIPT_KHOJKI = 108;
  static const int G_UNICODE_SCRIPT_KHUDAWADI = 109;
  static const int G_UNICODE_SCRIPT_LINEAR_A = 110;
  static const int G_UNICODE_SCRIPT_MAHAJANI = 111;
  static const int G_UNICODE_SCRIPT_MANICHAEAN = 112;
  static const int G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113;
  static const int G_UNICODE_SCRIPT_MODI = 114;
  static const int G_UNICODE_SCRIPT_MRO = 115;
  static const int G_UNICODE_SCRIPT_NABATAEAN = 116;
  static const int G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117;
  static const int G_UNICODE_SCRIPT_OLD_PERMIC = 118;
  static const int G_UNICODE_SCRIPT_PAHAWH_HMONG = 119;
  static const int G_UNICODE_SCRIPT_PALMYRENE = 120;
  static const int G_UNICODE_SCRIPT_PAU_CIN_HAU = 121;
  static const int G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122;
  static const int G_UNICODE_SCRIPT_SIDDHAM = 123;
  static const int G_UNICODE_SCRIPT_TIRHUTA = 124;
  static const int G_UNICODE_SCRIPT_WARANG_CITI = 125;
  static const int G_UNICODE_SCRIPT_AHOM = 126;
  static const int G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127;
  static const int G_UNICODE_SCRIPT_HATRAN = 128;
  static const int G_UNICODE_SCRIPT_MULTANI = 129;
  static const int G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130;
  static const int G_UNICODE_SCRIPT_SIGNWRITING = 131;
  static const int G_UNICODE_SCRIPT_ADLAM = 132;
  static const int G_UNICODE_SCRIPT_BHAIKSUKI = 133;
  static const int G_UNICODE_SCRIPT_MARCHEN = 134;
  static const int G_UNICODE_SCRIPT_NEWA = 135;
  static const int G_UNICODE_SCRIPT_OSAGE = 136;
  static const int G_UNICODE_SCRIPT_TANGUT = 137;
  static const int G_UNICODE_SCRIPT_MASARAM_GONDI = 138;
  static const int G_UNICODE_SCRIPT_NUSHU = 139;
  static const int G_UNICODE_SCRIPT_SOYOMBO = 140;
  static const int G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141;
  static const int G_UNICODE_SCRIPT_DOGRA = 142;
  static const int G_UNICODE_SCRIPT_GUNJALA_GONDI = 143;
  static const int G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144;
  static const int G_UNICODE_SCRIPT_MAKASAR = 145;
  static const int G_UNICODE_SCRIPT_MEDEFAIDRIN = 146;
  static const int G_UNICODE_SCRIPT_OLD_SOGDIAN = 147;
  static const int G_UNICODE_SCRIPT_SOGDIAN = 148;
  static const int G_UNICODE_SCRIPT_ELYMAIC = 149;
  static const int G_UNICODE_SCRIPT_NANDINAGARI = 150;
  static const int G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151;
  static const int G_UNICODE_SCRIPT_WANCHO = 152;
  static const int G_UNICODE_SCRIPT_CHORASMIAN = 153;
  static const int G_UNICODE_SCRIPT_DIVES_AKURU = 154;
  static const int G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT = 155;
  static const int G_UNICODE_SCRIPT_YEZIDI = 156;
  static const int G_UNICODE_SCRIPT_CYPRO_MINOAN = 157;
  static const int G_UNICODE_SCRIPT_OLD_UYGHUR = 158;
  static const int G_UNICODE_SCRIPT_TANGSA = 159;
  static const int G_UNICODE_SCRIPT_TOTO = 160;
  static const int G_UNICODE_SCRIPT_VITHKUQI = 161;
  static const int G_UNICODE_SCRIPT_MATH = 162;
}

/// GNormalizeMode:
/// @G_NORMALIZE_DEFAULT: standardize differences that do not affect the
/// text content, such as the above-mentioned accent representation
/// @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT
/// @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with
/// composed forms rather than a maximally decomposed form
/// @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE
/// @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the
/// "compatibility" characters in Unicode, such as SUPERSCRIPT THREE
/// to the standard forms (in this case DIGIT THREE). Formatting
/// information may be lost but for most text operations such
/// characters should be considered the same
/// @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL
/// @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed
/// forms rather than a maximally decomposed form
/// @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE
///
/// Defines how a Unicode string is transformed in a canonical
/// form, standardizing such issues as whether a character with
/// an accent is represented as a base character and combining
/// accent or as a single precomposed character. Unicode strings
/// should generally be normalized before comparing them.
abstract class GNormalizeMode {
  static const int G_NORMALIZE_DEFAULT = 0;
  static const int G_NORMALIZE_NFD = 0;
  static const int G_NORMALIZE_DEFAULT_COMPOSE = 1;
  static const int G_NORMALIZE_NFC = 1;
  static const int G_NORMALIZE_ALL = 2;
  static const int G_NORMALIZE_NFKD = 2;
  static const int G_NORMALIZE_ALL_COMPOSE = 3;
  static const int G_NORMALIZE_NFKC = 3;
}

final class _GString extends ffi.Struct {
  external ffi.Pointer<gchar> str;

  @gsize()
  external int len;

  @gsize()
  external int allocated_len;
}

final class _GIOChannel extends ffi.Opaque {}

final class _GIOFuncs extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GIOChannel> channel,
              ffi.Pointer<gchar> buf,
              gsize count,
              ffi.Pointer<gsize> bytes_read,
              ffi.Pointer<ffi.Pointer<GError>> err)>> io_read;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GIOChannel> channel,
              ffi.Pointer<gchar> buf,
              gsize count,
              ffi.Pointer<gsize> bytes_written,
              ffi.Pointer<ffi.Pointer<GError>> err)>> io_write;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GIOChannel> channel, gint64 offset,
              ffi.Int32 type, ffi.Pointer<ffi.Pointer<GError>> err)>> io_seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GIOChannel> channel,
              ffi.Pointer<ffi.Pointer<GError>> err)>> io_close;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GSource> Function(
                  ffi.Pointer<GIOChannel> channel, ffi.Int32 condition)>>
      io_create_watch;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GIOChannel> channel)>>
      io_free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GIOChannel> channel, ffi.Int32 flags,
              ffi.Pointer<ffi.Pointer<GError>> err)>> io_set_flags;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<GIOChannel> channel)>>
      io_get_flags;
}

abstract class GIOStatus {
  static const int G_IO_STATUS_ERROR = 0;
  static const int G_IO_STATUS_NORMAL = 1;
  static const int G_IO_STATUS_EOF = 2;
  static const int G_IO_STATUS_AGAIN = 3;
}

typedef GIOChannel = _GIOChannel;

/// GError:
/// @domain: error domain, e.g. %G_FILE_ERROR
/// @code: error code, e.g. %G_FILE_ERROR_NOENT
/// @message: human-readable informative error message
///
/// The `GError` structure contains information about
/// an error that has occurred.
typedef GError = _GError;
typedef gint64 = ffi.Long;
typedef Dartgint64 = int;

abstract class GSeekType {
  static const int G_SEEK_CUR = 0;
  static const int G_SEEK_SET = 1;
  static const int G_SEEK_END = 2;
}

abstract class GIOFlags {
  static const int G_IO_FLAG_APPEND = 1;
  static const int G_IO_FLAG_NONBLOCK = 2;
  static const int G_IO_FLAG_IS_READABLE = 4;
  static const int G_IO_FLAG_IS_WRITABLE = 8;
  static const int G_IO_FLAG_IS_WRITEABLE = 8;
  static const int G_IO_FLAG_IS_SEEKABLE = 16;
  static const int G_IO_FLAG_MASK = 31;
  static const int G_IO_FLAG_GET_MASK = 31;
  static const int G_IO_FLAG_SET_MASK = 3;
}

abstract class GIOError {
  static const int G_IO_ERROR_NONE = 0;
  static const int G_IO_ERROR_AGAIN = 1;
  static const int G_IO_ERROR_INVAL = 2;
  static const int G_IO_ERROR_UNKNOWN = 3;
}

abstract class GIOChannelError {
  static const int G_IO_CHANNEL_ERROR_FBIG = 0;
  static const int G_IO_CHANNEL_ERROR_INVAL = 1;
  static const int G_IO_CHANNEL_ERROR_IO = 2;
  static const int G_IO_CHANNEL_ERROR_ISDIR = 3;
  static const int G_IO_CHANNEL_ERROR_NOSPC = 4;
  static const int G_IO_CHANNEL_ERROR_NXIO = 5;
  static const int G_IO_CHANNEL_ERROR_OVERFLOW = 6;
  static const int G_IO_CHANNEL_ERROR_PIPE = 7;
  static const int G_IO_CHANNEL_ERROR_FAILED = 8;
}

abstract class GKeyFileError {
  static const int G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0;
  static const int G_KEY_FILE_ERROR_PARSE = 1;
  static const int G_KEY_FILE_ERROR_NOT_FOUND = 2;
  static const int G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3;
  static const int G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4;
  static const int G_KEY_FILE_ERROR_INVALID_VALUE = 5;
}

final class _GKeyFile extends ffi.Opaque {}

abstract class GKeyFileFlags {
  static const int G_KEY_FILE_NONE = 0;
  static const int G_KEY_FILE_KEEP_COMMENTS = 1;
  static const int G_KEY_FILE_KEEP_TRANSLATIONS = 2;
}

final class _GMappedFile extends ffi.Opaque {}

/// GMarkupError:
/// @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8
/// @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace
/// @G_MARKUP_ERROR_PARSE: document was ill-formed
/// @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser
/// functions; element wasn't known
/// @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser
/// functions; attribute wasn't known
/// @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser
/// functions; content was invalid
/// @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser
/// functions; a required attribute was missing
///
/// Error codes returned by markup parsing.
abstract class GMarkupError {
  static const int G_MARKUP_ERROR_BAD_UTF8 = 0;
  static const int G_MARKUP_ERROR_EMPTY = 1;
  static const int G_MARKUP_ERROR_PARSE = 2;
  static const int G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3;
  static const int G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4;
  static const int G_MARKUP_ERROR_INVALID_CONTENT = 5;
  static const int G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6;
}

/// GMarkupParseFlags:
/// @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use
/// @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked
/// sections are not passed literally to the @passthrough function of
/// the parser. Instead, the content of the section (without the
/// `<![CDATA[` and `]]>`) is
/// passed to the @text function. This flag was added in GLib 2.12
/// @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup
/// itself have line/column information prefixed to them to let the
/// caller know the location of the error. When this flag is set the
/// location information is also prefixed to errors generated by the
/// #GMarkupParser implementation functions
/// @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified
/// attributes and tags, along with their contents.  A qualified
/// attribute or tag is one that contains ':' in its name (ie: is in
/// another namespace).  Since: 2.40.
///
/// Flags that affect the behaviour of the parser.
abstract class GMarkupParseFlags {
  static const int G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1;
  static const int G_MARKUP_TREAT_CDATA_AS_TEXT = 2;
  static const int G_MARKUP_PREFIX_ERROR_POSITION = 4;
  static const int G_MARKUP_IGNORE_QUALIFIED = 8;
}

final class _GMarkupParseContext extends ffi.Opaque {}

/// GMarkupParser:
/// @start_element: Callback to invoke when the opening tag of an element
/// is seen. The callback's @attribute_names and @attribute_values parameters
/// are %NULL-terminated.
/// @end_element: Callback to invoke when the closing tag of an element
/// is seen. Note that this is also called for empty tags like
/// `<empty/>`.
/// @text: Callback to invoke when some text is seen (text is always
/// inside an element). Note that the text of an element may be spread
/// over multiple calls of this function. If the
/// %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also
/// called for the content of CDATA marked sections.
/// @passthrough: Callback to invoke for comments, processing instructions
/// and doctype declarations; if you're re-writing the parsed document,
/// write the passthrough text back out in the same position. If the
/// %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also
/// called for CDATA marked sections.
/// @error: Callback to invoke when an error occurs.
///
/// Any of the fields in #GMarkupParser can be %NULL, in which case they
/// will be ignored. Except for the @error function, any of these callbacks
/// can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,
/// %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT
/// errors are intended to be set from these callbacks. If you set an error
/// from a callback, g_markup_parse_context_parse() will report that error
/// back to its caller.
final class _GMarkupParser extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMarkupParseContext> context,
              ffi.Pointer<gchar> element_name,
              ffi.Pointer<ffi.Pointer<gchar>> attribute_names,
              ffi.Pointer<ffi.Pointer<gchar>> attribute_values,
              gpointer user_data,
              ffi.Pointer<ffi.Pointer<GError>> error)>> start_element;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMarkupParseContext> context,
              ffi.Pointer<gchar> element_name,
              gpointer user_data,
              ffi.Pointer<ffi.Pointer<GError>> error)>> end_element;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMarkupParseContext> context,
              ffi.Pointer<gchar> text,
              gsize text_len,
              gpointer user_data,
              ffi.Pointer<ffi.Pointer<GError>> error)>> text;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMarkupParseContext> context,
              ffi.Pointer<gchar> passthrough_text,
              gsize text_len,
              gpointer user_data,
              ffi.Pointer<ffi.Pointer<GError>> error)>> passthrough;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GMarkupParseContext> context,
              ffi.Pointer<GError> error, gpointer user_data)>> error;
}

/// GMarkupParseContext:
///
/// A parse context is used to parse a stream of bytes that
/// you expect to contain marked-up text.
///
/// See g_markup_parse_context_new(), #GMarkupParser, and so
/// on for more details.
typedef GMarkupParseContext = _GMarkupParseContext;

abstract class GMarkupCollectType {
  static const int G_MARKUP_COLLECT_INVALID = 0;
  static const int G_MARKUP_COLLECT_STRING = 1;
  static const int G_MARKUP_COLLECT_STRDUP = 2;
  static const int G_MARKUP_COLLECT_BOOLEAN = 3;
  static const int G_MARKUP_COLLECT_TRISTATE = 4;
  static const int G_MARKUP_COLLECT_OPTIONAL = 65536;
}

final class _GVariantType extends ffi.Opaque {}

final class _GVariant extends ffi.Opaque {}

abstract class GVariantClass {
  static const int G_VARIANT_CLASS_BOOLEAN = 98;
  static const int G_VARIANT_CLASS_BYTE = 121;
  static const int G_VARIANT_CLASS_INT16 = 110;
  static const int G_VARIANT_CLASS_UINT16 = 113;
  static const int G_VARIANT_CLASS_INT32 = 105;
  static const int G_VARIANT_CLASS_UINT32 = 117;
  static const int G_VARIANT_CLASS_INT64 = 120;
  static const int G_VARIANT_CLASS_UINT64 = 116;
  static const int G_VARIANT_CLASS_HANDLE = 104;
  static const int G_VARIANT_CLASS_DOUBLE = 100;
  static const int G_VARIANT_CLASS_STRING = 115;
  static const int G_VARIANT_CLASS_OBJECT_PATH = 111;
  static const int G_VARIANT_CLASS_SIGNATURE = 103;
  static const int G_VARIANT_CLASS_VARIANT = 118;
  static const int G_VARIANT_CLASS_MAYBE = 109;
  static const int G_VARIANT_CLASS_ARRAY = 97;
  static const int G_VARIANT_CLASS_TUPLE = 40;
  static const int G_VARIANT_CLASS_DICT_ENTRY = 123;
}

final class _GVariantIter extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<gsize> x;
}

final class _GVariantBuilder extends ffi.Struct {
  external UnnamedUnion6 u;
}

final class UnnamedUnion6 extends ffi.Union {
  external UnnamedStruct13 s;

  @ffi.Array.multi([16])
  external ffi.Array<gsize> x;
}

final class UnnamedStruct13 extends ffi.Struct {
  @gsize()
  external int partial_magic;

  external ffi.Pointer<GVariantType> type;

  @ffi.Array.multi([14])
  external ffi.Array<gsize> y;
}

/// GVariantType:
///
/// A type in the GVariant type system.
///
/// Two types may not be compared by value; use g_variant_type_equal() or
/// g_variant_type_is_subtype_of().  May be copied using
/// g_variant_type_copy() and freed using g_variant_type_free().
typedef GVariantType = _GVariantType;

abstract class GVariantParseError {
  static const int G_VARIANT_PARSE_ERROR_FAILED = 0;
  static const int G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1;
  static const int G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2;
  static const int G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3;
  static const int G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4;
  static const int G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5;
  static const int G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6;
  static const int G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7;
  static const int G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8;
  static const int G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9;
  static const int G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10;
  static const int G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11;
  static const int G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12;
  static const int G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13;
  static const int G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14;
  static const int G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15;
  static const int G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16;
  static const int G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17;
  static const int G_VARIANT_PARSE_ERROR_RECURSION = 18;
}

final class _GVariantDict extends ffi.Struct {
  external UnnamedUnion7 u;
}

final class UnnamedUnion7 extends ffi.Union {
  external UnnamedStruct14 s;

  @ffi.Array.multi([16])
  external ffi.Array<gsize> x;
}

final class UnnamedStruct14 extends ffi.Struct {
  external ffi.Pointer<GVariant> asv;

  @gsize()
  external int partial_magic;

  @ffi.Array.multi([14])
  external ffi.Array<gsize> y;
}

typedef GVariant = _GVariant;

abstract class GLogLevelFlags {
  static const int G_LOG_FLAG_RECURSION = 1;
  static const int G_LOG_FLAG_FATAL = 2;
  static const int G_LOG_LEVEL_ERROR = 4;
  static const int G_LOG_LEVEL_CRITICAL = 8;
  static const int G_LOG_LEVEL_WARNING = 16;
  static const int G_LOG_LEVEL_MESSAGE = 32;
  static const int G_LOG_LEVEL_INFO = 64;
  static const int G_LOG_LEVEL_DEBUG = 128;
  static const int G_LOG_LEVEL_MASK = -4;
}

/// GLogWriterOutput:
/// @G_LOG_WRITER_HANDLED: Log writer has handled the log entry.
/// @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.
///
/// Return values from #GLogWriterFuncs to indicate whether the given log entry
/// was successfully handled by the writer, or whether there was an error in
/// handling it (and hence a fallback writer should be used).
///
/// If a #GLogWriterFunc ignores a log entry, it should return
/// %G_LOG_WRITER_HANDLED.
///
/// Since: 2.50
abstract class GLogWriterOutput {
  static const int G_LOG_WRITER_HANDLED = 1;
  static const int G_LOG_WRITER_UNHANDLED = 0;
}

final class _GLogField extends ffi.Struct {
  external ffi.Pointer<gchar> key;

  external gconstpointer value;

  @gssize()
  external int length;
}

typedef gconstpointer = ffi.Pointer<ffi.Void>;
typedef gssize = ffi.Long;
typedef Dartgssize = int;

final class _GOptionContext extends ffi.Opaque {}

final class _GOptionGroup extends ffi.Opaque {}

/// GOptionEntry:
/// @long_name: The long name of an option can be used to specify it
/// in a commandline as `--long_name`. Every option must have a
/// long name. To resolve conflicts if multiple option groups contain
/// the same long name, it is also possible to specify the option as
/// `--groupname-long_name`.
/// @short_name: If an option has a short name, it can be specified
/// `-short_name` in a commandline. @short_name must be  a printable
/// ASCII character different from '-', or zero if the option has no
/// short name.
/// @flags: Flags from #GOptionFlags
/// @arg: The type of the option, as a #GOptionArg
/// @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data
/// must point to a #GOptionArgFunc callback function, which will be
/// called to handle the extra argument. Otherwise, @arg_data is a
/// pointer to a location to store the value, the required type of
/// the location depends on the @arg type:
/// - %G_OPTION_ARG_NONE: %gboolean
/// - %G_OPTION_ARG_STRING: %gchar*
/// - %G_OPTION_ARG_INT: %gint
/// - %G_OPTION_ARG_FILENAME: %gchar*
/// - %G_OPTION_ARG_STRING_ARRAY: %gchar**
/// - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**
/// - %G_OPTION_ARG_DOUBLE: %gdouble
/// If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,
/// the location will contain a newly allocated string if the option
/// was given. That string needs to be freed by the callee using g_free().
/// Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or
/// %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().
/// @description: the description for the option in `--help`
/// output. The @description is translated using the @translate_func
/// of the group, see g_option_group_set_translation_domain().
/// @arg_description: The placeholder to use for the extra argument parsed
/// by the option in `--help` output. The @arg_description is translated
/// using the @translate_func of the group, see
/// g_option_group_set_translation_domain().
///
/// A GOptionEntry struct defines a single option. To have an effect, they
/// must be added to a #GOptionGroup with g_option_context_add_main_entries()
/// or g_option_group_add_entries().
final class _GOptionEntry extends ffi.Struct {
  external ffi.Pointer<gchar> long_name;

  @gchar()
  external int short_name;

  @gint()
  external int flags;

  @ffi.Int32()
  external int arg;

  external gpointer arg_data;

  external ffi.Pointer<gchar> description;

  external ffi.Pointer<gchar> arg_description;
}

/// GOptionArg:
/// @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags.
/// @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument.
/// @G_OPTION_ARG_INT: The option takes an integer argument.
/// @G_OPTION_ARG_CALLBACK: The option provides a callback (of type
/// #GOptionArgFunc) to parse the extra argument.
/// @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will
/// be in the GLib filename encoding rather than UTF-8.
/// @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple
/// uses of the option are collected into an array of strings.
/// @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,
/// multiple uses of the option are collected into an array of strings.
/// @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument
/// can be formatted either for the user's locale or for the "C" locale.
/// Since 2.12
/// @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like
/// %G_OPTION_ARG_INT but for larger numbers. The number can be in
/// decimal base, or in hexadecimal (when prefixed with `0x`, for
/// example, `0xffffffff`). Since 2.12
///
/// The #GOptionArg enum values determine which type of extra argument the
/// options expect to find. If an option expects an extra argument, it can
/// be specified in several ways; with a short option: `-x arg`, with a long
/// option: `--name arg` or combined in a single argument: `--name=arg`.
abstract class GOptionArg {
  static const int G_OPTION_ARG_NONE = 0;
  static const int G_OPTION_ARG_STRING = 1;
  static const int G_OPTION_ARG_INT = 2;
  static const int G_OPTION_ARG_CALLBACK = 3;
  static const int G_OPTION_ARG_FILENAME = 4;
  static const int G_OPTION_ARG_STRING_ARRAY = 5;
  static const int G_OPTION_ARG_FILENAME_ARRAY = 6;
  static const int G_OPTION_ARG_DOUBLE = 7;
  static const int G_OPTION_ARG_INT64 = 8;
}

/// GOptionFlags:
/// @G_OPTION_FLAG_NONE: No flags. Since: 2.42.
/// @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output.
/// @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the
/// `--help` output, even if it is defined in a group.
/// @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this
/// flag indicates that the sense of the option is reversed.
/// @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,
/// this flag indicates that the callback does not take any argument
/// (like a %G_OPTION_ARG_NONE option). Since 2.8
/// @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK
/// kind, this flag indicates that the argument should be passed to the
/// callback in the GLib filename encoding rather than UTF-8. Since 2.8
/// @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK
/// kind, this flag indicates that the argument supply is optional.
/// If no argument is given then data of %GOptionParseFunc will be
/// set to NULL. Since 2.8
/// @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict
/// resolution which prefixes long option names with `groupname-` if
/// there is a conflict. This option should only be used in situations
/// where aliasing is necessary to model some legacy commandline interface.
/// It is not safe to use this option, unless all option groups are under
/// your direct control. Since 2.8.
///
/// Flags which modify individual options.
abstract class GOptionFlags {
  static const int G_OPTION_FLAG_NONE = 0;
  static const int G_OPTION_FLAG_HIDDEN = 1;
  static const int G_OPTION_FLAG_IN_MAIN = 2;
  static const int G_OPTION_FLAG_REVERSE = 4;
  static const int G_OPTION_FLAG_NO_ARG = 8;
  static const int G_OPTION_FLAG_FILENAME = 16;
  static const int G_OPTION_FLAG_OPTIONAL_ARG = 32;
  static const int G_OPTION_FLAG_NOALIAS = 64;
}

/// GOptionError:
/// @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.
/// This error will only be reported, if the parser hasn't been instructed
/// to ignore unknown options, see g_option_context_set_ignore_unknown_options().
/// @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.
/// @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.
///
/// Error codes returned by option parsing.
abstract class GOptionError {
  static const int G_OPTION_ERROR_UNKNOWN_OPTION = 0;
  static const int G_OPTION_ERROR_BAD_VALUE = 1;
  static const int G_OPTION_ERROR_FAILED = 2;
}

final class _GPatternSpec extends ffi.Opaque {}

/// GQueue:
/// @head: a pointer to the first element of the queue
/// @tail: a pointer to the last element of the queue
/// @length: the number of elements in the queue
///
/// Contains the public fields of a
/// [Queue][glib-Double-ended-Queues].
final class _GQueue extends ffi.Struct {
  external ffi.Pointer<GList> head;

  external ffi.Pointer<GList> tail;

  @guint()
  external int length;
}

final class _GRand extends ffi.Opaque {}

/// GRegexError:
/// @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed.
/// @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.
/// @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement
/// string.
/// @G_REGEX_ERROR_MATCH: The match process failed.
/// @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.
/// Since 2.16
/// @G_REGEX_ERROR_STRAY_BACKSLASH: "\\" at end of pattern. Since 2.16
/// @G_REGEX_ERROR_MISSING_CONTROL_CHAR: "\\c" at end of pattern. Since 2.16
/// @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows "\\".
/// Since 2.16
/// @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in "{}"
/// quantifier. Since 2.16
/// @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in "{}" quantifier.
/// Since 2.16
/// @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating "]" for
/// character class. Since 2.16
/// @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence
/// in character class. Since 2.16
/// @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.
/// Since 2.16
/// @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16
/// @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after "(?",
/// "(?<" or "(?P". Since 2.16
/// @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are
/// supported only within a class. Since 2.16
/// @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating ")" or ")"
/// without opening "(". Since 2.16
/// @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent
/// subpattern. Since 2.16
/// @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating ")" after comment.
/// Since 2.16
/// @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.
/// Since 2.16
/// @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16
/// @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not
/// fixed length. Since 2.16
/// @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after "(?(".
/// Since 2.16
/// @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains
/// more than two branches. Since 2.16
/// @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after "(?(".
/// Since 2.16
/// @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.
/// Since 2.16
/// @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating
/// elements are not supported. Since 2.16
/// @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in "\\x{...}" sequence
/// is too large. Since 2.16
/// @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition "(?(0)". Since 2.16
/// @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\C not allowed in
/// lookbehind assertion. Since 2.16
/// @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.
/// Since 2.16
/// @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator
/// in subpattern name. Since 2.16
/// @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have
/// the same name. Since 2.16
/// @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed "\\P" or "\\p" sequence.
/// Since 2.16
/// @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after "\\P" or
/// "\\p". Since 2.16
/// @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long
/// (maximum 32 characters). Since 2.16
/// @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum
/// 10,000). Since 2.16
/// @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than "\\377".
/// Since 2.16
/// @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: "DEFINE" group contains more
/// than one branch. Since 2.16
/// @G_REGEX_ERROR_DEFINE_REPETION: Repeating a "DEFINE" group is not allowed.
/// This error is never raised. Since: 2.16 Deprecated: 2.34
/// @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.
/// Since 2.16
/// @G_REGEX_ERROR_MISSING_BACK_REFERENCE: "\\g" is not followed by a braced,
/// angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16
/// @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34
/// @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing
/// control verb used does not allow an argument. Since: 2.34
/// @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing
/// control verb. Since: 2.34
/// @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34
/// @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34
/// @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34
/// @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,
/// "[" is an invalid data character. Since: 2.34
/// @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the
/// same number are not allowed. Since: 2.34
/// @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control
/// verb requires an argument. Since: 2.34
/// @G_REGEX_ERROR_INVALID_CONTROL_CHAR: "\\c" must be followed by an ASCII
/// character. Since: 2.34
/// @G_REGEX_ERROR_MISSING_NAME: "\\k" is not followed by a braced, angle-bracketed, or
/// quoted name. Since: 2.34
/// @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: "\\N" is not supported in a class. Since: 2.34
/// @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34
/// @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in "(*MARK)", "(*PRUNE)",
/// "(*SKIP)", or "(*THEN)". Since: 2.34
/// @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\u sequence is
/// too large. Since: 2.34
///
/// Error codes returned by regular expressions functions.
///
/// Since: 2.14
abstract class GRegexError {
  static const int G_REGEX_ERROR_COMPILE = 0;
  static const int G_REGEX_ERROR_OPTIMIZE = 1;
  static const int G_REGEX_ERROR_REPLACE = 2;
  static const int G_REGEX_ERROR_MATCH = 3;
  static const int G_REGEX_ERROR_INTERNAL = 4;
  static const int G_REGEX_ERROR_STRAY_BACKSLASH = 101;
  static const int G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102;
  static const int G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103;
  static const int G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104;
  static const int G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105;
  static const int G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106;
  static const int G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107;
  static const int G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108;
  static const int G_REGEX_ERROR_NOTHING_TO_REPEAT = 109;
  static const int G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112;
  static const int G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113;
  static const int G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114;
  static const int G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115;
  static const int G_REGEX_ERROR_UNTERMINATED_COMMENT = 118;
  static const int G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120;
  static const int G_REGEX_ERROR_MEMORY_ERROR = 121;
  static const int G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125;
  static const int G_REGEX_ERROR_MALFORMED_CONDITION = 126;
  static const int G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127;
  static const int G_REGEX_ERROR_ASSERTION_EXPECTED = 128;
  static const int G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130;
  static const int G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131;
  static const int G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134;
  static const int G_REGEX_ERROR_INVALID_CONDITION = 135;
  static const int G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136;
  static const int G_REGEX_ERROR_INFINITE_LOOP = 140;
  static const int G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142;
  static const int G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143;
  static const int G_REGEX_ERROR_MALFORMED_PROPERTY = 146;
  static const int G_REGEX_ERROR_UNKNOWN_PROPERTY = 147;
  static const int G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148;
  static const int G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149;
  static const int G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151;
  static const int G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154;
  static const int G_REGEX_ERROR_DEFINE_REPETION = 155;
  static const int G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156;
  static const int G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157;
  static const int G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158;
  static const int G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN =
      159;
  static const int G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160;
  static const int G_REGEX_ERROR_NUMBER_TOO_BIG = 161;
  static const int G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162;
  static const int G_REGEX_ERROR_MISSING_DIGIT = 163;
  static const int G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164;
  static const int G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165;
  static const int G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED =
      166;
  static const int G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168;
  static const int G_REGEX_ERROR_MISSING_NAME = 169;
  static const int G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171;
  static const int G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172;
  static const int G_REGEX_ERROR_NAME_TOO_LONG = 175;
  static const int G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176;
}

/// GRegexCompileFlags:
/// @G_REGEX_CASELESS: Letters in the pattern match both upper- and
/// lowercase letters. This option can be changed within a pattern
/// by a "(?i)" option setting.
/// @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting
/// of a single line of characters (even if it actually contains
/// newlines). The "start of line" metacharacter ("^") matches only
/// at the start of the string, while the "end of line" metacharacter
/// ("$") matches only at the end of the string, or before a terminating
/// newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When
/// %G_REGEX_MULTILINE is set, the "start of line" and "end of line"
/// constructs match immediately following or immediately before any
/// newline in the string, respectively, as well as at the very start
/// and end. This can be changed within a pattern by a "(?m)" option
/// setting.
/// @G_REGEX_DOTALL: A dot metacharacter (".") in the pattern matches all
/// characters, including newlines. Without it, newlines are excluded.
/// This option can be changed within a pattern by a ("?s") option setting.
/// @G_REGEX_EXTENDED: Whitespace data characters in the pattern are
/// totally ignored except when escaped or inside a character class.
/// Whitespace does not include the VT character (code 11). In addition,
/// characters between an unescaped "#" outside a character class and
/// the next newline character, inclusive, are also ignored. This can
/// be changed within a pattern by a "(?x)" option setting.
/// @G_REGEX_ANCHORED: The pattern is forced to be "anchored", that is,
/// it is constrained to match only at the first matching point in the
/// string that is being searched. This effect can also be achieved by
/// appropriate constructs in the pattern itself such as the "^"
/// metacharacter.
/// @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter ("$") in the pattern
/// matches only at the end of the string. Without this option, a
/// dollar also matches immediately before the final character if
/// it is a newline (but not before any other newlines). This option
/// is ignored if %G_REGEX_MULTILINE is set.
/// @G_REGEX_UNGREEDY: Inverts the "greediness" of the quantifiers so that
/// they are not greedy by default, but become greedy if followed by "?".
/// It can also be set by a "(?U)" option setting within the pattern.
/// @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this
/// flag they are considered as a raw sequence of bytes.
/// @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing
/// parentheses in the pattern. Any opening parenthesis that is not
/// followed by "?" behaves as if it were followed by "?:" but named
/// parentheses can still be used for capturing (and they acquire numbers
/// in the usual way).
/// @G_REGEX_OPTIMIZE: Optimize the regular expression. If the pattern will
/// be used many times, then it may be worth the effort to optimize it
/// to improve the speed of matches.
/// @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the
/// first newline. Since: 2.34
/// @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not
/// be unique. This can be helpful for certain types of pattern when it
/// is known that only one instance of the named subpattern can ever be
/// matched.
/// @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is
/// recognized. If this option is set, the only recognized newline character
/// is '\r'.
/// @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is
/// recognized. If this option is set, the only recognized newline character
/// is '\n'.
/// @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is
/// recognized. If this option is set, the only recognized newline character
/// sequence is '\r\n'.
/// @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence
/// is recognized. If this option is set, the only recognized newline character
/// sequences are '\r', '\n', and '\r\n'. Since: 2.34
/// @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence
/// is recognised. If this option is set, then "\R" only recognizes the newline
/// characters '\r', '\n' and '\r\n'. Since: 2.34
/// @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with
/// JavaScript rather than PCRE. Since: 2.34
///
/// Flags specifying compile-time options.
///
/// Since: 2.14
abstract class GRegexCompileFlags {
  static const int G_REGEX_CASELESS = 1;
  static const int G_REGEX_MULTILINE = 2;
  static const int G_REGEX_DOTALL = 4;
  static const int G_REGEX_EXTENDED = 8;
  static const int G_REGEX_ANCHORED = 16;
  static const int G_REGEX_DOLLAR_ENDONLY = 32;
  static const int G_REGEX_UNGREEDY = 512;
  static const int G_REGEX_RAW = 2048;
  static const int G_REGEX_NO_AUTO_CAPTURE = 4096;
  static const int G_REGEX_OPTIMIZE = 8192;
  static const int G_REGEX_FIRSTLINE = 262144;
  static const int G_REGEX_DUPNAMES = 524288;
  static const int G_REGEX_NEWLINE_CR = 1048576;
  static const int G_REGEX_NEWLINE_LF = 2097152;
  static const int G_REGEX_NEWLINE_CRLF = 3145728;
  static const int G_REGEX_NEWLINE_ANYCRLF = 5242880;
  static const int G_REGEX_BSR_ANYCRLF = 8388608;
  static const int G_REGEX_JAVASCRIPT_COMPAT = 33554432;
}

/// GRegexMatchFlags:
/// @G_REGEX_MATCH_ANCHORED: The pattern is forced to be "anchored", that is,
/// it is constrained to match only at the first matching point in the
/// string that is being searched. This effect can also be achieved by
/// appropriate constructs in the pattern itself such as the "^"
/// metacharacter.
/// @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is
/// not the beginning of a line, so the circumflex metacharacter should
/// not match before it. Setting this without %G_REGEX_MULTILINE (at
/// compile time) causes circumflex never to match. This option affects
/// only the behaviour of the circumflex metacharacter, it does not
/// affect "\A".
/// @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is
/// not the end of a line, so the dollar metacharacter should not match
/// it nor (except in multiline mode) a newline immediately before it.
/// Setting this without %G_REGEX_MULTILINE (at compile time) causes
/// dollar never to match. This option affects only the behaviour of
/// the dollar metacharacter, it does not affect "\Z" or "\z".
/// @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid
/// match if this option is set. If there are alternatives in the pattern,
/// they are tried. If all the alternatives match the empty string, the
/// entire match fails. For example, if the pattern "a?b?" is applied to
/// a string not beginning with "a" or "b", it matches the empty string
/// at the start of the string. With this flag set, this match is not
/// valid, so GRegex searches further into the string for occurrences
/// of "a" or "b".
/// @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more
/// documentation on partial matching see g_match_info_is_partial_match().
/// @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when
/// creating a new #GRegex, setting the '\r' character as line terminator.
/// @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when
/// creating a new #GRegex, setting the '\n' character as line terminator.
/// @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when
/// creating a new #GRegex, setting the '\r\n' characters sequence as line terminator.
/// @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when
/// creating a new #GRegex, any Unicode newline sequence
/// is recognised as a newline. These are '\r', '\n' and '\rn', and the
/// single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
/// U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
/// U+2029 PARAGRAPH SEPARATOR.
/// @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when
/// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence
/// is recognized as a newline. Since: 2.34
/// @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for "\R" set when
/// creating a new #GRegex; only '\r', '\n', or '\r\n' character sequences
/// are recognized as a newline by "\R". Since: 2.34
/// @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for "\R" set when
/// creating a new #GRegex; any Unicode newline character or character sequence
/// are recognized as a newline by "\R". These are '\r', '\n' and '\rn', and the
/// single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
/// U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
/// U+2029 PARAGRAPH SEPARATOR. Since: 2.34
/// @G_REGEX_MATCH_PARTIAL_SOFT: An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34
/// @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to
/// to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match
/// is found, without continuing to search for a possible complete match. See
/// g_match_info_is_partial_match() for more information. Since: 2.34
/// @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like %G_REGEX_MATCH_NOTEMPTY, but only applied to
/// the start of the matched string. For anchored
/// patterns this can only happen for pattern containing "\K". Since: 2.34
///
/// Flags specifying match-time options.
///
/// Since: 2.14
abstract class GRegexMatchFlags {
  static const int G_REGEX_MATCH_ANCHORED = 16;
  static const int G_REGEX_MATCH_NOTBOL = 128;
  static const int G_REGEX_MATCH_NOTEOL = 256;
  static const int G_REGEX_MATCH_NOTEMPTY = 1024;
  static const int G_REGEX_MATCH_PARTIAL = 32768;
  static const int G_REGEX_MATCH_NEWLINE_CR = 1048576;
  static const int G_REGEX_MATCH_NEWLINE_LF = 2097152;
  static const int G_REGEX_MATCH_NEWLINE_CRLF = 3145728;
  static const int G_REGEX_MATCH_NEWLINE_ANY = 4194304;
  static const int G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880;
  static const int G_REGEX_MATCH_BSR_ANYCRLF = 8388608;
  static const int G_REGEX_MATCH_BSR_ANY = 16777216;
  static const int G_REGEX_MATCH_PARTIAL_SOFT = 32768;
  static const int G_REGEX_MATCH_PARTIAL_HARD = 134217728;
  static const int G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456;
}

final class _GRegex extends ffi.Opaque {}

final class _GMatchInfo extends ffi.Opaque {}

final class _GScanner extends ffi.Struct {
  external gpointer user_data;

  @guint()
  external int max_parse_errors;

  @guint()
  external int parse_errors;

  external ffi.Pointer<gchar> input_name;

  external ffi.Pointer<GData> qdata;

  external ffi.Pointer<GScannerConfig> config;

  @ffi.Int32()
  external int token;

  external GTokenValue value;

  @guint()
  external int line;

  @guint()
  external int position;

  @ffi.Int32()
  external int next_token;

  external GTokenValue next_value;

  @guint()
  external int next_line;

  @guint()
  external int next_position;

  external ffi.Pointer<GHashTable> symbol_table;

  @gint()
  external int input_fd;

  external ffi.Pointer<gchar> text;

  external ffi.Pointer<gchar> text_end;

  external ffi.Pointer<gchar> buffer;

  @guint()
  external int scope_id;

  external GScannerMsgFunc msg_handler;
}

typedef GData = _GData;
typedef GScannerConfig = _GScannerConfig;

final class _GScannerConfig extends ffi.Opaque {}

abstract class GTokenType {
  static const int G_TOKEN_EOF = 0;
  static const int G_TOKEN_LEFT_PAREN = 40;
  static const int G_TOKEN_RIGHT_PAREN = 41;
  static const int G_TOKEN_LEFT_CURLY = 123;
  static const int G_TOKEN_RIGHT_CURLY = 125;
  static const int G_TOKEN_LEFT_BRACE = 91;
  static const int G_TOKEN_RIGHT_BRACE = 93;
  static const int G_TOKEN_EQUAL_SIGN = 61;
  static const int G_TOKEN_COMMA = 44;
  static const int G_TOKEN_NONE = 256;
  static const int G_TOKEN_ERROR = 257;
  static const int G_TOKEN_CHAR = 258;
  static const int G_TOKEN_BINARY = 259;
  static const int G_TOKEN_OCTAL = 260;
  static const int G_TOKEN_INT = 261;
  static const int G_TOKEN_HEX = 262;
  static const int G_TOKEN_FLOAT = 263;
  static const int G_TOKEN_STRING = 264;
  static const int G_TOKEN_SYMBOL = 265;
  static const int G_TOKEN_IDENTIFIER = 266;
  static const int G_TOKEN_IDENTIFIER_NULL = 267;
  static const int G_TOKEN_COMMENT_SINGLE = 268;
  static const int G_TOKEN_COMMENT_MULTI = 269;
  static const int G_TOKEN_LAST = 270;
}

typedef GTokenValue = _GTokenValue;

final class _GTokenValue extends ffi.Union {
  external gpointer v_symbol;

  external ffi.Pointer<gchar> v_identifier;

  @gulong()
  external int v_binary;

  @gulong()
  external int v_octal;

  @gulong()
  external int v_int;

  @guint64()
  external int v_int64;

  @gdouble()
  external double v_float;

  @gulong()
  external int v_hex;

  external ffi.Pointer<gchar> v_string;

  external ffi.Pointer<gchar> v_comment;

  @guchar()
  external int v_char;

  @guint()
  external int v_error;
}

typedef guint64 = ffi.UnsignedLong;
typedef Dartguint64 = int;
typedef gdouble = ffi.Double;
typedef Dartgdouble = double;
typedef guchar = ffi.UnsignedChar;
typedef Dartguchar = int;
typedef GHashTable = _GHashTable;
typedef GScannerMsgFunc
    = ffi.Pointer<ffi.NativeFunction<GScannerMsgFuncFunction>>;
typedef GScannerMsgFuncFunction = ffi.Void Function(
    ffi.Pointer<GScanner> scanner, ffi.Pointer<gchar> message, gboolean error);
typedef DartGScannerMsgFuncFunction = void Function(
    ffi.Pointer<GScanner> scanner, ffi.Pointer<gchar> message, Dartgint error);
typedef GScanner = _GScanner;

abstract class GErrorType {
  static const int G_ERR_UNKNOWN = 0;
  static const int G_ERR_UNEXP_EOF = 1;
  static const int G_ERR_UNEXP_EOF_IN_STRING = 2;
  static const int G_ERR_UNEXP_EOF_IN_COMMENT = 3;
  static const int G_ERR_NON_DIGIT_IN_CONST = 4;
  static const int G_ERR_DIGIT_RADIX = 5;
  static const int G_ERR_FLOAT_RADIX = 6;
  static const int G_ERR_FLOAT_MALFORMED = 7;
}

final class _GSequence extends ffi.Opaque {}

final class _GSequenceNode extends ffi.Opaque {}

abstract class GShellError {
  static const int G_SHELL_ERROR_BAD_QUOTING = 0;
  static const int G_SHELL_ERROR_EMPTY_STRING = 1;
  static const int G_SHELL_ERROR_FAILED = 2;
}

abstract class GSliceConfig {
  static const int G_SLICE_CONFIG_ALWAYS_MALLOC = 1;
  static const int G_SLICE_CONFIG_BYPASS_MAGAZINES = 2;
  static const int G_SLICE_CONFIG_WORKING_SET_MSECS = 3;
  static const int G_SLICE_CONFIG_COLOR_INCREMENT = 4;
  static const int G_SLICE_CONFIG_CHUNK_SIZES = 5;
  static const int G_SLICE_CONFIG_CONTENTION_COUNTER = 6;
}

/// GSpawnError:
/// @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory.
/// @G_SPAWN_ERROR_READ: Read or select on pipes failed.
/// @G_SPAWN_ERROR_CHDIR: Changing to working directory failed.
/// @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`
/// @G_SPAWN_ERROR_PERM: execv() returned `EPERM`
/// @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`
/// @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)
/// @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`
/// @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`
/// @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`
/// @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`
/// @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`
/// @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`
/// @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`
/// @G_SPAWN_ERROR_IO: execv() returned `EIO`
/// @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`
/// @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`
/// @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`
/// @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`
/// @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`
/// @G_SPAWN_ERROR_FAILED: Some other fatal failure,
/// `error->message` should explain.
///
/// Error codes returned by spawning processes.
abstract class GSpawnError {
  static const int G_SPAWN_ERROR_FORK = 0;
  static const int G_SPAWN_ERROR_READ = 1;
  static const int G_SPAWN_ERROR_CHDIR = 2;
  static const int G_SPAWN_ERROR_ACCES = 3;
  static const int G_SPAWN_ERROR_PERM = 4;
  static const int G_SPAWN_ERROR_TOO_BIG = 5;
  static const int G_SPAWN_ERROR_2BIG = 5;
  static const int G_SPAWN_ERROR_NOEXEC = 6;
  static const int G_SPAWN_ERROR_NAMETOOLONG = 7;
  static const int G_SPAWN_ERROR_NOENT = 8;
  static const int G_SPAWN_ERROR_NOMEM = 9;
  static const int G_SPAWN_ERROR_NOTDIR = 10;
  static const int G_SPAWN_ERROR_LOOP = 11;
  static const int G_SPAWN_ERROR_TXTBUSY = 12;
  static const int G_SPAWN_ERROR_IO = 13;
  static const int G_SPAWN_ERROR_NFILE = 14;
  static const int G_SPAWN_ERROR_MFILE = 15;
  static const int G_SPAWN_ERROR_INVAL = 16;
  static const int G_SPAWN_ERROR_ISDIR = 17;
  static const int G_SPAWN_ERROR_LIBBAD = 18;
  static const int G_SPAWN_ERROR_FAILED = 19;
}

/// GSpawnFlags:
/// @G_SPAWN_DEFAULT: no flags, default behaviour
/// @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will
/// be inherited by the child; otherwise all descriptors except stdin,
/// stdout and stderr will be closed before calling exec() in the child.
/// @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;
/// you must use g_child_watch_add() yourself (or call waitpid() or handle
/// `SIGCHLD` yourself), or the child will become a zombie.
/// @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be
/// looked for in the user's `PATH`.
/// @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,
/// instead of going to the same location as the parent's standard output.
/// @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.
/// @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard
/// input (by default, the child's standard input is attached to `/dev/null`).
/// @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to
/// execute, while the remaining elements are the actual argument vector
/// to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`
/// as the file to execute, and passes all of `argv` to the child.
/// @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an absolute path,
/// it will be looked for in the `PATH` from the passed child environment.
/// Since: 2.34
/// @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.
/// Since: 2.40
///
/// Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes().
abstract class GSpawnFlags {
  static const int G_SPAWN_DEFAULT = 0;
  static const int G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1;
  static const int G_SPAWN_DO_NOT_REAP_CHILD = 2;
  static const int G_SPAWN_SEARCH_PATH = 4;
  static const int G_SPAWN_STDOUT_TO_DEV_NULL = 8;
  static const int G_SPAWN_STDERR_TO_DEV_NULL = 16;
  static const int G_SPAWN_CHILD_INHERITS_STDIN = 32;
  static const int G_SPAWN_FILE_AND_ARGV_ZERO = 64;
  static const int G_SPAWN_SEARCH_PATH_FROM_ENVP = 128;
  static const int G_SPAWN_CLOEXEC_PIPES = 256;
}

abstract class GAsciiType {
  static const int G_ASCII_ALNUM = 1;
  static const int G_ASCII_ALPHA = 2;
  static const int G_ASCII_CNTRL = 4;
  static const int G_ASCII_DIGIT = 8;
  static const int G_ASCII_GRAPH = 16;
  static const int G_ASCII_LOWER = 32;
  static const int G_ASCII_PRINT = 64;
  static const int G_ASCII_PUNCT = 128;
  static const int G_ASCII_SPACE = 256;
  static const int G_ASCII_UPPER = 512;
  static const int G_ASCII_XDIGIT = 1024;
}

typedef guint16 = ffi.UnsignedShort;
typedef Dartguint16 = int;

/// GNumberParserError:
/// @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number.
/// @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds.
///
/// Error codes returned by functions converting a string to a number.
///
/// Since: 2.54
abstract class GNumberParserError {
  static const int G_NUMBER_PARSER_ERROR_INVALID = 0;
  static const int G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1;
}

final class _GStringChunk extends ffi.Opaque {}

final class _GStrvBuilder extends ffi.Opaque {}

final class GTestCase extends ffi.Opaque {}

final class GTestSuite extends ffi.Opaque {}

/// GTestTrapFlags:
/// @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to
/// `/dev/null` so it cannot be observed on the console during test
/// runs. The actual output is still captured though to allow later
/// tests with g_test_trap_assert_stdout().
/// @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to
/// `/dev/null` so it cannot be observed on the console during test
/// runs. The actual output is still captured though to allow later
/// tests with g_test_trap_assert_stderr().
/// @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the
/// child process is shared with stdin of its parent process.
/// It is redirected to `/dev/null` otherwise.
///
/// Test traps are guards around forked tests.
/// These flags determine what traps to set.
///
/// Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),
/// which is deprecated. g_test_trap_subprocess() uses
/// #GTestSubprocessFlags.
abstract class GTestTrapFlags {
  static const int G_TEST_TRAP_SILENCE_STDOUT = 128;
  static const int G_TEST_TRAP_SILENCE_STDERR = 256;
  static const int G_TEST_TRAP_INHERIT_STDIN = 512;
}

abstract class GTestSubprocessFlags {
  static const int G_TEST_SUBPROCESS_INHERIT_STDIN = 1;
  static const int G_TEST_SUBPROCESS_INHERIT_STDOUT = 2;
  static const int G_TEST_SUBPROCESS_INHERIT_STDERR = 4;
}

final class GTestConfig extends ffi.Struct {
  @gboolean()
  external int test_initialized;

  @gboolean()
  external int test_quick;

  @gboolean()
  external int test_perf;

  @gboolean()
  external int test_verbose;

  @gboolean()
  external int test_quiet;

  @gboolean()
  external int test_undefined;
}

abstract class GTestResult {
  static const int G_TEST_RUN_SUCCESS = 0;
  static const int G_TEST_RUN_SKIPPED = 1;
  static const int G_TEST_RUN_FAILURE = 2;
  static const int G_TEST_RUN_INCOMPLETE = 3;
}

abstract class GTestLogType {
  static const int G_TEST_LOG_NONE = 0;
  static const int G_TEST_LOG_ERROR = 1;
  static const int G_TEST_LOG_START_BINARY = 2;
  static const int G_TEST_LOG_LIST_CASE = 3;
  static const int G_TEST_LOG_SKIP_CASE = 4;
  static const int G_TEST_LOG_START_CASE = 5;
  static const int G_TEST_LOG_STOP_CASE = 6;
  static const int G_TEST_LOG_MIN_RESULT = 7;
  static const int G_TEST_LOG_MAX_RESULT = 8;
  static const int G_TEST_LOG_MESSAGE = 9;
  static const int G_TEST_LOG_START_SUITE = 10;
  static const int G_TEST_LOG_STOP_SUITE = 11;
}

final class GTestLogMsg extends ffi.Opaque {}

final class GTestLogBuffer extends ffi.Struct {
  external ffi.Pointer<GString> data;

  external ffi.Pointer<GSList> msgs;
}

typedef GString = _GString;

abstract class GTestFileType {
  static const int G_TEST_DIST = 0;
  static const int G_TEST_BUILT = 1;
}

final class _GThreadPool extends ffi.Struct {
  external GFunc func;

  external gpointer user_data;

  @gboolean()
  external int exclusive;
}

typedef GFunc = ffi.Pointer<ffi.NativeFunction<GFuncFunction>>;
typedef GFuncFunction = ffi.Void Function(gpointer data, gpointer user_data);
typedef DartGFuncFunction = void Function(gpointer data, gpointer user_data);

final class _GTimer extends ffi.Opaque {}

final class _GTrashStack extends ffi.Struct {
  external ffi.Pointer<GTrashStack> next;
}

typedef GTrashStack = _GTrashStack;

final class _GTree extends ffi.Opaque {}

final class _GTreeNode extends ffi.Opaque {}

final class _GUri extends ffi.Opaque {}

/// GUriFlags:
/// @G_URI_FLAGS_NONE: No flags set.
/// @G_URI_FLAGS_PARSE_RELAXED: Parse the URI more relaxedly than the
/// [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,
/// fixing up or ignoring common mistakes in URIs coming from external
/// sources. This is also needed for some obscure URI schemes where `;`
/// separates the host from the path. Don’t use this flag unless you need to.
/// @G_URI_FLAGS_HAS_PASSWORD: The userinfo field may contain a password,
/// which will be separated from the username by `:`.
/// @G_URI_FLAGS_HAS_AUTH_PARAMS: The userinfo may contain additional
/// authentication-related parameters, which will be separated from
/// the username and/or password by `;`.
/// @G_URI_FLAGS_NON_DNS: The host component should not be assumed to be a
/// DNS hostname or IP address (for example, for `smb` URIs with NetBIOS
/// hostnames).
/// @G_URI_FLAGS_ENCODED: When parsing a URI, this indicates that `%`-encoded
/// characters in the userinfo, path, query, and fragment fields
/// should not be decoded. (And likewise the host field if
/// %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates
/// that you have already `%`-encoded the components, and so #GUri
/// should not do any encoding itself.
/// @G_URI_FLAGS_ENCODED_QUERY: Same as %G_URI_FLAGS_ENCODED, for the query
/// field only.
/// @G_URI_FLAGS_ENCODED_PATH: Same as %G_URI_FLAGS_ENCODED, for the path only.
/// @G_URI_FLAGS_ENCODED_FRAGMENT: Same as %G_URI_FLAGS_ENCODED, for the
/// fragment only.
/// @G_URI_FLAGS_SCHEME_NORMALIZE: A scheme-based normalization will be applied.
/// For example, when parsing an HTTP URI changing omitted path to `/` and
/// omitted port to `80`; and when building a URI, changing empty path to `/`
/// and default port `80`). This only supports a subset of known schemes. (Since: 2.68)
///
/// Flags that describe a URI.
///
/// When parsing a URI, if you need to choose different flags based on
/// the type of URI, you can use g_uri_peek_scheme() on the URI string
/// to check the scheme first, and use that to decide what flags to
/// parse it with.
///
/// Since: 2.66
abstract class GUriFlags {
  static const int G_URI_FLAGS_NONE = 0;
  static const int G_URI_FLAGS_PARSE_RELAXED = 1;
  static const int G_URI_FLAGS_HAS_PASSWORD = 2;
  static const int G_URI_FLAGS_HAS_AUTH_PARAMS = 4;
  static const int G_URI_FLAGS_ENCODED = 8;
  static const int G_URI_FLAGS_NON_DNS = 16;
  static const int G_URI_FLAGS_ENCODED_QUERY = 32;
  static const int G_URI_FLAGS_ENCODED_PATH = 64;
  static const int G_URI_FLAGS_ENCODED_FRAGMENT = 128;
  static const int G_URI_FLAGS_SCHEME_NORMALIZE = 256;
}

/// GUriHideFlags:
/// @G_URI_HIDE_NONE: No flags set.
/// @G_URI_HIDE_USERINFO: Hide the userinfo.
/// @G_URI_HIDE_PASSWORD: Hide the password.
/// @G_URI_HIDE_AUTH_PARAMS: Hide the auth_params.
/// @G_URI_HIDE_QUERY: Hide the query.
/// @G_URI_HIDE_FRAGMENT: Hide the fragment.
///
/// Flags describing what parts of the URI to hide in
/// g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and
/// %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with
/// the corresponding flags.
///
/// Since: 2.66
abstract class GUriHideFlags {
  static const int G_URI_HIDE_NONE = 0;
  static const int G_URI_HIDE_USERINFO = 1;
  static const int G_URI_HIDE_PASSWORD = 2;
  static const int G_URI_HIDE_AUTH_PARAMS = 4;
  static const int G_URI_HIDE_QUERY = 8;
  static const int G_URI_HIDE_FRAGMENT = 16;
}

/// GUriParamsFlags:
/// @G_URI_PARAMS_NONE: No flags set.
/// @G_URI_PARAMS_CASE_INSENSITIVE: Parameter names are case insensitive.
/// @G_URI_PARAMS_WWW_FORM: Replace `+` with space character. Only useful for
/// URLs on the web, using the `https` or `http` schemas.
/// @G_URI_PARAMS_PARSE_RELAXED: See %G_URI_FLAGS_PARSE_RELAXED.
///
/// Flags modifying the way parameters are handled by g_uri_parse_params() and
/// #GUriParamsIter.
///
/// Since: 2.66
abstract class GUriParamsFlags {
  static const int G_URI_PARAMS_NONE = 0;
  static const int G_URI_PARAMS_CASE_INSENSITIVE = 1;
  static const int G_URI_PARAMS_WWW_FORM = 2;
  static const int G_URI_PARAMS_PARSE_RELAXED = 4;
}

final class _GUriParamsIter extends ffi.Struct {
  @gint()
  external int dummy0;

  external gpointer dummy1;

  external gpointer dummy2;

  @ffi.Array.multi([256])
  external ffi.Array<guint8> dummy3;
}

/// GUriError:
/// @G_URI_ERROR_FAILED: Generic error if no more specific error is available.
/// See the error message for details.
/// @G_URI_ERROR_BAD_SCHEME: The scheme of a URI could not be parsed.
/// @G_URI_ERROR_BAD_USER: The user/userinfo of a URI could not be parsed.
/// @G_URI_ERROR_BAD_PASSWORD: The password of a URI could not be parsed.
/// @G_URI_ERROR_BAD_AUTH_PARAMS: The authentication parameters of a URI could not be parsed.
/// @G_URI_ERROR_BAD_HOST: The host of a URI could not be parsed.
/// @G_URI_ERROR_BAD_PORT: The port of a URI could not be parsed.
/// @G_URI_ERROR_BAD_PATH: The path of a URI could not be parsed.
/// @G_URI_ERROR_BAD_QUERY: The query of a URI could not be parsed.
/// @G_URI_ERROR_BAD_FRAGMENT: The fragment of a URI could not be parsed.
///
/// Error codes returned by #GUri methods.
///
/// Since: 2.66
abstract class GUriError {
  static const int G_URI_ERROR_FAILED = 0;
  static const int G_URI_ERROR_BAD_SCHEME = 1;
  static const int G_URI_ERROR_BAD_USER = 2;
  static const int G_URI_ERROR_BAD_PASSWORD = 3;
  static const int G_URI_ERROR_BAD_AUTH_PARAMS = 4;
  static const int G_URI_ERROR_BAD_HOST = 5;
  static const int G_URI_ERROR_BAD_PORT = 6;
  static const int G_URI_ERROR_BAD_PATH = 7;
  static const int G_URI_ERROR_BAD_QUERY = 8;
  static const int G_URI_ERROR_BAD_FRAGMENT = 9;
}

final class _GAllocator extends ffi.Opaque {}

final class _GMemChunk extends ffi.Opaque {}

final class _GCache extends ffi.Opaque {}

final class _GCompletion extends ffi.Struct {
  external ffi.Pointer<GList> items;

  external GCompletionFunc func;

  external ffi.Pointer<gchar> prefix;

  external ffi.Pointer<GList> cache;

  external GCompletionStrncmpFunc strncmp_func;
}

typedef GCompletionFunc
    = ffi.Pointer<ffi.NativeFunction<GCompletionFuncFunction>>;
typedef GCompletionFuncFunction = ffi.Pointer<gchar> Function(gpointer);
typedef GCompletionStrncmpFunc
    = ffi.Pointer<ffi.NativeFunction<GCompletionStrncmpFuncFunction>>;
typedef GCompletionStrncmpFuncFunction = gint Function(
    ffi.Pointer<gchar> s1, ffi.Pointer<gchar> s2, gsize n);
typedef DartGCompletionStrncmpFuncFunction = Dartgint Function(
    ffi.Pointer<gchar> s1, ffi.Pointer<gchar> s2, Dartgsize n);

final class _GRelation extends ffi.Opaque {}

final class _GTuples extends ffi.Struct {
  @guint()
  external int len;
}

final class _GThreadFunctions extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Pointer<GMutex> Function()>>
      mutex_new;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GMutex> mutex)>>
      mutex_lock;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GMutex> mutex)>>
      mutex_trylock;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GMutex> mutex)>>
      mutex_unlock;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GMutex> mutex)>>
      mutex_free;

  external ffi.Pointer<ffi.NativeFunction<ffi.Pointer<GCond> Function()>>
      cond_new;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GCond> cond)>>
      cond_signal;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GCond> cond)>>
      cond_broadcast;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GCond> cond, ffi.Pointer<GMutex> mutex)>> cond_wait;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GCond> cond, ffi.Pointer<GMutex> mutex,
              ffi.Pointer<GTimeVal> end_time)>> cond_timed_wait;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GCond> cond)>>
      cond_free;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GPrivate> Function(GDestroyNotify destructor)>>
      private_new;

  external ffi.Pointer<
          ffi
          .NativeFunction<gpointer Function(ffi.Pointer<GPrivate> private_key)>>
      private_get;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GPrivate> private_key, gpointer data)>> private_set;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              GThreadFunc func,
              gpointer data,
              gulong stack_size,
              gboolean joinable,
              gboolean bound,
              ffi.Int32 priority,
              gpointer thread,
              ffi.Pointer<ffi.Pointer<GError>> error)>> thread_create;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> thread_yield;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(gpointer thread)>>
      thread_join;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> thread_exit;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(gpointer thread, ffi.Int32 priority)>>
      thread_set_priority;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(gpointer thread)>>
      thread_self;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(gpointer thread1, gpointer thread2)>> thread_equal;
}

typedef GMutex = _GMutex;
typedef GCond = _GCond;
typedef GTimeVal = _GTimeVal;
typedef GPrivate = _GPrivate;
typedef GThreadFunctions = _GThreadFunctions;

final class sched_param extends ffi.Struct {
  @ffi.Int()
  external int sched_priority;
}

final class cpu_set_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__cpu_mask> __bits;
}

typedef __cpu_mask = ffi.UnsignedLong;
typedef Dart__cpu_mask = int;

final class __jmp_buf_tag extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Long> __jmpbuf;

  @ffi.Int()
  external int __mask_was_saved;

  external __sigset_t __saved_mask;
}

final class _pthread_cleanup_buffer extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  @ffi.Int()
  external int __canceltype;

  external ffi.Pointer<_pthread_cleanup_buffer> __prev;
}

final class __cancel_jmp_buf_tag extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Long> __cancel_jmp_buf;

  @ffi.Int()
  external int __mask_was_saved;
}

final class __pthread_unwind_buf_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<__cancel_jmp_buf_tag> __cancel_jmp_buf;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<ffi.Void>> __pad;
}

final class __pthread_cleanup_frame extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __cancel_routine;

  external ffi.Pointer<ffi.Void> __cancel_arg;

  @ffi.Int()
  external int __do_it;

  @ffi.Int()
  external int __cancel_type;
}

final class GStaticMutex extends ffi.Struct {
  external ffi.Pointer<GMutex> mutex;

  external pthread_mutex_t unused;
}

final class _GStaticRecMutex extends ffi.Struct {
  external GStaticMutex mutex;

  @guint()
  external int depth;

  external UnnamedUnion8 unused;
}

final class UnnamedUnion8 extends ffi.Union {
  @pthread_t()
  external int owner;

  @gdouble()
  external double dummy;
}

typedef pthread_t = ffi.UnsignedLong;
typedef Dartpthread_t = int;

final class _GStaticRWLock extends ffi.Struct {
  external GStaticMutex mutex;

  external ffi.Pointer<GCond> read_cond;

  external ffi.Pointer<GCond> write_cond;

  @guint()
  external int read_counter;

  @gboolean()
  external int have_writer;

  @guint()
  external int want_to_read;

  @guint()
  external int want_to_write;
}

final class _GStaticPrivate extends ffi.Struct {
  @guint()
  external int index;
}

/// GValue:
///
/// An opaque structure used to hold different types of values.
///
/// The data within the structure has protected scope: it is accessible only
/// to functions within a #GTypeValueTable structure, or implementations of
/// the g_value_*() API. That is, code portions which implement new fundamental
/// types.
///
/// #GValue users cannot make any assumptions about how data is stored
/// within the 2 element @data union, and the @g_type member should
/// only be accessed through the G_VALUE_TYPE() macro.
final class _GValue extends ffi.Struct {
  @GType()
  external int g_type;

  @ffi.Array.multi([2])
  external ffi.Array<UnnamedUnion9> data;
}

typedef GType = gsize;

final class UnnamedUnion9 extends ffi.Union {
  @gint()
  external int v_int;

  @guint()
  external int v_uint;

  @glong()
  external int v_long;

  @gulong()
  external int v_ulong;

  @gint64()
  external int v_int64;

  @guint64()
  external int v_uint64;

  @gfloat()
  external double v_float;

  @gdouble()
  external double v_double;

  external gpointer v_pointer;
}

typedef gfloat = ffi.Float;
typedef Dartgfloat = double;

final class _GTypeCValue extends ffi.Opaque {}

final class _GTypePlugin extends ffi.Opaque {}

/// GTypeClass:
///
/// An opaque structure used as the base of all classes.
final class _GTypeClass extends ffi.Struct {
  @GType()
  external int g_type;
}

/// GTypeInterface:
///
/// An opaque structure used as the base of all interface types.
final class _GTypeInterface extends ffi.Struct {
  @GType()
  external int g_type;

  @GType()
  external int g_instance_type;
}

/// GTypeInstance:
///
/// An opaque structure used as the base of all type instances.
final class _GTypeInstance extends ffi.Struct {
  external ffi.Pointer<GTypeClass> g_class;
}

typedef GTypeClass = _GTypeClass;

/// GTypeInfo:
/// @class_size: Size of the class structure (required for interface, classed and instantiatable types)
/// @base_init: Location of the base initialization function (optional)
/// @base_finalize: Location of the base finalization function (optional)
/// @class_init: Location of the class initialization function for
/// classed and instantiatable types. Location of the default vtable
/// inititalization function for interface types. (optional) This function
/// is used both to fill in virtual functions in the class or default vtable,
/// and to do type-specific setup such as registering signals and object
/// properties.
/// @class_finalize: Location of the class finalization function for
/// classed and instantiatable types. Location of the default vtable
/// finalization function for interface types. (optional)
/// @class_data: User-supplied data passed to the class init/finalize functions
/// @instance_size: Size of the instance (object) structure (required for instantiatable types only)
/// @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.
/// @instance_init: Location of the instance initialization function (optional, for instantiatable types only)
/// @value_table: A #GTypeValueTable function table for generic handling of GValues
/// of this type (usually only useful for fundamental types)
///
/// This structure is used to provide the type system with the information
/// required to initialize and destruct (finalize) a type's class and
/// its instances.
///
/// The initialized structure is passed to the g_type_register_static() function
/// (or is copied into the provided #GTypeInfo structure in the
/// g_type_plugin_complete_type_info()). The type system will perform a deep
/// copy of this structure, so its memory does not need to be persistent
/// across invocation of g_type_register_static().
final class _GTypeInfo extends ffi.Struct {
  @guint16()
  external int class_size;

  external GBaseInitFunc base_init;

  external GBaseFinalizeFunc base_finalize;

  external GClassInitFunc class_init;

  external GClassFinalizeFunc class_finalize;

  external gconstpointer class_data;

  @guint16()
  external int instance_size;

  @guint16()
  external int n_preallocs;

  external GInstanceInitFunc instance_init;

  external ffi.Pointer<GTypeValueTable> value_table;
}

/// GBaseInitFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize
///
/// A callback function used by the type system to do base initialization
/// of the class structures of derived types.
///
/// This function is called as part of the initialization process of all derived
/// classes and should reallocate or reset all dynamic class members copied over
/// from the parent class.
///
/// For example, class members (such as strings) that are not sufficiently
/// handled by a plain memory copy of the parent class into the derived class
/// have to be altered. See GClassInitFunc() for a discussion of the class
/// initialization process.
typedef GBaseInitFunc = ffi.Pointer<ffi.NativeFunction<GBaseInitFuncFunction>>;
typedef GBaseInitFuncFunction = ffi.Void Function(gpointer g_class);
typedef DartGBaseInitFuncFunction = void Function(gpointer g_class);

/// GBaseFinalizeFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize
///
/// A callback function used by the type system to finalize those portions
/// of a derived types class structure that were setup from the corresponding
/// GBaseInitFunc() function.
///
/// Class finalization basically works the inverse way in which class
/// initialization is performed.
///
/// See GClassInitFunc() for a discussion of the class initialization process.
typedef GBaseFinalizeFunc
    = ffi.Pointer<ffi.NativeFunction<GBaseFinalizeFuncFunction>>;
typedef GBaseFinalizeFuncFunction = ffi.Void Function(gpointer g_class);
typedef DartGBaseFinalizeFuncFunction = void Function(gpointer g_class);

/// GClassInitFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize.
/// @class_data: The @class_data member supplied via the #GTypeInfo structure.
///
/// A callback function used by the type system to initialize the class
/// of a specific type.
///
/// This function should initialize all static class members.
///
/// The initialization process of a class involves:
///
/// - Copying common members from the parent class over to the
/// derived class structure.
/// - Zero initialization of the remaining members not copied
/// over from the parent class.
/// - Invocation of the GBaseInitFunc() initializers of all parent
/// types and the class' type.
/// - Invocation of the class' GClassInitFunc() initializer.
///
/// Since derived classes are partially initialized through a memory copy
/// of the parent class, the general rule is that GBaseInitFunc() and
/// GBaseFinalizeFunc() should take care of necessary reinitialization
/// and release of those class members that were introduced by the type
/// that specified these GBaseInitFunc()/GBaseFinalizeFunc().
/// GClassInitFunc() should only care about initializing static
/// class members, while dynamic class members (such as allocated strings
/// or reference counted resources) are better handled by a GBaseInitFunc()
/// for this type, so proper initialization of the dynamic class members
/// is performed for class initialization of derived types as well.
///
/// An example may help to correspond the intend of the different class
/// initializers:
///
/// |[<!-- language="C" -->
/// typedef struct {
/// GObjectClass parent_class;
/// gint         static_integer;
/// gchar       *dynamic_string;
/// } TypeAClass;
/// static void
/// type_a_base_class_init (TypeAClass *class)
/// {
/// class->dynamic_string = g_strdup ("some string");
/// }
/// static void
/// type_a_base_class_finalize (TypeAClass *class)
/// {
/// g_free (class->dynamic_string);
/// }
/// static void
/// type_a_class_init (TypeAClass *class)
/// {
/// class->static_integer = 42;
/// }
///
/// typedef struct {
/// TypeAClass   parent_class;
/// gfloat       static_float;
/// GString     *dynamic_gstring;
/// } TypeBClass;
/// static void
/// type_b_base_class_init (TypeBClass *class)
/// {
/// class->dynamic_gstring = g_string_new ("some other string");
/// }
/// static void
/// type_b_base_class_finalize (TypeBClass *class)
/// {
/// g_string_free (class->dynamic_gstring);
/// }
/// static void
/// type_b_class_init (TypeBClass *class)
/// {
/// class->static_float = 3.14159265358979323846;
/// }
/// ]|
///
/// Initialization of TypeBClass will first cause initialization of
/// TypeAClass (derived classes reference their parent classes, see
/// g_type_class_ref() on this).
///
/// Initialization of TypeAClass roughly involves zero-initializing its fields,
/// then calling its GBaseInitFunc() type_a_base_class_init() to allocate
/// its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
/// type_a_class_init() to initialize its static members (static_integer).
/// The first step in the initialization process of TypeBClass is then
/// a plain memory copy of the contents of TypeAClass into TypeBClass and
/// zero-initialization of the remaining fields in TypeBClass.
/// The dynamic members of TypeAClass within TypeBClass now need
/// reinitialization which is performed by calling type_a_base_class_init()
/// with an argument of TypeBClass.
///
/// After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
/// is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
/// and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
/// is called to complete the initialization process with the static members
/// (static_float).
///
/// Corresponding finalization counter parts to the GBaseInitFunc() functions
/// have to be provided to release allocated resources at class finalization
/// time.
typedef GClassInitFunc
    = ffi.Pointer<ffi.NativeFunction<GClassInitFuncFunction>>;
typedef GClassInitFuncFunction = ffi.Void Function(
    gpointer g_class, gpointer class_data);
typedef DartGClassInitFuncFunction = void Function(
    gpointer g_class, gpointer class_data);

/// GClassFinalizeFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize
/// @class_data: The @class_data member supplied via the #GTypeInfo structure
///
/// A callback function used by the type system to finalize a class.
///
/// This function is rarely needed, as dynamically allocated class resources
/// should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
///
/// Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
/// structure of a static type is invalid, because classes of static types
/// will never be finalized (they are artificially kept alive when their
/// reference count drops to zero).
typedef GClassFinalizeFunc
    = ffi.Pointer<ffi.NativeFunction<GClassFinalizeFuncFunction>>;
typedef GClassFinalizeFuncFunction = ffi.Void Function(
    gpointer g_class, gpointer class_data);
typedef DartGClassFinalizeFuncFunction = void Function(
    gpointer g_class, gpointer class_data);

/// GInstanceInitFunc:
/// @instance: The instance to initialize
/// @g_class: (type GObject.TypeClass): The class of the type the instance is
/// created for
///
/// A callback function used by the type system to initialize a new
/// instance of a type.
///
/// This function initializes all instance members and allocates any resources
/// required by it.
///
/// Initialization of a derived instance involves calling all its parent
/// types instance initializers, so the class member of the instance
/// is altered during its initialization to always point to the class that
/// belongs to the type the current initializer was introduced for.
///
/// The extended members of @instance are guaranteed to have been filled with
/// zeros before this function is called.
typedef GInstanceInitFunc
    = ffi.Pointer<ffi.NativeFunction<GInstanceInitFuncFunction>>;
typedef GInstanceInitFuncFunction = ffi.Void Function(
    ffi.Pointer<GTypeInstance> instance, gpointer g_class);
typedef DartGInstanceInitFuncFunction = void Function(
    ffi.Pointer<GTypeInstance> instance, gpointer g_class);
typedef GTypeInstance = _GTypeInstance;
typedef GTypeValueTable = _GTypeValueTable;

/// GTypeValueTable:
/// @value_init: Default initialize @values contents by poking values
/// directly into the value->data array. The data array of
/// the #GValue passed into this function was zero-filled
/// with `memset()`, so no care has to be taken to free any
/// old contents. E.g. for the implementation of a string
/// value that may never be %NULL, the implementation might
/// look like:
/// |[<!-- language="C" -->
/// value->data[0].v_pointer = g_strdup ("");
/// ]|
/// @value_free: Free any old contents that might be left in the
/// data array of the passed in @value. No resources may
/// remain allocated through the #GValue contents after
/// this function returns. E.g. for our above string type:
/// |[<!-- language="C" -->
/// // only free strings without a specific flag for static storage
/// if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))
/// g_free (value->data[0].v_pointer);
/// ]|
/// @value_copy: @dest_value is a #GValue with zero-filled data section
/// and @src_value is a properly setup #GValue of same or
/// derived type.
/// The purpose of this function is to copy the contents of
/// @src_value into @dest_value in a way, that even after
/// @src_value has been freed, the contents of @dest_value
/// remain valid. String type example:
/// |[<!-- language="C" -->
/// dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);
/// ]|
/// @value_peek_pointer: If the value contents fit into a pointer, such as objects
/// or strings, return this pointer, so the caller can peek at
/// the current contents. To extend on our above string example:
/// |[<!-- language="C" -->
/// return value->data[0].v_pointer;
/// ]|
/// @collect_format: A string format describing how to collect the contents of
/// this value bit-by-bit. Each character in the format represents
/// an argument to be collected, and the characters themselves indicate
/// the type of the argument. Currently supported arguments are:
/// - 'i' - Integers. passed as collect_values[].v_int.
/// - 'l' - Longs. passed as collect_values[].v_long.
/// - 'd' - Doubles. passed as collect_values[].v_double.
/// - 'p' - Pointers. passed as collect_values[].v_pointer.
/// It should be noted that for variable argument list construction,
/// ANSI C promotes every type smaller than an integer to an int, and
/// floats to doubles. So for collection of short int or char, 'i'
/// needs to be used, and for collection of floats 'd'.
/// @collect_value: The collect_value() function is responsible for converting the
/// values collected from a variable argument list into contents
/// suitable for storage in a GValue. This function should setup
/// @value similar to value_init(); e.g. for a string value that
/// does not allow %NULL pointers, it needs to either spew an error,
/// or do an implicit conversion by storing an empty string.
/// The @value passed in to this function has a zero-filled data
/// array, so just like for value_init() it is guaranteed to not
/// contain any old contents that might need freeing.
/// @n_collect_values is exactly the string length of @collect_format,
/// and @collect_values is an array of unions #GTypeCValue with
/// length @n_collect_values, containing the collected values
/// according to @collect_format.
/// @collect_flags is an argument provided as a hint by the caller.
/// It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,
/// that the collected value contents may be considered "static"
/// for the duration of the @value lifetime.
/// Thus an extra copy of the contents stored in @collect_values is
/// not required for assignment to @value.
/// For our above string example, we continue with:
/// |[<!-- language="C" -->
/// if (!collect_values[0].v_pointer)
/// value->data[0].v_pointer = g_strdup ("");
/// else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
/// {
/// value->data[0].v_pointer = collect_values[0].v_pointer;
/// // keep a flag for the value_free() implementation to not free this string
/// value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
/// }
/// else
/// value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
/// return NULL;
/// ]|
/// It should be noted, that it is generally a bad idea to follow the
/// %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to
/// reentrancy requirements and reference count assertions performed
/// by the signal emission code, reference counts should always be
/// incremented for reference counted contents stored in the value->data
/// array.  To deviate from our string example for a moment, and taking
/// a look at an exemplary implementation for collect_value() of
/// #GObject:
/// |[<!-- language="C" -->
/// GObject *object = G_OBJECT (collect_values[0].v_pointer);
/// g_return_val_if_fail (object != NULL,
/// g_strdup_printf ("Object passed as invalid NULL pointer"));
/// // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types
/// value->data[0].v_pointer = g_object_ref (object);
/// return NULL;
/// ]|
/// The reference count for valid objects is always incremented,
/// regardless of @collect_flags. For invalid objects, the example
/// returns a newly allocated string without altering @value.
/// Upon success, collect_value() needs to return %NULL. If, however,
/// an error condition occurred, collect_value() may spew an
/// error by returning a newly allocated non-%NULL string, giving
/// a suitable description of the error condition.
/// The calling code makes no assumptions about the @value
/// contents being valid upon error returns, @value
/// is simply thrown away without further freeing. As such, it is
/// a good idea to not allocate #GValue contents, prior to returning
/// an error, however, collect_values() is not obliged to return
/// a correctly setup @value for error returns, simply because
/// any non-%NULL return is considered a fatal condition so further
/// program behaviour is undefined.
/// @lcopy_format: Format description of the arguments to collect for @lcopy_value,
/// analogous to @collect_format. Usually, @lcopy_format string consists
/// only of 'p's to provide lcopy_value() with pointers to storage locations.
/// @lcopy_value: This function is responsible for storing the @value contents into
/// arguments passed through a variable argument list which got
/// collected into @collect_values according to @lcopy_format.
/// @n_collect_values equals the string length of @lcopy_format,
/// and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.
/// In contrast to collect_value(), lcopy_value() is obliged to
/// always properly support %G_VALUE_NOCOPY_CONTENTS.
/// Similar to collect_value() the function may prematurely abort
/// by returning a newly allocated string describing an error condition.
/// To complete the string example:
/// |[<!-- language="C" -->
/// gchar **string_p = collect_values[0].v_pointer;
/// g_return_val_if_fail (string_p != NULL,
/// g_strdup_printf ("string location passed as NULL"));
/// if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
/// *string_p = value->data[0].v_pointer;
/// else
/// *string_p = g_strdup (value->data[0].v_pointer);
/// ]|
/// And an illustrative version of lcopy_value() for
/// reference-counted types:
/// |[<!-- language="C" -->
/// GObject **object_p = collect_values[0].v_pointer;
/// g_return_val_if_fail (object_p != NULL,
/// g_strdup_printf ("object location passed as NULL"));
/// if (!value->data[0].v_pointer)
/// *object_p = NULL;
/// else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour
/// *object_p = value->data[0].v_pointer;
/// else
/// *object_p = g_object_ref (value->data[0].v_pointer);
/// return NULL;
/// ]|
///
/// The #GTypeValueTable provides the functions required by the #GValue
/// implementation, to serve as a container for values of a type.
final class _GTypeValueTable extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue> value)>>
      value_init;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue> value)>>
      value_free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue> src_value,
              ffi.Pointer<GValue> dest_value)>> value_copy;

  external ffi
      .Pointer<ffi.NativeFunction<gpointer Function(ffi.Pointer<GValue> value)>>
      value_peek_pointer;

  external ffi.Pointer<gchar> collect_format;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(
              ffi.Pointer<GValue> value,
              guint n_collect_values,
              ffi.Pointer<GTypeCValue> collect_values,
              guint collect_flags)>> collect_value;

  external ffi.Pointer<gchar> lcopy_format;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(
              ffi.Pointer<GValue> value,
              guint n_collect_values,
              ffi.Pointer<GTypeCValue> collect_values,
              guint collect_flags)>> lcopy_value;
}

typedef GValue = _GValue;
typedef GTypeCValue = _GTypeCValue;

/// GTypeFundamentalInfo:
/// @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type
///
/// A structure that provides information to the type system which is
/// used specifically for managing fundamental types.
final class _GTypeFundamentalInfo extends ffi.Struct {
  @ffi.Int32()
  external int type_flags;
}

/// GTypeFundamentalFlags:
/// @G_TYPE_FLAG_CLASSED: Indicates a classed type
/// @G_TYPE_FLAG_INSTANTIATABLE: Indicates an instantiatable type (implies classed)
/// @G_TYPE_FLAG_DERIVABLE: Indicates a flat derivable type
/// @G_TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable)
///
/// Bit masks used to check or determine specific characteristics of a
/// fundamental type.
abstract class GTypeFundamentalFlags {
  static const int G_TYPE_FLAG_CLASSED = 1;
  static const int G_TYPE_FLAG_INSTANTIATABLE = 2;
  static const int G_TYPE_FLAG_DERIVABLE = 4;
  static const int G_TYPE_FLAG_DEEP_DERIVABLE = 8;
}

/// GInterfaceInfo:
/// @interface_init: location of the interface initialization function
/// @interface_finalize: location of the interface finalization function
/// @interface_data: user-supplied data passed to the interface init/finalize functions
///
/// A structure that provides information to the type system which is
/// used specifically for managing interface types.
final class _GInterfaceInfo extends ffi.Struct {
  external GInterfaceInitFunc interface_init;

  external GInterfaceFinalizeFunc interface_finalize;

  external gpointer interface_data;
}

/// GInterfaceInitFunc:
/// @g_iface: (type GObject.TypeInterface): The interface structure to initialize
/// @iface_data: The @interface_data supplied via the #GInterfaceInfo structure
///
/// A callback function used by the type system to initialize a new
/// interface.
///
/// This function should initialize all internal data and* allocate any
/// resources required by the interface.
///
/// The members of @iface_data are guaranteed to have been filled with
/// zeros before this function is called.
typedef GInterfaceInitFunc
    = ffi.Pointer<ffi.NativeFunction<GInterfaceInitFuncFunction>>;
typedef GInterfaceInitFuncFunction = ffi.Void Function(
    gpointer g_iface, gpointer iface_data);
typedef DartGInterfaceInitFuncFunction = void Function(
    gpointer g_iface, gpointer iface_data);

/// GInterfaceFinalizeFunc:
/// @g_iface: (type GObject.TypeInterface): The interface structure to finalize
/// @iface_data: The @interface_data supplied via the #GInterfaceInfo structure
///
/// A callback function used by the type system to finalize an interface.
///
/// This function should destroy any internal data and release any resources
/// allocated by the corresponding GInterfaceInitFunc() function.
typedef GInterfaceFinalizeFunc
    = ffi.Pointer<ffi.NativeFunction<GInterfaceFinalizeFuncFunction>>;
typedef GInterfaceFinalizeFuncFunction = ffi.Void Function(
    gpointer g_iface, gpointer iface_data);
typedef DartGInterfaceFinalizeFuncFunction = void Function(
    gpointer g_iface, gpointer iface_data);

/// GTypeQuery:
/// @type: the #GType value of the type
/// @type_name: the name of the type
/// @class_size: the size of the class structure
/// @instance_size: the size of the instance structure
///
/// A structure holding information for a specific type.
///
/// See also: g_type_query()
final class _GTypeQuery extends ffi.Struct {
  @GType()
  external int type;

  external ffi.Pointer<gchar> type_name;

  @guint()
  external int class_size;

  @guint()
  external int instance_size;
}

/// GTypeDebugFlags:
/// @G_TYPE_DEBUG_NONE: Print no messages
/// @G_TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping
/// @G_TYPE_DEBUG_SIGNALS: Print messages about signal emissions
/// @G_TYPE_DEBUG_MASK: Mask covering all debug flags
/// @G_TYPE_DEBUG_INSTANCE_COUNT: Keep a count of instances of each type
///
/// These flags used to be passed to g_type_init_with_debug_flags() which
/// is now deprecated.
///
/// If you need to enable debugging features, use the GOBJECT_DEBUG
/// environment variable.
///
/// Deprecated: 2.36: g_type_init() is now done automatically
abstract class GTypeDebugFlags {
  static const int G_TYPE_DEBUG_NONE = 0;
  static const int G_TYPE_DEBUG_OBJECTS = 1;
  static const int G_TYPE_DEBUG_SIGNALS = 2;
  static const int G_TYPE_DEBUG_INSTANCE_COUNT = 4;
  static const int G_TYPE_DEBUG_MASK = 7;
}

/// GTypeFlags:
/// @G_TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be
/// created for an abstract type
/// @G_TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type
/// that introduces a value table, but can't be used for
/// g_value_init()
/// @G_TYPE_FLAG_FINAL: Indicates a final type. A final type is a non-derivable
/// leaf node in a deep derivable type hierarchy tree. Since: 2.70
///
/// Bit masks used to check or determine characteristics of a type.
abstract class GTypeFlags {
  static const int G_TYPE_FLAG_ABSTRACT = 16;
  static const int G_TYPE_FLAG_VALUE_ABSTRACT = 32;
  static const int G_TYPE_FLAG_FINAL = 64;
}

/// GParamFlags:
/// @G_PARAM_READABLE: the parameter is readable
/// @G_PARAM_WRITABLE: the parameter is writable
/// @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE
/// @G_PARAM_CONSTRUCT: the parameter will be set upon object construction
/// @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction
/// @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())
/// strict validation is not required
/// @G_PARAM_STATIC_NAME: the string used as name when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_NICK: the string used as nick when constructing the
/// parameter is guaranteed to remain valid and
/// unmmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this
/// property will not automatically result in a "notify" signal being
/// emitted: the implementation must call g_object_notify() themselves
/// in case the property actually changes.  Since: 2.42.
/// @G_PARAM_PRIVATE: internal
/// @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed
/// in a future version. A warning will be generated if it is used
/// while running with G_ENABLE_DIAGNOSTIC=1.
/// Since 2.26
///
/// Through the #GParamFlags flag values, certain aspects of parameters
/// can be configured.
///
/// See also: %G_PARAM_STATIC_STRINGS
abstract class GParamFlags {
  static const int G_PARAM_READABLE = 1;
  static const int G_PARAM_WRITABLE = 2;
  static const int G_PARAM_READWRITE = 3;
  static const int G_PARAM_CONSTRUCT = 4;
  static const int G_PARAM_CONSTRUCT_ONLY = 8;
  static const int G_PARAM_LAX_VALIDATION = 16;
  static const int G_PARAM_STATIC_NAME = 32;
  static const int G_PARAM_PRIVATE = 32;
  static const int G_PARAM_STATIC_NICK = 64;
  static const int G_PARAM_STATIC_BLURB = 128;
  static const int G_PARAM_EXPLICIT_NOTIFY = 1073741824;
  static const int G_PARAM_DEPRECATED = -2147483648;
}

/// GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)
/// @g_type_instance: private #GTypeInstance portion
/// @name: name of this parameter: always an interned string
/// @flags: #GParamFlags flags for this parameter
/// @value_type: the #GValue type for this parameter
/// @owner_type: #GType type that uses (introduces) this parameter
///
/// All other fields of the GParamSpec struct are private and
/// should not be used directly.
final class _GParamSpec extends ffi.Struct {
  external GTypeInstance g_type_instance;

  external ffi.Pointer<gchar> name;

  @ffi.Int32()
  external int flags;

  @GType()
  external int value_type;

  @GType()
  external int owner_type;

  external ffi.Pointer<gchar> _nick;

  external ffi.Pointer<gchar> _blurb;

  external ffi.Pointer<GData> qdata;

  @guint()
  external int ref_count;

  @guint()
  external int param_id;
}

/// GParamSpecClass:
/// @g_type_class: the parent class
/// @value_type: the #GValue type for this parameter
/// @finalize: The instance finalization function (optional), should chain
/// up to the finalize method of the parent class.
/// @value_set_default: Resets a @value to the default value for this type
/// (recommended, the default is g_value_reset()), see
/// g_param_value_set_default().
/// @value_validate: Ensures that the contents of @value comply with the
/// specifications set out by this type (optional), see
/// g_param_value_validate().
/// @values_cmp: Compares @value1 with @value2 according to this type
/// (recommended, the default is memcmp()), see g_param_values_cmp().
///
/// The class structure for the GParamSpec type.
/// Normally, GParamSpec classes are filled by
/// g_param_type_register_static().
final class _GParamSpecClass extends ffi.Struct {
  external GTypeClass g_type_class;

  @GType()
  external int value_type;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GParamSpec> pspec)>>
      finalize;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GParamSpec> pspec, ffi.Pointer<GValue> value)>>
      value_set_default;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GParamSpec> pspec, ffi.Pointer<GValue> value)>>
      value_validate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gint Function(
              ffi.Pointer<GParamSpec> pspec,
              ffi.Pointer<GValue> value1,
              ffi.Pointer<GValue> value2)>> values_cmp;

  @ffi.Array.multi([4])
  external ffi.Array<gpointer> dummy;
}

typedef GParamSpec = _GParamSpec;

/// GParameter:
/// @name: the parameter name
/// @value: the parameter value
///
/// The GParameter struct is an auxiliary structure used
/// to hand parameter name/value pairs to g_object_newv().
///
/// Deprecated: 2.54: This type is not introspectable.
final class _GParameter extends ffi.Struct {
  external ffi.Pointer<gchar> name;

  external GValue value;
}

final class _GParamSpecPool extends ffi.Opaque {}

/// GParamSpecTypeInfo:
/// @instance_size: Size of the instance (object) structure.
/// @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.
/// @instance_init: Location of the instance initialization function (optional).
/// @value_type: The #GType of values conforming to this #GParamSpec
/// @finalize: The instance finalization function (optional).
/// @value_set_default: Resets a @value to the default value for @pspec
/// (recommended, the default is g_value_reset()), see
/// g_param_value_set_default().
/// @value_validate: Ensures that the contents of @value comply with the
/// specifications set out by @pspec (optional), see
/// g_param_value_validate().
/// @values_cmp: Compares @value1 with @value2 according to @pspec
/// (recommended, the default is memcmp()), see g_param_values_cmp().
///
/// This structure is used to provide the type system with the information
/// required to initialize and destruct (finalize) a parameter's class and
/// instances thereof.
///
/// The initialized structure is passed to the g_param_type_register_static()
/// The type system will perform a deep copy of this structure, so its memory
/// does not need to be persistent across invocation of
/// g_param_type_register_static().
final class _GParamSpecTypeInfo extends ffi.Struct {
  @guint16()
  external int instance_size;

  @guint16()
  external int n_preallocs;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GParamSpec> pspec)>>
      instance_init;

  @GType()
  external int value_type;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GParamSpec> pspec)>>
      finalize;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GParamSpec> pspec, ffi.Pointer<GValue> value)>>
      value_set_default;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GParamSpec> pspec, ffi.Pointer<GValue> value)>>
      value_validate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gint Function(
              ffi.Pointer<GParamSpec> pspec,
              ffi.Pointer<GValue> value1,
              ffi.Pointer<GValue> value2)>> values_cmp;
}

/// GClosure:
/// @in_marshal: Indicates whether the closure is currently being invoked with
/// g_closure_invoke()
/// @is_invalid: Indicates whether the closure has been invalidated by
/// g_closure_invalidate()
///
/// A #GClosure represents a callback supplied by the programmer.
final class _GClosure extends ffi.Opaque {}

final class _GClosureNotifyData extends ffi.Struct {
  external gpointer data;

  external GClosureNotify notify;
}

/// GClosureNotify:
/// @data: data specified when registering the notification callback
/// @closure: the #GClosure on which the notification is emitted
///
/// The type used for the various notification callbacks which can be registered
/// on closures.
typedef GClosureNotify
    = ffi.Pointer<ffi.NativeFunction<GClosureNotifyFunction>>;
typedef GClosureNotifyFunction = ffi.Void Function(
    gpointer data, ffi.Pointer<GClosure> closure);
typedef DartGClosureNotifyFunction = void Function(
    gpointer data, ffi.Pointer<GClosure> closure);
typedef GClosure = _GClosure;

final class _GCClosure extends ffi.Opaque {}

/// GSignalQuery:
/// @signal_id: The signal id of the signal being queried, or 0 if the
/// signal to be queried was unknown.
/// @signal_name: The signal name.
/// @itype: The interface/instance type that this signal can be emitted for.
/// @signal_flags: The signal flags as passed in to g_signal_new().
/// @return_type: The return type for user callbacks.
/// @n_params: The number of parameters that user callbacks take.
/// @param_types: (array length=n_params): The individual parameter types for
/// user callbacks, note that the effective callback signature is:
/// |[<!-- language="C" -->
/// @return_type callback (#gpointer     data1,
/// [param_types param_names,]
/// gpointer     data2);
/// ]|
///
/// A structure holding in-depth information for a specific signal.
///
/// See also: g_signal_query()
final class _GSignalQuery extends ffi.Struct {
  @guint()
  external int signal_id;

  external ffi.Pointer<gchar> signal_name;

  @GType()
  external int itype;

  @ffi.Int32()
  external int signal_flags;

  @GType()
  external int return_type;

  @guint()
  external int n_params;

  external ffi.Pointer<GType> param_types;
}

/// GSignalFlags:
/// @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.
/// @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.
/// @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.
/// @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in
/// emission for this very object will not be emitted recursively,
/// but instead cause the first emission to be restarted.
/// @G_SIGNAL_DETAILED: This signal supports "::detail" appendices to the signal name
/// upon handler connections and emissions.
/// @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive
/// objects from user code via g_signal_emit() and friends, without
/// the need of being embedded into extra code that performs pre or
/// post emission adjustments on the object. They can also be thought
/// of as object methods which can be called generically by
/// third-party code.
/// @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.
/// @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the
/// arguments, even if there are no signal handlers connected.  Since 2.30.
/// @G_SIGNAL_DEPRECATED: The signal is deprecated and will be removed
/// in a future version. A warning will be generated if it is connected while
/// running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.
/// @G_SIGNAL_ACCUMULATOR_FIRST_RUN: Only used in #GSignalAccumulator accumulator
/// functions for the #GSignalInvocationHint::run_type field to mark the first
/// call to the accumulator function for a signal emission.  Since 2.68.
///
/// The signal flags are used to specify a signal's behaviour.
abstract class GSignalFlags {
  static const int G_SIGNAL_RUN_FIRST = 1;
  static const int G_SIGNAL_RUN_LAST = 2;
  static const int G_SIGNAL_RUN_CLEANUP = 4;
  static const int G_SIGNAL_NO_RECURSE = 8;
  static const int G_SIGNAL_DETAILED = 16;
  static const int G_SIGNAL_ACTION = 32;
  static const int G_SIGNAL_NO_HOOKS = 64;
  static const int G_SIGNAL_MUST_COLLECT = 128;
  static const int G_SIGNAL_DEPRECATED = 256;
  static const int G_SIGNAL_ACCUMULATOR_FIRST_RUN = 131072;
}

/// GSignalInvocationHint:
/// @signal_id: The signal id of the signal invoking the callback
/// @detail: The detail passed on for this emission
/// @run_type: The stage the signal emission is currently in, this
/// field will contain one of %G_SIGNAL_RUN_FIRST,
/// %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.
/// %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator
/// function for a signal emission.
///
/// The #GSignalInvocationHint structure is used to pass on additional information
/// to callbacks during a signal emission.
final class _GSignalInvocationHint extends ffi.Struct {
  @guint()
  external int signal_id;

  @GQuark()
  external int detail;

  @ffi.Int32()
  external int run_type;
}

/// GConnectFlags:
/// @G_CONNECT_AFTER: whether the handler should be called before or after the
/// default handler of the signal.
/// @G_CONNECT_SWAPPED: whether the instance and data should be swapped when
/// calling the handler; see g_signal_connect_swapped() for an example.
///
/// The connection flags are used to specify the behaviour of a signal's
/// connection.
abstract class GConnectFlags {
  static const int G_CONNECT_AFTER = 1;
  static const int G_CONNECT_SWAPPED = 2;
}

/// GSignalMatchType:
/// @G_SIGNAL_MATCH_ID: The signal id must be equal.
/// @G_SIGNAL_MATCH_DETAIL: The signal detail must be equal.
/// @G_SIGNAL_MATCH_CLOSURE: The closure must be the same.
/// @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.
/// @G_SIGNAL_MATCH_DATA: The closure data must be the same.
/// @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may be matched.
///
/// The match types specify what g_signal_handlers_block_matched(),
/// g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
/// match signals by.
abstract class GSignalMatchType {
  static const int G_SIGNAL_MATCH_ID = 1;
  static const int G_SIGNAL_MATCH_DETAIL = 2;
  static const int G_SIGNAL_MATCH_CLOSURE = 4;
  static const int G_SIGNAL_MATCH_FUNC = 8;
  static const int G_SIGNAL_MATCH_DATA = 16;
  static const int G_SIGNAL_MATCH_UNBLOCKED = 32;
}

/// GObject:
///
/// The base object type.
///
/// All the fields in the `GObject` structure are private to the implementation
/// and should never be accessed directly.
///
/// Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
/// alignment of the largest basic GLib type (typically this is #guint64 or
/// #gdouble). If you need larger alignment for an element in a #GObject, you
/// should allocate it on the heap (aligned), or arrange for your #GObject to be
/// appropriately padded. This guarantee applies to the #GObject (or derived)
/// struct, the #GObjectClass (or derived) struct, and any private data allocated
/// by G_ADD_PRIVATE().
final class _GObject extends ffi.Struct {
  external GTypeInstance g_type_instance;

  @guint()
  external int ref_count;

  external ffi.Pointer<GData> qdata;
}

/// GObjectClass:
/// @g_type_class: the parent class
/// @constructor: the @constructor function is called by g_object_new () to
/// complete the object initialization after all the construction properties are
/// set. The first thing a @constructor implementation must do is chain up to the
/// @constructor of the parent class. Overriding @constructor should be rarely
/// needed, e.g. to handle construct properties, or to implement singletons.
/// @set_property: the generic setter for all properties of this type. Should be
/// overridden for every type with properties. If implementations of
/// @set_property don't emit property change notification explicitly, this will
/// be done implicitly by the type system. However, if the notify signal is
/// emitted explicitly, the type system will not emit it a second time.
/// @get_property: the generic getter for all properties of this type. Should be
/// overridden for every type with properties.
/// @dispose: the @dispose function is supposed to drop all references to other
/// objects, but keep the instance otherwise intact, so that client method
/// invocations still work. It may be run multiple times (due to reference
/// loops). Before returning, @dispose should chain up to the @dispose method
/// of the parent class.
/// @finalize: instance finalization function, should finish the finalization of
/// the instance begun in @dispose and chain up to the @finalize method of the
/// parent class.
/// @dispatch_properties_changed: emits property change notification for a bunch
/// of properties. Overriding @dispatch_properties_changed should be rarely
/// needed.
/// @notify: the class closure for the notify signal
/// @constructed: the @constructed function is called by g_object_new() as the
/// final step of the object creation process.  At the point of the call, all
/// construction properties have been set on the object.  The purpose of this
/// call is to allow for object initialisation steps that can only be performed
/// after construction properties have been set.  @constructed implementors
/// should chain up to the @constructed call of their parent class to allow it
/// to complete its initialisation.
///
/// The class structure for the GObject type.
///
/// |[<!-- language="C" -->
/// // Example of implementing a singleton using a constructor.
/// static MySingleton *the_singleton = NULL;
///
/// static GObject*
/// my_singleton_constructor (GType                  type,
/// guint                  n_construct_params,
/// GObjectConstructParam *construct_params)
/// {
/// GObject *object;
///
/// if (!the_singleton)
/// {
/// object = G_OBJECT_CLASS (parent_class)->constructor (type,
/// n_construct_params,
/// construct_params);
/// the_singleton = MY_SINGLETON (object);
/// }
/// else
/// object = g_object_ref (G_OBJECT (the_singleton));
///
/// return object;
/// }
/// ]|
final class _GObjectClass extends ffi.Struct {
  external GTypeClass g_type_class;

  external ffi.Pointer<GSList> construct_properties;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GObject> Function(
                  GType type,
                  guint n_construct_properties,
                  ffi.Pointer<GObjectConstructParam> construct_properties)>>
      constructor;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GObject> object,
              guint property_id,
              ffi.Pointer<GValue> value,
              ffi.Pointer<GParamSpec> pspec)>> set_property;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GObject> object,
              guint property_id,
              ffi.Pointer<GValue> value,
              ffi.Pointer<GParamSpec> pspec)>> get_property;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GObject> object)>>
      dispose;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GObject> object)>>
      finalize;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GObject> object, guint n_pspecs,
                  ffi.Pointer<ffi.Pointer<GParamSpec>> pspecs)>>
      dispatch_properties_changed;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GObject> object, ffi.Pointer<GParamSpec> pspec)>>
      notify;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GObject> object)>>
      constructed;

  @gsize()
  external int flags;

  @ffi.Array.multi([6])
  external ffi.Array<gpointer> pdummy;
}

typedef GObject = _GObject;
typedef GObjectConstructParam = _GObjectConstructParam;

/// GObjectConstructParam:
/// @pspec: the #GParamSpec of the construct parameter
/// @value: the value to set the parameter to
///
/// The GObjectConstructParam struct is an auxiliary structure used to hand
/// #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass.
final class _GObjectConstructParam extends ffi.Struct {
  external ffi.Pointer<GParamSpec> pspec;

  external ffi.Pointer<GValue> value;
}

final class GWeakRef extends ffi.Struct {
  external UnnamedUnion10 priv;
}

final class UnnamedUnion10 extends ffi.Union {
  external gpointer p;
}

final class _GBinding extends ffi.Opaque {}

/// GBindingFlags:
/// @G_BINDING_DEFAULT: The default binding; if the source property
/// changes, the target property is updated with its value.
/// @G_BINDING_BIDIRECTIONAL: Bidirectional binding; if either the
/// property of the source or the property of the target changes,
/// the other is updated.
/// @G_BINDING_SYNC_CREATE: Synchronize the values of the source and
/// target properties when creating the binding; the direction of
/// the synchronization is always from the source to the target.
/// @G_BINDING_INVERT_BOOLEAN: If the two properties being bound are
/// booleans, setting one to %TRUE will result in the other being
/// set to %FALSE and vice versa. This flag will only work for
/// boolean properties, and cannot be used when passing custom
/// transformation functions to g_object_bind_property_full().
///
/// Flags to be passed to g_object_bind_property() or
/// g_object_bind_property_full().
///
/// This enumeration can be extended at later date.
///
/// Since: 2.26
abstract class GBindingFlags {
  static const int G_BINDING_DEFAULT = 0;
  static const int G_BINDING_BIDIRECTIONAL = 1;
  static const int G_BINDING_SYNC_CREATE = 2;
  static const int G_BINDING_INVERT_BOOLEAN = 4;
}

final class _GBindingGroup extends ffi.Opaque {}

/// GEnumClass:
/// @g_type_class: the parent class
/// @minimum: the smallest possible value.
/// @maximum: the largest possible value.
/// @n_values: the number of possible values.
/// @values: an array of #GEnumValue structs describing the
/// individual values.
///
/// The class of an enumeration type holds information about its
/// possible values.
final class _GEnumClass extends ffi.Struct {
  external GTypeClass g_type_class;

  @gint()
  external int minimum;

  @gint()
  external int maximum;

  @guint()
  external int n_values;

  external ffi.Pointer<GEnumValue> values;
}

typedef GEnumValue = _GEnumValue;

/// GEnumValue:
/// @value: the enum value
/// @value_name: the name of the value
/// @value_nick: the nickname of the value
///
/// A structure which contains a single enum value, its name, and its
/// nickname.
final class _GEnumValue extends ffi.Struct {
  @gint()
  external int value;

  external ffi.Pointer<gchar> value_name;

  external ffi.Pointer<gchar> value_nick;
}

/// GFlagsClass:
/// @g_type_class: the parent class
/// @mask: a mask covering all possible values.
/// @n_values: the number of possible values.
/// @values: an array of #GFlagsValue structs describing the
/// individual values.
///
/// The class of a flags type holds information about its
/// possible values.
final class _GFlagsClass extends ffi.Struct {
  external GTypeClass g_type_class;

  @guint()
  external int mask;

  @guint()
  external int n_values;

  external ffi.Pointer<GFlagsValue> values;
}

typedef GFlagsValue = _GFlagsValue;

/// GFlagsValue:
/// @value: the flags value
/// @value_name: the name of the value
/// @value_nick: the nickname of the value
///
/// A structure which contains a single flags value, its name, and its
/// nickname.
final class _GFlagsValue extends ffi.Struct {
  @guint()
  external int value;

  external ffi.Pointer<gchar> value_name;

  external ffi.Pointer<gchar> value_nick;
}

/// GParamSpecChar:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for character properties.
final class _GParamSpecChar extends ffi.Struct {
  external GParamSpec parent_instance;

  @gint8()
  external int minimum;

  @gint8()
  external int maximum;

  @gint8()
  external int default_value;
}

typedef gint8 = ffi.SignedChar;
typedef Dartgint8 = int;

/// GParamSpecUChar:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned character properties.
final class _GParamSpecUChar extends ffi.Struct {
  external GParamSpec parent_instance;

  @guint8()
  external int minimum;

  @guint8()
  external int maximum;

  @guint8()
  external int default_value;
}

/// GParamSpecBoolean:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for boolean properties.
final class _GParamSpecBoolean extends ffi.Struct {
  external GParamSpec parent_instance;

  @gboolean()
  external int default_value;
}

/// GParamSpecInt:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for integer properties.
final class _GParamSpecInt extends ffi.Struct {
  external GParamSpec parent_instance;

  @gint()
  external int minimum;

  @gint()
  external int maximum;

  @gint()
  external int default_value;
}

/// GParamSpecUInt:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned integer properties.
final class _GParamSpecUInt extends ffi.Struct {
  external GParamSpec parent_instance;

  @guint()
  external int minimum;

  @guint()
  external int maximum;

  @guint()
  external int default_value;
}

/// GParamSpecLong:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for long integer properties.
final class _GParamSpecLong extends ffi.Struct {
  external GParamSpec parent_instance;

  @glong()
  external int minimum;

  @glong()
  external int maximum;

  @glong()
  external int default_value;
}

/// GParamSpecULong:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned long integer properties.
final class _GParamSpecULong extends ffi.Struct {
  external GParamSpec parent_instance;

  @gulong()
  external int minimum;

  @gulong()
  external int maximum;

  @gulong()
  external int default_value;
}

/// GParamSpecInt64:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for 64bit integer properties.
final class _GParamSpecInt64 extends ffi.Struct {
  external GParamSpec parent_instance;

  @gint64()
  external int minimum;

  @gint64()
  external int maximum;

  @gint64()
  external int default_value;
}

/// GParamSpecUInt64:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties.
final class _GParamSpecUInt64 extends ffi.Struct {
  external GParamSpec parent_instance;

  @guint64()
  external int minimum;

  @guint64()
  external int maximum;

  @guint64()
  external int default_value;
}

/// GParamSpecUnichar:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties.
final class _GParamSpecUnichar extends ffi.Struct {
  external GParamSpec parent_instance;

  @gunichar()
  external int default_value;
}

/// gunichar:
///
/// A type which can hold any UTF-32 or UCS-4 character code,
/// also known as a Unicode code point.
///
/// If you want to produce the UTF-8 representation of a #gunichar,
/// use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse
/// process.
///
/// To print/scan values of this type as integer, use
/// %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.
///
/// The notation to express a Unicode code point in running text is
/// as a hexadecimal number with four to six digits and uppercase
/// letters, prefixed by the string "U+". Leading zeros are omitted,
/// unless the code point would have fewer than four hexadecimal digits.
/// For example, "U+0041 LATIN CAPITAL LETTER A". To print a code point
/// in the U+-notation, use the format string "U+\%04"G_GINT32_FORMAT"X".
/// To scan, use the format string "U+\%06"G_GINT32_FORMAT"X".
///
/// |[
/// gunichar c;
/// sscanf ("U+0041", "U+%06"G_GINT32_FORMAT"X", &amp;c)
/// g_print ("Read U+%04"G_GINT32_FORMAT"X", c);
/// ]|
typedef gunichar = guint32;

/// GParamSpecEnum:
/// @parent_instance: private #GParamSpec portion
/// @enum_class: the #GEnumClass for the enum
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for enum
/// properties.
final class _GParamSpecEnum extends ffi.Struct {
  external GParamSpec parent_instance;

  external ffi.Pointer<GEnumClass> enum_class;

  @gint()
  external int default_value;
}

typedef GEnumClass = _GEnumClass;

/// GParamSpecFlags:
/// @parent_instance: private #GParamSpec portion
/// @flags_class: the #GFlagsClass for the flags
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for flags
/// properties.
final class _GParamSpecFlags extends ffi.Struct {
  external GParamSpec parent_instance;

  external ffi.Pointer<GFlagsClass> flags_class;

  @guint()
  external int default_value;
}

typedef GFlagsClass = _GFlagsClass;

/// GParamSpecFloat:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
/// @epsilon: values closer than @epsilon will be considered identical
/// by g_param_values_cmp(); the default value is 1e-30.
///
/// A #GParamSpec derived structure that contains the meta data for float properties.
final class _GParamSpecFloat extends ffi.Struct {
  external GParamSpec parent_instance;

  @gfloat()
  external double minimum;

  @gfloat()
  external double maximum;

  @gfloat()
  external double default_value;

  @gfloat()
  external double epsilon;
}

/// GParamSpecDouble:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
/// @epsilon: values closer than @epsilon will be considered identical
/// by g_param_values_cmp(); the default value is 1e-90.
///
/// A #GParamSpec derived structure that contains the meta data for double properties.
final class _GParamSpecDouble extends ffi.Struct {
  external GParamSpec parent_instance;

  @gdouble()
  external double minimum;

  @gdouble()
  external double maximum;

  @gdouble()
  external double default_value;

  @gdouble()
  external double epsilon;
}

/// GParamSpecString:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
/// @cset_first: a string containing the allowed values for the first byte
/// @cset_nth: a string containing the allowed values for the subsequent bytes
/// @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.
/// @null_fold_if_empty: replace empty string by %NULL
/// @ensure_non_null: replace %NULL strings by an empty string
///
/// A #GParamSpec derived structure that contains the meta data for string
/// properties.
final class _GParamSpecString extends ffi.Opaque {}

/// GParamSpecParam:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM
/// properties.
final class _GParamSpecParam extends ffi.Struct {
  external GParamSpec parent_instance;
}

/// GParamSpecBoxed:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for boxed properties.
final class _GParamSpecBoxed extends ffi.Struct {
  external GParamSpec parent_instance;
}

/// GParamSpecPointer:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for pointer properties.
final class _GParamSpecPointer extends ffi.Struct {
  external GParamSpec parent_instance;
}

/// GParamSpecValueArray:
/// @parent_instance: private #GParamSpec portion
/// @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL
/// @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements
///
/// A #GParamSpec derived structure that contains the meta data for #GValueArray properties.
final class _GParamSpecValueArray extends ffi.Struct {
  external GParamSpec parent_instance;

  external ffi.Pointer<GParamSpec> element_spec;

  @guint()
  external int fixed_n_elements;
}

/// GParamSpecObject:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for object properties.
final class _GParamSpecObject extends ffi.Struct {
  external GParamSpec parent_instance;
}

/// GParamSpecOverride:
///
/// A #GParamSpec derived structure that redirects operations to
/// other types of #GParamSpec.
///
/// All operations other than getting or setting the value are redirected,
/// including accessing the nick and blurb, validating a value, and so
/// forth.
///
/// See g_param_spec_get_redirect_target() for retrieving the overridden
/// property. #GParamSpecOverride is used in implementing
/// g_object_class_override_property(), and will not be directly useful
/// unless you are implementing a new base type similar to GObject.
///
/// Since: 2.4
final class _GParamSpecOverride extends ffi.Struct {
  external GParamSpec parent_instance;

  external ffi.Pointer<GParamSpec> overridden;
}

/// GParamSpecGType:
/// @parent_instance: private #GParamSpec portion
/// @is_a_type: a #GType whose subtypes can occur as values
///
/// A #GParamSpec derived structure that contains the meta data for #GType properties.
///
/// Since: 2.10
final class _GParamSpecGType extends ffi.Struct {
  external GParamSpec parent_instance;

  @GType()
  external int is_a_type;
}

/// GParamSpecVariant:
/// @parent_instance: private #GParamSpec portion
/// @type: a #GVariantType, or %NULL
/// @default_value: a #GVariant, or %NULL
///
/// A #GParamSpec derived structure that contains the meta data for #GVariant properties.
///
/// When comparing values with g_param_values_cmp(), scalar values with the same
/// type will be compared with g_variant_compare(). Other non-%NULL variants will
/// be checked for equality with g_variant_equal(), and their sort order is
/// otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL
/// values compare equal.
///
/// Since: 2.26
final class _GParamSpecVariant extends ffi.Struct {
  external GParamSpec parent_instance;

  external ffi.Pointer<GVariantType> type;

  external ffi.Pointer<GVariant> default_value;

  @ffi.Array.multi([4])
  external ffi.Array<gpointer> padding;
}

final class _GSignalGroup extends ffi.Opaque {}

/// GTypeModule:
/// @name: the name of the module
///
/// The members of the GTypeModule structure should not
/// be accessed directly, except for the @name field.
final class _GTypeModule extends ffi.Struct {
  external GObject parent_instance;

  @guint()
  external int use_count;

  external ffi.Pointer<GSList> type_infos;

  external ffi.Pointer<GSList> interface_infos;

  external ffi.Pointer<gchar> name;
}

/// GTypeModuleClass:
/// @parent_class: the parent class
/// @load: loads the module and registers one or more types using
/// g_type_module_register_type().
/// @unload: unloads the module
///
/// In order to implement dynamic loading of types based on #GTypeModule,
/// the @load and @unload functions in #GTypeModuleClass must be implemented.
final class _GTypeModuleClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi
      .NativeFunction<gboolean Function(ffi.Pointer<GTypeModule> module)>> load;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GTypeModule> module)>>
      unload;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> reserved4;
}

typedef GObjectClass = _GObjectClass;
typedef GTypeModule = _GTypeModule;

/// GTypePlugin:
///
/// The GTypePlugin typedef is used as a placeholder
/// for objects that implement the GTypePlugin interface.
/// /
/// /**
/// GTypePluginClass:
/// @use_plugin: Increases the use count of the plugin.
/// @unuse_plugin: Decreases the use count of the plugin.
/// @complete_type_info: Fills in the #GTypeInfo and
/// #GTypeValueTable structs for the type. The structs are initialized
/// with `memset(s, 0, sizeof (s))` before calling this function.
/// @complete_interface_info: Fills in missing parts of the #GInterfaceInfo
/// for the interface. The structs is initialized with
/// `memset(s, 0, sizeof (s))` before calling this function.
///
/// The #GTypePlugin interface is used by the type system in order to handle
/// the lifecycle of dynamically loaded types.
final class _GTypePluginClass extends ffi.Struct {
  external GTypeInterface base_iface;

  external GTypePluginUse use_plugin;

  external GTypePluginUnuse unuse_plugin;

  external GTypePluginCompleteTypeInfo complete_type_info;

  external GTypePluginCompleteInterfaceInfo complete_interface_info;
}

typedef GTypeInterface = _GTypeInterface;

/// GTypePluginUse:
/// @plugin: the #GTypePlugin whose use count should be increased
///
/// The type of the @use_plugin function of #GTypePluginClass, which gets called
/// to increase the use count of @plugin.
typedef GTypePluginUse
    = ffi.Pointer<ffi.NativeFunction<GTypePluginUseFunction>>;
typedef GTypePluginUseFunction = ffi.Void Function(
    ffi.Pointer<GTypePlugin> plugin);
typedef DartGTypePluginUseFunction = void Function(
    ffi.Pointer<GTypePlugin> plugin);
typedef GTypePlugin = _GTypePlugin;

/// GTypePluginUnuse:
/// @plugin: the #GTypePlugin whose use count should be decreased
///
/// The type of the @unuse_plugin function of #GTypePluginClass.
typedef GTypePluginUnuse
    = ffi.Pointer<ffi.NativeFunction<GTypePluginUnuseFunction>>;
typedef GTypePluginUnuseFunction = ffi.Void Function(
    ffi.Pointer<GTypePlugin> plugin);
typedef DartGTypePluginUnuseFunction = void Function(
    ffi.Pointer<GTypePlugin> plugin);

/// GTypePluginCompleteTypeInfo:
/// @plugin: the #GTypePlugin
/// @g_type: the #GType whose info is completed
/// @info: the #GTypeInfo struct to fill in
/// @value_table: the #GTypeValueTable to fill in
///
/// The type of the @complete_type_info function of #GTypePluginClass.
typedef GTypePluginCompleteTypeInfo
    = ffi.Pointer<ffi.NativeFunction<GTypePluginCompleteTypeInfoFunction>>;
typedef GTypePluginCompleteTypeInfoFunction = ffi.Void Function(
    ffi.Pointer<GTypePlugin> plugin,
    GType g_type,
    ffi.Pointer<GTypeInfo> info,
    ffi.Pointer<GTypeValueTable> value_table);
typedef DartGTypePluginCompleteTypeInfoFunction = void Function(
    ffi.Pointer<GTypePlugin> plugin,
    Dartgsize g_type,
    ffi.Pointer<GTypeInfo> info,
    ffi.Pointer<GTypeValueTable> value_table);
typedef GTypeInfo = _GTypeInfo;

/// GTypePluginCompleteInterfaceInfo:
/// @plugin: the #GTypePlugin
/// @instance_type: the #GType of an instantiatable type to which the interface
/// is added
/// @interface_type: the #GType of the interface whose info is completed
/// @info: the #GInterfaceInfo to fill in
///
/// The type of the @complete_interface_info function of #GTypePluginClass.
typedef GTypePluginCompleteInterfaceInfo
    = ffi.Pointer<ffi.NativeFunction<GTypePluginCompleteInterfaceInfoFunction>>;
typedef GTypePluginCompleteInterfaceInfoFunction = ffi.Void Function(
    ffi.Pointer<GTypePlugin> plugin,
    GType instance_type,
    GType interface_type,
    ffi.Pointer<GInterfaceInfo> info);
typedef DartGTypePluginCompleteInterfaceInfoFunction = void Function(
    ffi.Pointer<GTypePlugin> plugin,
    Dartgsize instance_type,
    Dartgsize interface_type,
    ffi.Pointer<GInterfaceInfo> info);
typedef GInterfaceInfo = _GInterfaceInfo;

/// GValueArray:
/// @n_values: number of values contained in the array
/// @values: array of values
///
/// A #GValueArray contains an array of #GValue elements.
final class _GValueArray extends ffi.Struct {
  @guint()
  external int n_values;

  external ffi.Pointer<GValue> values;

  @guint()
  external int n_prealloced;
}

/// GAppInfoCreateFlags:
/// @G_APP_INFO_CREATE_NONE: No flags.
/// @G_APP_INFO_CREATE_NEEDS_TERMINAL: Application opens in a terminal window.
/// @G_APP_INFO_CREATE_SUPPORTS_URIS: Application supports URI arguments.
/// @G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: Application supports startup notification. Since 2.26
///
/// Flags used when creating a #GAppInfo.
abstract class GAppInfoCreateFlags {
  static const int G_APP_INFO_CREATE_NONE = 0;
  static const int G_APP_INFO_CREATE_NEEDS_TERMINAL = 1;
  static const int G_APP_INFO_CREATE_SUPPORTS_URIS = 2;
  static const int G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 4;
}

/// GConverterFlags:
/// @G_CONVERTER_NO_FLAGS: No flags.
/// @G_CONVERTER_INPUT_AT_END: At end of input data
/// @G_CONVERTER_FLUSH: Flush data
///
/// Flags used when calling a g_converter_convert().
///
/// Since: 2.24
abstract class GConverterFlags {
  static const int G_CONVERTER_NO_FLAGS = 0;
  static const int G_CONVERTER_INPUT_AT_END = 1;
  static const int G_CONVERTER_FLUSH = 2;
}

/// GConverterResult:
/// @G_CONVERTER_ERROR: There was an error during conversion.
/// @G_CONVERTER_CONVERTED: Some data was consumed or produced
/// @G_CONVERTER_FINISHED: The conversion is finished
/// @G_CONVERTER_FLUSHED: Flushing is finished
///
/// Results returned from g_converter_convert().
///
/// Since: 2.24
abstract class GConverterResult {
  static const int G_CONVERTER_ERROR = 0;
  static const int G_CONVERTER_CONVERTED = 1;
  static const int G_CONVERTER_FINISHED = 2;
  static const int G_CONVERTER_FLUSHED = 3;
}

/// GDataStreamByteOrder:
/// @G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: Selects Big Endian byte order.
/// @G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: Selects Little Endian byte order.
/// @G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: Selects endianness based on host machine's architecture.
///
/// #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
/// across various machine architectures.
abstract class GDataStreamByteOrder {
  static const int G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN = 0;
  static const int G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN = 1;
  static const int G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN = 2;
}

/// GDataStreamNewlineType:
/// @G_DATA_STREAM_NEWLINE_TYPE_LF: Selects "LF" line endings, common on most modern UNIX platforms.
/// @G_DATA_STREAM_NEWLINE_TYPE_CR: Selects "CR" line endings.
/// @G_DATA_STREAM_NEWLINE_TYPE_CR_LF: Selects "CR, LF" line ending, common on Microsoft Windows.
/// @G_DATA_STREAM_NEWLINE_TYPE_ANY: Automatically try to handle any line ending type.
///
/// #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
abstract class GDataStreamNewlineType {
  static const int G_DATA_STREAM_NEWLINE_TYPE_LF = 0;
  static const int G_DATA_STREAM_NEWLINE_TYPE_CR = 1;
  static const int G_DATA_STREAM_NEWLINE_TYPE_CR_LF = 2;
  static const int G_DATA_STREAM_NEWLINE_TYPE_ANY = 3;
}

/// GFileAttributeType:
/// @G_FILE_ATTRIBUTE_TYPE_INVALID: indicates an invalid or uninitialized type.
/// @G_FILE_ATTRIBUTE_TYPE_STRING: a null terminated UTF8 string.
/// @G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: a zero terminated string of non-zero bytes.
/// @G_FILE_ATTRIBUTE_TYPE_BOOLEAN: a boolean value.
/// @G_FILE_ATTRIBUTE_TYPE_UINT32: an unsigned 4-byte/32-bit integer.
/// @G_FILE_ATTRIBUTE_TYPE_INT32: a signed 4-byte/32-bit integer.
/// @G_FILE_ATTRIBUTE_TYPE_UINT64: an unsigned 8-byte/64-bit integer.
/// @G_FILE_ATTRIBUTE_TYPE_INT64: a signed 8-byte/64-bit integer.
/// @G_FILE_ATTRIBUTE_TYPE_OBJECT: a #GObject.
/// @G_FILE_ATTRIBUTE_TYPE_STRINGV: a %NULL terminated char **. Since 2.22
///
/// The data types for file attributes.
abstract class GFileAttributeType {
  static const int G_FILE_ATTRIBUTE_TYPE_INVALID = 0;
  static const int G_FILE_ATTRIBUTE_TYPE_STRING = 1;
  static const int G_FILE_ATTRIBUTE_TYPE_BYTE_STRING = 2;
  static const int G_FILE_ATTRIBUTE_TYPE_BOOLEAN = 3;
  static const int G_FILE_ATTRIBUTE_TYPE_UINT32 = 4;
  static const int G_FILE_ATTRIBUTE_TYPE_INT32 = 5;
  static const int G_FILE_ATTRIBUTE_TYPE_UINT64 = 6;
  static const int G_FILE_ATTRIBUTE_TYPE_INT64 = 7;
  static const int G_FILE_ATTRIBUTE_TYPE_OBJECT = 8;
  static const int G_FILE_ATTRIBUTE_TYPE_STRINGV = 9;
}

/// GFileAttributeInfoFlags:
/// @G_FILE_ATTRIBUTE_INFO_NONE: no flags set.
/// @G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: copy the attribute values when the file is copied.
/// @G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: copy the attribute values when the file is moved.
///
/// Flags specifying the behaviour of an attribute.
abstract class GFileAttributeInfoFlags {
  static const int G_FILE_ATTRIBUTE_INFO_NONE = 0;
  static const int G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 1;
  static const int G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 2;
}

/// GFileAttributeStatus:
/// @G_FILE_ATTRIBUTE_STATUS_UNSET: Attribute value is unset (empty).
/// @G_FILE_ATTRIBUTE_STATUS_SET: Attribute value is set.
/// @G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: Indicates an error in setting the value.
///
/// Used by g_file_set_attributes_from_info() when setting file attributes.
abstract class GFileAttributeStatus {
  static const int G_FILE_ATTRIBUTE_STATUS_UNSET = 0;
  static const int G_FILE_ATTRIBUTE_STATUS_SET = 1;
  static const int G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING = 2;
}

/// GFileQueryInfoFlags:
/// @G_FILE_QUERY_INFO_NONE: No flags set.
/// @G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: Don't follow symlinks.
///
/// Flags used when querying a #GFileInfo.
abstract class GFileQueryInfoFlags {
  static const int G_FILE_QUERY_INFO_NONE = 0;
  static const int G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 1;
}

/// GFileCreateFlags:
/// @G_FILE_CREATE_NONE: No flags set.
/// @G_FILE_CREATE_PRIVATE: Create a file that can only be
/// accessed by the current user.
/// @G_FILE_CREATE_REPLACE_DESTINATION: Replace the destination
/// as if it didn't exist before. Don't try to keep any old
/// permissions, replace instead of following links. This
/// is generally useful if you're doing a "copy over"
/// rather than a "save new version of" replace operation.
/// You can think of it as "unlink destination" before
/// writing to it, although the implementation may not
/// be exactly like that. This flag can only be used with
/// g_file_replace() and its variants, including g_file_replace_contents().
/// Since 2.20
///
/// Flags used when an operation may create a file.
abstract class GFileCreateFlags {
  static const int G_FILE_CREATE_NONE = 0;
  static const int G_FILE_CREATE_PRIVATE = 1;
  static const int G_FILE_CREATE_REPLACE_DESTINATION = 2;
}

/// GFileMeasureFlags:
/// @G_FILE_MEASURE_NONE: No flags set.
/// @G_FILE_MEASURE_REPORT_ANY_ERROR: Report any error encountered
/// while traversing the directory tree.  Normally errors are only
/// reported for the toplevel file.
/// @G_FILE_MEASURE_APPARENT_SIZE: Tally usage based on apparent file
/// sizes.  Normally, the block-size is used, if available, as this is a
/// more accurate representation of disk space used.
/// Compare with `du --apparent-size`.
/// @G_FILE_MEASURE_NO_XDEV: Do not cross mount point boundaries.
/// Compare with `du -x`.
///
/// Flags that can be used with g_file_measure_disk_usage().
///
/// Since: 2.38
abstract class GFileMeasureFlags {
  static const int G_FILE_MEASURE_NONE = 0;
  static const int G_FILE_MEASURE_REPORT_ANY_ERROR = 2;
  static const int G_FILE_MEASURE_APPARENT_SIZE = 4;
  static const int G_FILE_MEASURE_NO_XDEV = 8;
}

/// GMountMountFlags:
/// @G_MOUNT_MOUNT_NONE: No flags set.
///
/// Flags used when mounting a mount.
abstract class GMountMountFlags {
  static const int G_MOUNT_MOUNT_NONE = 0;
}

/// GMountUnmountFlags:
/// @G_MOUNT_UNMOUNT_NONE: No flags set.
/// @G_MOUNT_UNMOUNT_FORCE: Unmount even if there are outstanding
/// file operations on the mount.
///
/// Flags used when an unmounting a mount.
abstract class GMountUnmountFlags {
  static const int G_MOUNT_UNMOUNT_NONE = 0;
  static const int G_MOUNT_UNMOUNT_FORCE = 1;
}

/// GDriveStartFlags:
/// @G_DRIVE_START_NONE: No flags set.
///
/// Flags used when starting a drive.
///
/// Since: 2.22
abstract class GDriveStartFlags {
  static const int G_DRIVE_START_NONE = 0;
}

/// GDriveStartStopType:
/// @G_DRIVE_START_STOP_TYPE_UNKNOWN: Unknown or drive doesn't support
/// start/stop.
/// @G_DRIVE_START_STOP_TYPE_SHUTDOWN: The stop method will physically
/// shut down the drive and e.g. power down the port the drive is
/// attached to.
/// @G_DRIVE_START_STOP_TYPE_NETWORK: The start/stop methods are used
/// for connecting/disconnect to the drive over the network.
/// @G_DRIVE_START_STOP_TYPE_MULTIDISK: The start/stop methods will
/// assemble/disassemble a virtual drive from several physical
/// drives.
/// @G_DRIVE_START_STOP_TYPE_PASSWORD: The start/stop methods will
/// unlock/lock the disk (for example using the ATA <quote>SECURITY
/// UNLOCK DEVICE</quote> command)
///
/// Enumeration describing how a drive can be started/stopped.
///
/// Since: 2.22
abstract class GDriveStartStopType {
  static const int G_DRIVE_START_STOP_TYPE_UNKNOWN = 0;
  static const int G_DRIVE_START_STOP_TYPE_SHUTDOWN = 1;
  static const int G_DRIVE_START_STOP_TYPE_NETWORK = 2;
  static const int G_DRIVE_START_STOP_TYPE_MULTIDISK = 3;
  static const int G_DRIVE_START_STOP_TYPE_PASSWORD = 4;
}

/// GFileCopyFlags:
/// @G_FILE_COPY_NONE: No flags set.
/// @G_FILE_COPY_OVERWRITE: Overwrite any existing files
/// @G_FILE_COPY_BACKUP: Make a backup of any existing files.
/// @G_FILE_COPY_NOFOLLOW_SYMLINKS: Don't follow symlinks.
/// @G_FILE_COPY_ALL_METADATA: Copy all file metadata instead of just default set used for copy (see #GFileInfo).
/// @G_FILE_COPY_NO_FALLBACK_FOR_MOVE: Don't use copy and delete fallback if native move not supported.
/// @G_FILE_COPY_TARGET_DEFAULT_PERMS: Leaves target file with default perms, instead of setting the source file perms.
///
/// Flags used when copying or moving files.
abstract class GFileCopyFlags {
  static const int G_FILE_COPY_NONE = 0;
  static const int G_FILE_COPY_OVERWRITE = 1;
  static const int G_FILE_COPY_BACKUP = 2;
  static const int G_FILE_COPY_NOFOLLOW_SYMLINKS = 4;
  static const int G_FILE_COPY_ALL_METADATA = 8;
  static const int G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 16;
  static const int G_FILE_COPY_TARGET_DEFAULT_PERMS = 32;
}

/// GFileMonitorFlags:
/// @G_FILE_MONITOR_NONE: No flags set.
/// @G_FILE_MONITOR_WATCH_MOUNTS: Watch for mount events.
/// @G_FILE_MONITOR_SEND_MOVED: Pair DELETED and CREATED events caused
/// by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
/// event instead (NB: not supported on all backends; the default
/// behaviour -without specifying this flag- is to send single DELETED
/// and CREATED events).  Deprecated since 2.46: use
/// %G_FILE_MONITOR_WATCH_MOVES instead.
/// @G_FILE_MONITOR_WATCH_HARD_LINKS: Watch for changes to the file made
/// via another hard link. Since 2.36.
/// @G_FILE_MONITOR_WATCH_MOVES: Watch for rename operations on a
/// monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
/// %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
/// events to be emitted when possible.  Since: 2.46.
///
/// Flags used to set what a #GFileMonitor will watch for.
abstract class GFileMonitorFlags {
  static const int G_FILE_MONITOR_NONE = 0;
  static const int G_FILE_MONITOR_WATCH_MOUNTS = 1;
  static const int G_FILE_MONITOR_SEND_MOVED = 2;
  static const int G_FILE_MONITOR_WATCH_HARD_LINKS = 4;
  static const int G_FILE_MONITOR_WATCH_MOVES = 8;
}

/// GFileType:
/// @G_FILE_TYPE_UNKNOWN: File's type is unknown.
/// @G_FILE_TYPE_REGULAR: File handle represents a regular file.
/// @G_FILE_TYPE_DIRECTORY: File handle represents a directory.
/// @G_FILE_TYPE_SYMBOLIC_LINK: File handle represents a symbolic link
/// (Unix systems).
/// @G_FILE_TYPE_SPECIAL: File is a "special" file, such as a socket, fifo,
/// block device, or character device.
/// @G_FILE_TYPE_SHORTCUT: File is a shortcut (Windows systems).
/// @G_FILE_TYPE_MOUNTABLE: File is a mountable location.
///
/// Indicates the file's on-disk type.
///
/// On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
/// use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
/// whether a file is a symlink or not. This is due to the fact that NTFS does
/// not have a single filesystem object type for symbolic links - it has
/// files that symlink to files, and directories that symlink to directories.
/// #GFileType enumeration cannot precisely represent this important distinction,
/// which is why all Windows symlinks will continue to be reported as
/// %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.
abstract class GFileType {
  static const int G_FILE_TYPE_UNKNOWN = 0;
  static const int G_FILE_TYPE_REGULAR = 1;
  static const int G_FILE_TYPE_DIRECTORY = 2;
  static const int G_FILE_TYPE_SYMBOLIC_LINK = 3;
  static const int G_FILE_TYPE_SPECIAL = 4;
  static const int G_FILE_TYPE_SHORTCUT = 5;
  static const int G_FILE_TYPE_MOUNTABLE = 6;
}

/// GFilesystemPreviewType:
/// @G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: Only preview files if user has explicitly requested it.
/// @G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: Preview files if user has requested preview of "local" files.
/// @G_FILESYSTEM_PREVIEW_TYPE_NEVER: Never preview files.
///
/// Indicates a hint from the file system whether files should be
/// previewed in a file manager. Returned as the value of the key
/// %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
abstract class GFilesystemPreviewType {
  static const int G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0;
  static const int G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL = 1;
  static const int G_FILESYSTEM_PREVIEW_TYPE_NEVER = 2;
}

/// GFileMonitorEvent:
/// @G_FILE_MONITOR_EVENT_CHANGED: a file changed.
/// @G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: a hint that this was probably the last change in a set of changes.
/// @G_FILE_MONITOR_EVENT_DELETED: a file was deleted.
/// @G_FILE_MONITOR_EVENT_CREATED: a file was created.
/// @G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: a file attribute was changed.
/// @G_FILE_MONITOR_EVENT_PRE_UNMOUNT: the file location will soon be unmounted.
/// @G_FILE_MONITOR_EVENT_UNMOUNTED: the file location was unmounted.
/// @G_FILE_MONITOR_EVENT_MOVED: the file was moved -- only sent if the
/// (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
/// @G_FILE_MONITOR_EVENT_RENAMED: the file was renamed within the
/// current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
/// flag is set.  Since: 2.46.
/// @G_FILE_MONITOR_EVENT_MOVED_IN: the file was moved into the
/// monitored directory from another location -- only sent if the
/// %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
/// @G_FILE_MONITOR_EVENT_MOVED_OUT: the file was moved out of the
/// monitored directory to another location -- only sent if the
/// %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
///
/// Specifies what type of event a monitor event is.
abstract class GFileMonitorEvent {
  static const int G_FILE_MONITOR_EVENT_CHANGED = 0;
  static const int G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT = 1;
  static const int G_FILE_MONITOR_EVENT_DELETED = 2;
  static const int G_FILE_MONITOR_EVENT_CREATED = 3;
  static const int G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED = 4;
  static const int G_FILE_MONITOR_EVENT_PRE_UNMOUNT = 5;
  static const int G_FILE_MONITOR_EVENT_UNMOUNTED = 6;
  static const int G_FILE_MONITOR_EVENT_MOVED = 7;
  static const int G_FILE_MONITOR_EVENT_RENAMED = 8;
  static const int G_FILE_MONITOR_EVENT_MOVED_IN = 9;
  static const int G_FILE_MONITOR_EVENT_MOVED_OUT = 10;
}

/// GIOErrorEnum:
/// @G_IO_ERROR_FAILED: Generic error condition for when an operation fails
/// and no more specific #GIOErrorEnum value is defined.
/// @G_IO_ERROR_NOT_FOUND: File not found.
/// @G_IO_ERROR_EXISTS: File already exists.
/// @G_IO_ERROR_IS_DIRECTORY: File is a directory.
/// @G_IO_ERROR_NOT_DIRECTORY: File is not a directory.
/// @G_IO_ERROR_NOT_EMPTY: File is a directory that isn't empty.
/// @G_IO_ERROR_NOT_REGULAR_FILE: File is not a regular file.
/// @G_IO_ERROR_NOT_SYMBOLIC_LINK: File is not a symbolic link.
/// @G_IO_ERROR_NOT_MOUNTABLE_FILE: File cannot be mounted.
/// @G_IO_ERROR_FILENAME_TOO_LONG: Filename is too many characters.
/// @G_IO_ERROR_INVALID_FILENAME: Filename is invalid or contains invalid characters.
/// @G_IO_ERROR_TOO_MANY_LINKS: File contains too many symbolic links.
/// @G_IO_ERROR_NO_SPACE: No space left on drive.
/// @G_IO_ERROR_INVALID_ARGUMENT: Invalid argument.
/// @G_IO_ERROR_PERMISSION_DENIED: Permission denied.
/// @G_IO_ERROR_NOT_SUPPORTED: Operation (or one of its parameters) not supported
/// @G_IO_ERROR_NOT_MOUNTED: File isn't mounted.
/// @G_IO_ERROR_ALREADY_MOUNTED: File is already mounted.
/// @G_IO_ERROR_CLOSED: File was closed.
/// @G_IO_ERROR_CANCELLED: Operation was cancelled. See #GCancellable.
/// @G_IO_ERROR_PENDING: Operations are still pending.
/// @G_IO_ERROR_READ_ONLY: File is read only.
/// @G_IO_ERROR_CANT_CREATE_BACKUP: Backup couldn't be created.
/// @G_IO_ERROR_WRONG_ETAG: File's Entity Tag was incorrect.
/// @G_IO_ERROR_TIMED_OUT: Operation timed out.
/// @G_IO_ERROR_WOULD_RECURSE: Operation would be recursive.
/// @G_IO_ERROR_BUSY: File is busy.
/// @G_IO_ERROR_WOULD_BLOCK: Operation would block.
/// @G_IO_ERROR_HOST_NOT_FOUND: Host couldn't be found (remote operations).
/// @G_IO_ERROR_WOULD_MERGE: Operation would merge files.
/// @G_IO_ERROR_FAILED_HANDLED: Operation failed and a helper program has
/// already interacted with the user. Do not display any error dialog.
/// @G_IO_ERROR_TOO_MANY_OPEN_FILES: The current process has too many files
/// open and can't open any more. Duplicate descriptors do count toward
/// this limit. Since 2.20
/// @G_IO_ERROR_NOT_INITIALIZED: The object has not been initialized. Since 2.22
/// @G_IO_ERROR_ADDRESS_IN_USE: The requested address is already in use. Since 2.22
/// @G_IO_ERROR_PARTIAL_INPUT: Need more input to finish operation. Since 2.24
/// @G_IO_ERROR_INVALID_DATA: The input data was invalid. Since 2.24
/// @G_IO_ERROR_DBUS_ERROR: A remote object generated an error that
/// doesn't correspond to a locally registered #GError error
/// domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
/// error name and g_dbus_error_strip_remote_error() to fix up the
/// message so it matches what was received on the wire. Since 2.26.
/// @G_IO_ERROR_HOST_UNREACHABLE: Host unreachable. Since 2.26
/// @G_IO_ERROR_NETWORK_UNREACHABLE: Network unreachable. Since 2.26
/// @G_IO_ERROR_CONNECTION_REFUSED: Connection refused. Since 2.26
/// @G_IO_ERROR_PROXY_FAILED: Connection to proxy server failed. Since 2.26
/// @G_IO_ERROR_PROXY_AUTH_FAILED: Proxy authentication failed. Since 2.26
/// @G_IO_ERROR_PROXY_NEED_AUTH: Proxy server needs authentication. Since 2.26
/// @G_IO_ERROR_PROXY_NOT_ALLOWED: Proxy connection is not allowed by ruleset.
/// Since 2.26
/// @G_IO_ERROR_BROKEN_PIPE: Broken pipe. Since 2.36
/// @G_IO_ERROR_CONNECTION_CLOSED: Connection closed by peer. Note that this
/// is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
/// "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
/// returned %G_IO_ERROR_FAILED. Now they should all return the same
/// value, which has this more logical name. Since 2.44.
/// @G_IO_ERROR_NOT_CONNECTED: Transport endpoint is not connected. Since 2.44
/// @G_IO_ERROR_MESSAGE_TOO_LARGE: Message too large. Since 2.48.
///
/// Error codes returned by GIO functions.
///
/// Note that this domain may be extended in future GLib releases. In
/// general, new error codes either only apply to new APIs, or else
/// replace %G_IO_ERROR_FAILED in cases that were not explicitly
/// distinguished before. You should therefore avoid writing code like
/// |[<!-- language="C" -->
/// if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
/// {
/// // Assume that this is EPRINTERONFIRE
/// ...
/// }
/// ]|
/// but should instead treat all unrecognized error codes the same as
/// %G_IO_ERROR_FAILED.
///
/// See also #GPollableReturn for a cheaper way of returning
/// %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError.
abstract class GIOErrorEnum {
  static const int G_IO_ERROR_FAILED = 0;
  static const int G_IO_ERROR_NOT_FOUND = 1;
  static const int G_IO_ERROR_EXISTS = 2;
  static const int G_IO_ERROR_IS_DIRECTORY = 3;
  static const int G_IO_ERROR_NOT_DIRECTORY = 4;
  static const int G_IO_ERROR_NOT_EMPTY = 5;
  static const int G_IO_ERROR_NOT_REGULAR_FILE = 6;
  static const int G_IO_ERROR_NOT_SYMBOLIC_LINK = 7;
  static const int G_IO_ERROR_NOT_MOUNTABLE_FILE = 8;
  static const int G_IO_ERROR_FILENAME_TOO_LONG = 9;
  static const int G_IO_ERROR_INVALID_FILENAME = 10;
  static const int G_IO_ERROR_TOO_MANY_LINKS = 11;
  static const int G_IO_ERROR_NO_SPACE = 12;
  static const int G_IO_ERROR_INVALID_ARGUMENT = 13;
  static const int G_IO_ERROR_PERMISSION_DENIED = 14;
  static const int G_IO_ERROR_NOT_SUPPORTED = 15;
  static const int G_IO_ERROR_NOT_MOUNTED = 16;
  static const int G_IO_ERROR_ALREADY_MOUNTED = 17;
  static const int G_IO_ERROR_CLOSED = 18;
  static const int G_IO_ERROR_CANCELLED = 19;
  static const int G_IO_ERROR_PENDING = 20;
  static const int G_IO_ERROR_READ_ONLY = 21;
  static const int G_IO_ERROR_CANT_CREATE_BACKUP = 22;
  static const int G_IO_ERROR_WRONG_ETAG = 23;
  static const int G_IO_ERROR_TIMED_OUT = 24;
  static const int G_IO_ERROR_WOULD_RECURSE = 25;
  static const int G_IO_ERROR_BUSY = 26;
  static const int G_IO_ERROR_WOULD_BLOCK = 27;
  static const int G_IO_ERROR_HOST_NOT_FOUND = 28;
  static const int G_IO_ERROR_WOULD_MERGE = 29;
  static const int G_IO_ERROR_FAILED_HANDLED = 30;
  static const int G_IO_ERROR_TOO_MANY_OPEN_FILES = 31;
  static const int G_IO_ERROR_NOT_INITIALIZED = 32;
  static const int G_IO_ERROR_ADDRESS_IN_USE = 33;
  static const int G_IO_ERROR_PARTIAL_INPUT = 34;
  static const int G_IO_ERROR_INVALID_DATA = 35;
  static const int G_IO_ERROR_DBUS_ERROR = 36;
  static const int G_IO_ERROR_HOST_UNREACHABLE = 37;
  static const int G_IO_ERROR_NETWORK_UNREACHABLE = 38;
  static const int G_IO_ERROR_CONNECTION_REFUSED = 39;
  static const int G_IO_ERROR_PROXY_FAILED = 40;
  static const int G_IO_ERROR_PROXY_AUTH_FAILED = 41;
  static const int G_IO_ERROR_PROXY_NEED_AUTH = 42;
  static const int G_IO_ERROR_PROXY_NOT_ALLOWED = 43;
  static const int G_IO_ERROR_BROKEN_PIPE = 44;
  static const int G_IO_ERROR_CONNECTION_CLOSED = 44;
  static const int G_IO_ERROR_NOT_CONNECTED = 45;
  static const int G_IO_ERROR_MESSAGE_TOO_LARGE = 46;
}

/// GAskPasswordFlags:
/// @G_ASK_PASSWORD_NEED_PASSWORD: operation requires a password.
/// @G_ASK_PASSWORD_NEED_USERNAME: operation requires a username.
/// @G_ASK_PASSWORD_NEED_DOMAIN: operation requires a domain.
/// @G_ASK_PASSWORD_SAVING_SUPPORTED: operation supports saving settings.
/// @G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: operation supports anonymous users.
/// @G_ASK_PASSWORD_TCRYPT: operation takes TCRYPT parameters (Since: 2.58)
///
/// #GAskPasswordFlags are used to request specific information from the
/// user, or to notify the user of their choices in an authentication
/// situation.
abstract class GAskPasswordFlags {
  static const int G_ASK_PASSWORD_NEED_PASSWORD = 1;
  static const int G_ASK_PASSWORD_NEED_USERNAME = 2;
  static const int G_ASK_PASSWORD_NEED_DOMAIN = 4;
  static const int G_ASK_PASSWORD_SAVING_SUPPORTED = 8;
  static const int G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 16;
  static const int G_ASK_PASSWORD_TCRYPT = 32;
}

/// GPasswordSave:
/// @G_PASSWORD_SAVE_NEVER: never save a password.
/// @G_PASSWORD_SAVE_FOR_SESSION: save a password for the session.
/// @G_PASSWORD_SAVE_PERMANENTLY: save a password permanently.
///
/// #GPasswordSave is used to indicate the lifespan of a saved password.
///
/// #Gvfs stores passwords in the Gnome keyring when this flag allows it
/// to, and later retrieves it again from there.
abstract class GPasswordSave {
  static const int G_PASSWORD_SAVE_NEVER = 0;
  static const int G_PASSWORD_SAVE_FOR_SESSION = 1;
  static const int G_PASSWORD_SAVE_PERMANENTLY = 2;
}

/// GMountOperationResult:
/// @G_MOUNT_OPERATION_HANDLED: The request was fulfilled and the
/// user specified data is now available
/// @G_MOUNT_OPERATION_ABORTED: The user requested the mount operation
/// to be aborted
/// @G_MOUNT_OPERATION_UNHANDLED: The request was unhandled (i.e. not
/// implemented)
///
/// #GMountOperationResult is returned as a result when a request for
/// information is send by the mounting operation.
abstract class GMountOperationResult {
  static const int G_MOUNT_OPERATION_HANDLED = 0;
  static const int G_MOUNT_OPERATION_ABORTED = 1;
  static const int G_MOUNT_OPERATION_UNHANDLED = 2;
}

/// GOutputStreamSpliceFlags:
/// @G_OUTPUT_STREAM_SPLICE_NONE: Do not close either stream.
/// @G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: Close the source stream after
/// the splice.
/// @G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: Close the target stream after
/// the splice.
///
/// GOutputStreamSpliceFlags determine how streams should be spliced.
abstract class GOutputStreamSpliceFlags {
  static const int G_OUTPUT_STREAM_SPLICE_NONE = 0;
  static const int G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 1;
  static const int G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 2;
}

/// GIOStreamSpliceFlags:
/// @G_IO_STREAM_SPLICE_NONE: Do not close either stream.
/// @G_IO_STREAM_SPLICE_CLOSE_STREAM1: Close the first stream after
/// the splice.
/// @G_IO_STREAM_SPLICE_CLOSE_STREAM2: Close the second stream after
/// the splice.
/// @G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: Wait for both splice operations to finish
/// before calling the callback.
///
/// GIOStreamSpliceFlags determine how streams should be spliced.
///
/// Since: 2.28
abstract class GIOStreamSpliceFlags {
  static const int G_IO_STREAM_SPLICE_NONE = 0;
  static const int G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 1;
  static const int G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 2;
  static const int G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 4;
}

/// GEmblemOrigin:
/// @G_EMBLEM_ORIGIN_UNKNOWN: Emblem of unknown origin
/// @G_EMBLEM_ORIGIN_DEVICE: Emblem adds device-specific information
/// @G_EMBLEM_ORIGIN_LIVEMETADATA: Emblem depicts live metadata, such as "readonly"
/// @G_EMBLEM_ORIGIN_TAG: Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
///
/// GEmblemOrigin is used to add information about the origin of the emblem
/// to #GEmblem.
///
/// Since: 2.18
abstract class GEmblemOrigin {
  static const int G_EMBLEM_ORIGIN_UNKNOWN = 0;
  static const int G_EMBLEM_ORIGIN_DEVICE = 1;
  static const int G_EMBLEM_ORIGIN_LIVEMETADATA = 2;
  static const int G_EMBLEM_ORIGIN_TAG = 3;
}

/// GResolverError:
/// @G_RESOLVER_ERROR_NOT_FOUND: the requested name/address/service was not
/// found
/// @G_RESOLVER_ERROR_TEMPORARY_FAILURE: the requested information could not
/// be looked up due to a network error or similar problem
/// @G_RESOLVER_ERROR_INTERNAL: unknown error
///
/// An error code used with %G_RESOLVER_ERROR in a #GError returned
/// from a #GResolver routine.
///
/// Since: 2.22
abstract class GResolverError {
  static const int G_RESOLVER_ERROR_NOT_FOUND = 0;
  static const int G_RESOLVER_ERROR_TEMPORARY_FAILURE = 1;
  static const int G_RESOLVER_ERROR_INTERNAL = 2;
}

/// GResolverRecordType:
/// @G_RESOLVER_RECORD_SRV: look up DNS SRV records for a domain
/// @G_RESOLVER_RECORD_MX: look up DNS MX records for a domain
/// @G_RESOLVER_RECORD_TXT: look up DNS TXT records for a name
/// @G_RESOLVER_RECORD_SOA: look up DNS SOA records for a zone
/// @G_RESOLVER_RECORD_NS: look up DNS NS records for a domain
///
/// The type of record that g_resolver_lookup_records() or
/// g_resolver_lookup_records_async() should retrieve. The records are returned
/// as lists of #GVariant tuples. Each record type has different values in
/// the variant tuples returned.
///
/// %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
/// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
/// weight, a `guint16` with the port, and a string of the hostname.
///
/// %G_RESOLVER_RECORD_MX records are returned as variants with the signature
/// `(qs)`, representing a `guint16` with the preference, and a string containing
/// the mail exchanger hostname.
///
/// %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
/// `(as)`, representing an array of the strings in the text record. Note: Most TXT
/// records only contain a single string, but
/// [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
/// record to contain multiple strings. The RFC which defines the interpretation
/// of a specific TXT record will likely require concatenation of multiple
/// strings if they are present, as with
/// [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
///
/// %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
/// `(ssuuuuu)`, representing a string containing the primary name server, a
/// string containing the administrator, the serial as a `guint32`, the refresh
/// interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
/// as a `guint32`, and the TTL as a `guint32`.
///
/// %G_RESOLVER_RECORD_NS records are returned as variants with the signature
/// `(s)`, representing a string of the hostname of the name server.
///
/// Since: 2.34
abstract class GResolverRecordType {
  static const int G_RESOLVER_RECORD_SRV = 1;
  static const int G_RESOLVER_RECORD_MX = 2;
  static const int G_RESOLVER_RECORD_TXT = 3;
  static const int G_RESOLVER_RECORD_SOA = 4;
  static const int G_RESOLVER_RECORD_NS = 5;
}

/// GResourceError:
/// @G_RESOURCE_ERROR_NOT_FOUND: no file was found at the requested path
/// @G_RESOURCE_ERROR_INTERNAL: unknown error
///
/// An error code used with %G_RESOURCE_ERROR in a #GError returned
/// from a #GResource routine.
///
/// Since: 2.32
abstract class GResourceError {
  static const int G_RESOURCE_ERROR_NOT_FOUND = 0;
  static const int G_RESOURCE_ERROR_INTERNAL = 1;
}

/// GResourceFlags:
/// @G_RESOURCE_FLAGS_NONE: No flags set.
/// @G_RESOURCE_FLAGS_COMPRESSED: The file is compressed.
///
/// GResourceFlags give information about a particular file inside a resource
/// bundle.
///
/// Since: 2.32
abstract class GResourceFlags {
  static const int G_RESOURCE_FLAGS_NONE = 0;
  static const int G_RESOURCE_FLAGS_COMPRESSED = 1;
}

/// GResourceLookupFlags:
/// @G_RESOURCE_LOOKUP_FLAGS_NONE: No flags set.
///
/// GResourceLookupFlags determine how resource path lookups are handled.
///
/// Since: 2.32
abstract class GResourceLookupFlags {
  static const int G_RESOURCE_LOOKUP_FLAGS_NONE = 0;
}

/// GSocketFamily:
/// @G_SOCKET_FAMILY_INVALID: no address family
/// @G_SOCKET_FAMILY_IPV4: the IPv4 family
/// @G_SOCKET_FAMILY_IPV6: the IPv6 family
/// @G_SOCKET_FAMILY_UNIX: the UNIX domain family
///
/// The protocol family of a #GSocketAddress. (These values are
/// identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
/// if available.)
///
/// Since: 2.22
abstract class GSocketFamily {
  static const int G_SOCKET_FAMILY_INVALID = 0;
  static const int G_SOCKET_FAMILY_UNIX = 1;
  static const int G_SOCKET_FAMILY_IPV4 = 2;
  static const int G_SOCKET_FAMILY_IPV6 = 10;
}

/// GSocketType:
/// @G_SOCKET_TYPE_INVALID: Type unknown or wrong
/// @G_SOCKET_TYPE_STREAM: Reliable connection-based byte streams (e.g. TCP).
/// @G_SOCKET_TYPE_DATAGRAM: Connectionless, unreliable datagram passing.
/// (e.g. UDP)
/// @G_SOCKET_TYPE_SEQPACKET: Reliable connection-based passing of datagrams
/// of fixed maximum length (e.g. SCTP).
///
/// Flags used when creating a #GSocket. Some protocols may not implement
/// all the socket types.
///
/// Since: 2.22
abstract class GSocketType {
  static const int G_SOCKET_TYPE_INVALID = 0;
  static const int G_SOCKET_TYPE_STREAM = 1;
  static const int G_SOCKET_TYPE_DATAGRAM = 2;
  static const int G_SOCKET_TYPE_SEQPACKET = 3;
}

/// GSocketMsgFlags:
/// @G_SOCKET_MSG_NONE: No flags.
/// @G_SOCKET_MSG_OOB: Request to send/receive out of band data.
/// @G_SOCKET_MSG_PEEK: Read data from the socket without removing it from
/// the queue.
/// @G_SOCKET_MSG_DONTROUTE: Don't use a gateway to send out the packet,
/// only send to hosts on directly connected networks.
///
/// Flags used in g_socket_receive_message() and g_socket_send_message().
/// The flags listed in the enum are some commonly available flags, but the
/// values used for them are the same as on the platform, and any other flags
/// are passed in/out as is. So to use a platform specific flag, just include
/// the right system header and pass in the flag.
///
/// Since: 2.22
abstract class GSocketMsgFlags {
  static const int G_SOCKET_MSG_NONE = 0;
  static const int G_SOCKET_MSG_OOB = 1;
  static const int G_SOCKET_MSG_PEEK = 2;
  static const int G_SOCKET_MSG_DONTROUTE = 4;
}

/// GSocketProtocol:
/// @G_SOCKET_PROTOCOL_UNKNOWN: The protocol type is unknown
/// @G_SOCKET_PROTOCOL_DEFAULT: The default protocol for the family/type
/// @G_SOCKET_PROTOCOL_TCP: TCP over IP
/// @G_SOCKET_PROTOCOL_UDP: UDP over IP
/// @G_SOCKET_PROTOCOL_SCTP: SCTP over IP
///
/// A protocol identifier is specified when creating a #GSocket, which is a
/// family/type specific identifier, where 0 means the default protocol for
/// the particular family/type.
///
/// This enum contains a set of commonly available and used protocols. You
/// can also pass any other identifiers handled by the platform in order to
/// use protocols not listed here.
///
/// Since: 2.22
abstract class GSocketProtocol {
  static const int G_SOCKET_PROTOCOL_UNKNOWN = -1;
  static const int G_SOCKET_PROTOCOL_DEFAULT = 0;
  static const int G_SOCKET_PROTOCOL_TCP = 6;
  static const int G_SOCKET_PROTOCOL_UDP = 17;
  static const int G_SOCKET_PROTOCOL_SCTP = 132;
}

/// GZlibCompressorFormat:
/// @G_ZLIB_COMPRESSOR_FORMAT_ZLIB: deflate compression with zlib header
/// @G_ZLIB_COMPRESSOR_FORMAT_GZIP: gzip file format
/// @G_ZLIB_COMPRESSOR_FORMAT_RAW: deflate compression with no header
///
/// Used to select the type of data format to use for #GZlibDecompressor
/// and #GZlibCompressor.
///
/// Since: 2.24
abstract class GZlibCompressorFormat {
  static const int G_ZLIB_COMPRESSOR_FORMAT_ZLIB = 0;
  static const int G_ZLIB_COMPRESSOR_FORMAT_GZIP = 1;
  static const int G_ZLIB_COMPRESSOR_FORMAT_RAW = 2;
}

/// GUnixSocketAddressType:
/// @G_UNIX_SOCKET_ADDRESS_INVALID: invalid
/// @G_UNIX_SOCKET_ADDRESS_ANONYMOUS: anonymous
/// @G_UNIX_SOCKET_ADDRESS_PATH: a filesystem path
/// @G_UNIX_SOCKET_ADDRESS_ABSTRACT: an abstract name
/// @G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: an abstract name, 0-padded
/// to the full length of a unix socket name
///
/// The type of name used by a #GUnixSocketAddress.
/// %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
/// socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
/// indicates a socket not bound to any name (eg, a client-side socket,
/// or a socket created with socketpair()).
///
/// For abstract sockets, there are two incompatible ways of naming
/// them; the man pages suggest using the entire `struct sockaddr_un`
/// as the name, padding the unused parts of the %sun_path field with
/// zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
/// However, many programs instead just use a portion of %sun_path, and
/// pass an appropriate smaller length to bind() or connect(). This is
/// %G_UNIX_SOCKET_ADDRESS_ABSTRACT.
///
/// Since: 2.26
abstract class GUnixSocketAddressType {
  static const int G_UNIX_SOCKET_ADDRESS_INVALID = 0;
  static const int G_UNIX_SOCKET_ADDRESS_ANONYMOUS = 1;
  static const int G_UNIX_SOCKET_ADDRESS_PATH = 2;
  static const int G_UNIX_SOCKET_ADDRESS_ABSTRACT = 3;
  static const int G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED = 4;
}

/// GBusType:
/// @G_BUS_TYPE_STARTER: An alias for the message bus that activated the process, if any.
/// @G_BUS_TYPE_NONE: Not a message bus.
/// @G_BUS_TYPE_SYSTEM: The system-wide message bus.
/// @G_BUS_TYPE_SESSION: The login session message bus.
///
/// An enumeration for well-known message buses.
///
/// Since: 2.26
abstract class GBusType {
  static const int G_BUS_TYPE_STARTER = -1;
  static const int G_BUS_TYPE_NONE = 0;
  static const int G_BUS_TYPE_SYSTEM = 1;
  static const int G_BUS_TYPE_SESSION = 2;
}

/// GBusNameOwnerFlags:
/// @G_BUS_NAME_OWNER_FLAGS_NONE: No flags set.
/// @G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: Allow another message bus connection to claim the name.
/// @G_BUS_NAME_OWNER_FLAGS_REPLACE: If another message bus connection owns the name and have
/// specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
/// @G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: If another message bus connection owns the name, immediately
/// return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)
///
/// Flags used in g_bus_own_name().
///
/// Since: 2.26
abstract class GBusNameOwnerFlags {
  static const int G_BUS_NAME_OWNER_FLAGS_NONE = 0;
  static const int G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 1;
  static const int G_BUS_NAME_OWNER_FLAGS_REPLACE = 2;
  static const int G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = 4;
}

/// GBusNameWatcherFlags:
/// @G_BUS_NAME_WATCHER_FLAGS_NONE: No flags set.
/// @G_BUS_NAME_WATCHER_FLAGS_AUTO_START: If no-one owns the name when
/// beginning to watch the name, ask the bus to launch an owner for the
/// name.
///
/// Flags used in g_bus_watch_name().
///
/// Since: 2.26
abstract class GBusNameWatcherFlags {
  static const int G_BUS_NAME_WATCHER_FLAGS_NONE = 0;
  static const int G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 1;
}

/// GDBusProxyFlags:
/// @G_DBUS_PROXY_FLAGS_NONE: No flags set.
/// @G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: Don't load properties.
/// @G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: Don't connect to signals on the remote object.
/// @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: If the proxy is for a well-known name,
/// do not ask the bus to launch an owner during proxy initialization or a method call.
/// This flag is only meaningful in proxies for well-known names.
/// @G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
/// @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: If the proxy is for a well-known name,
/// do not ask the bus to launch an owner during proxy initialization, but allow it to be
/// autostarted by a method call. This flag is only meaningful in proxies for well-known names,
/// and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
/// @G_DBUS_PROXY_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch D-Bus
/// call for this signal subscription. This gives you more control
/// over which match rules you add (but you must add them manually). (Since: 2.72)
///
/// Flags used when constructing an instance of a #GDBusProxy derived class.
///
/// Since: 2.26
abstract class GDBusProxyFlags {
  static const int G_DBUS_PROXY_FLAGS_NONE = 0;
  static const int G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1;
  static const int G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 2;
  static const int G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 4;
  static const int G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 8;
  static const int G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 16;
  static const int G_DBUS_PROXY_FLAGS_NO_MATCH_RULE = 32;
}

/// GDBusError:
/// @G_DBUS_ERROR_FAILED:
/// A generic error; "something went wrong" - see the error message for
/// more.
/// @G_DBUS_ERROR_NO_MEMORY:
/// There was not enough memory to complete an operation.
/// @G_DBUS_ERROR_SERVICE_UNKNOWN:
/// The bus doesn't know how to launch a service to supply the bus name
/// you wanted.
/// @G_DBUS_ERROR_NAME_HAS_NO_OWNER:
/// The bus name you referenced doesn't exist (i.e. no application owns
/// it).
/// @G_DBUS_ERROR_NO_REPLY:
/// No reply to a message expecting one, usually means a timeout occurred.
/// @G_DBUS_ERROR_IO_ERROR:
/// Something went wrong reading or writing to a socket, for example.
/// @G_DBUS_ERROR_BAD_ADDRESS:
/// A D-Bus bus address was malformed.
/// @G_DBUS_ERROR_NOT_SUPPORTED:
/// Requested operation isn't supported (like ENOSYS on UNIX).
/// @G_DBUS_ERROR_LIMITS_EXCEEDED:
/// Some limited resource is exhausted.
/// @G_DBUS_ERROR_ACCESS_DENIED:
/// Security restrictions don't allow doing what you're trying to do.
/// @G_DBUS_ERROR_AUTH_FAILED:
/// Authentication didn't work.
/// @G_DBUS_ERROR_NO_SERVER:
/// Unable to connect to server (probably caused by ECONNREFUSED on a
/// socket).
/// @G_DBUS_ERROR_TIMEOUT:
/// Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
/// %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
/// this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
/// exists. We can't fix it for compatibility reasons so just be
/// careful.
/// @G_DBUS_ERROR_NO_NETWORK:
/// No network access (probably ENETUNREACH on a socket).
/// @G_DBUS_ERROR_ADDRESS_IN_USE:
/// Can't bind a socket since its address is in use (i.e. EADDRINUSE).
/// @G_DBUS_ERROR_DISCONNECTED:
/// The connection is disconnected and you're trying to use it.
/// @G_DBUS_ERROR_INVALID_ARGS:
/// Invalid arguments passed to a method call.
/// @G_DBUS_ERROR_FILE_NOT_FOUND:
/// Missing file.
/// @G_DBUS_ERROR_FILE_EXISTS:
/// Existing file and the operation you're using does not silently overwrite.
/// @G_DBUS_ERROR_UNKNOWN_METHOD:
/// Method name you invoked isn't known by the object you invoked it on.
/// @G_DBUS_ERROR_UNKNOWN_OBJECT:
/// Object you invoked a method on isn't known. Since 2.42
/// @G_DBUS_ERROR_UNKNOWN_INTERFACE:
/// Interface you invoked a method on isn't known by the object. Since 2.42
/// @G_DBUS_ERROR_UNKNOWN_PROPERTY:
/// Property you tried to access isn't known by the object. Since 2.42
/// @G_DBUS_ERROR_PROPERTY_READ_ONLY:
/// Property you tried to set is read-only. Since 2.42
/// @G_DBUS_ERROR_TIMED_OUT:
/// Certain timeout errors, e.g. while starting a service. Warning: this is
/// confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
/// can't fix it for compatibility reasons so just be careful.
/// @G_DBUS_ERROR_MATCH_RULE_NOT_FOUND:
/// Tried to remove or modify a match rule that didn't exist.
/// @G_DBUS_ERROR_MATCH_RULE_INVALID:
/// The match rule isn't syntactically valid.
/// @G_DBUS_ERROR_SPAWN_EXEC_FAILED:
/// While starting a new process, the exec() call failed.
/// @G_DBUS_ERROR_SPAWN_FORK_FAILED:
/// While starting a new process, the fork() call failed.
/// @G_DBUS_ERROR_SPAWN_CHILD_EXITED:
/// While starting a new process, the child exited with a status code.
/// @G_DBUS_ERROR_SPAWN_CHILD_SIGNALED:
/// While starting a new process, the child exited on a signal.
/// @G_DBUS_ERROR_SPAWN_FAILED:
/// While starting a new process, something went wrong.
/// @G_DBUS_ERROR_SPAWN_SETUP_FAILED:
/// We failed to setup the environment correctly.
/// @G_DBUS_ERROR_SPAWN_CONFIG_INVALID:
/// We failed to setup the config parser correctly.
/// @G_DBUS_ERROR_SPAWN_SERVICE_INVALID:
/// Bus name was not valid.
/// @G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND:
/// Service file not found in system-services directory.
/// @G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID:
/// Permissions are incorrect on the setuid helper.
/// @G_DBUS_ERROR_SPAWN_FILE_INVALID:
/// Service file invalid (Name, User or Exec missing).
/// @G_DBUS_ERROR_SPAWN_NO_MEMORY:
/// Tried to get a UNIX process ID and it wasn't available.
/// @G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN:
/// Tried to get a UNIX process ID and it wasn't available.
/// @G_DBUS_ERROR_INVALID_SIGNATURE:
/// A type signature is not valid.
/// @G_DBUS_ERROR_INVALID_FILE_CONTENT:
/// A file contains invalid syntax or is otherwise broken.
/// @G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
/// Asked for SELinux security context and it wasn't available.
/// @G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN:
/// Asked for ADT audit data and it wasn't available.
/// @G_DBUS_ERROR_OBJECT_PATH_IN_USE:
/// There's already an object with the requested object path.
///
/// Error codes for the %G_DBUS_ERROR error domain.
///
/// Since: 2.26
abstract class GDBusError {
  static const int G_DBUS_ERROR_FAILED = 0;
  static const int G_DBUS_ERROR_NO_MEMORY = 1;
  static const int G_DBUS_ERROR_SERVICE_UNKNOWN = 2;
  static const int G_DBUS_ERROR_NAME_HAS_NO_OWNER = 3;
  static const int G_DBUS_ERROR_NO_REPLY = 4;
  static const int G_DBUS_ERROR_IO_ERROR = 5;
  static const int G_DBUS_ERROR_BAD_ADDRESS = 6;
  static const int G_DBUS_ERROR_NOT_SUPPORTED = 7;
  static const int G_DBUS_ERROR_LIMITS_EXCEEDED = 8;
  static const int G_DBUS_ERROR_ACCESS_DENIED = 9;
  static const int G_DBUS_ERROR_AUTH_FAILED = 10;
  static const int G_DBUS_ERROR_NO_SERVER = 11;
  static const int G_DBUS_ERROR_TIMEOUT = 12;
  static const int G_DBUS_ERROR_NO_NETWORK = 13;
  static const int G_DBUS_ERROR_ADDRESS_IN_USE = 14;
  static const int G_DBUS_ERROR_DISCONNECTED = 15;
  static const int G_DBUS_ERROR_INVALID_ARGS = 16;
  static const int G_DBUS_ERROR_FILE_NOT_FOUND = 17;
  static const int G_DBUS_ERROR_FILE_EXISTS = 18;
  static const int G_DBUS_ERROR_UNKNOWN_METHOD = 19;
  static const int G_DBUS_ERROR_TIMED_OUT = 20;
  static const int G_DBUS_ERROR_MATCH_RULE_NOT_FOUND = 21;
  static const int G_DBUS_ERROR_MATCH_RULE_INVALID = 22;
  static const int G_DBUS_ERROR_SPAWN_EXEC_FAILED = 23;
  static const int G_DBUS_ERROR_SPAWN_FORK_FAILED = 24;
  static const int G_DBUS_ERROR_SPAWN_CHILD_EXITED = 25;
  static const int G_DBUS_ERROR_SPAWN_CHILD_SIGNALED = 26;
  static const int G_DBUS_ERROR_SPAWN_FAILED = 27;
  static const int G_DBUS_ERROR_SPAWN_SETUP_FAILED = 28;
  static const int G_DBUS_ERROR_SPAWN_CONFIG_INVALID = 29;
  static const int G_DBUS_ERROR_SPAWN_SERVICE_INVALID = 30;
  static const int G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND = 31;
  static const int G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID = 32;
  static const int G_DBUS_ERROR_SPAWN_FILE_INVALID = 33;
  static const int G_DBUS_ERROR_SPAWN_NO_MEMORY = 34;
  static const int G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN = 35;
  static const int G_DBUS_ERROR_INVALID_SIGNATURE = 36;
  static const int G_DBUS_ERROR_INVALID_FILE_CONTENT = 37;
  static const int G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN = 38;
  static const int G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN = 39;
  static const int G_DBUS_ERROR_OBJECT_PATH_IN_USE = 40;
  static const int G_DBUS_ERROR_UNKNOWN_OBJECT = 41;
  static const int G_DBUS_ERROR_UNKNOWN_INTERFACE = 42;
  static const int G_DBUS_ERROR_UNKNOWN_PROPERTY = 43;
  static const int G_DBUS_ERROR_PROPERTY_READ_ONLY = 44;
}

/// GDBusConnectionFlags:
/// @G_DBUS_CONNECTION_FLAGS_NONE: No flags set.
/// @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: Perform authentication against server.
/// @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: Perform authentication against client.
/// @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: When
/// authenticating as a server, allow the anonymous authentication
/// method.
/// @G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION: Pass this flag if connecting to a peer that is a
/// message bus. This means that the Hello() method will be invoked as part of the connection setup.
/// @G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING: If set, processing of D-Bus messages is
/// delayed until g_dbus_connection_start_message_processing() is called.
/// @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: When authenticating
/// as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)
///
/// Flags used when creating a new #GDBusConnection.
///
/// Since: 2.26
abstract class GDBusConnectionFlags {
  static const int G_DBUS_CONNECTION_FLAGS_NONE = 0;
  static const int G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 1;
  static const int G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 2;
  static const int G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 4;
  static const int G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 8;
  static const int G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 16;
  static const int G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER =
      32;
}

/// GDBusCapabilityFlags:
/// @G_DBUS_CAPABILITY_FLAGS_NONE: No flags set.
/// @G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: The connection
/// supports exchanging UNIX file descriptors with the remote peer.
///
/// Capabilities negotiated with the remote peer.
///
/// Since: 2.26
abstract class GDBusCapabilityFlags {
  static const int G_DBUS_CAPABILITY_FLAGS_NONE = 0;
  static const int G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 1;
}

/// GDBusCallFlags:
/// @G_DBUS_CALL_FLAGS_NONE: No flags set.
/// @G_DBUS_CALL_FLAGS_NO_AUTO_START: The bus must not launch
/// an owner for the destination name in response to this method
/// invocation.
/// @G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: the caller is prepared to
/// wait for interactive authorization. Since 2.46.
///
/// Flags used in g_dbus_connection_call() and similar APIs.
///
/// Since: 2.26
abstract class GDBusCallFlags {
  static const int G_DBUS_CALL_FLAGS_NONE = 0;
  static const int G_DBUS_CALL_FLAGS_NO_AUTO_START = 1;
  static const int G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2;
}

/// GDBusMessageType:
/// @G_DBUS_MESSAGE_TYPE_INVALID: Message is of invalid type.
/// @G_DBUS_MESSAGE_TYPE_METHOD_CALL: Method call.
/// @G_DBUS_MESSAGE_TYPE_METHOD_RETURN: Method reply.
/// @G_DBUS_MESSAGE_TYPE_ERROR: Error reply.
/// @G_DBUS_MESSAGE_TYPE_SIGNAL: Signal emission.
///
/// Message types used in #GDBusMessage.
///
/// Since: 2.26
abstract class GDBusMessageType {
  static const int G_DBUS_MESSAGE_TYPE_INVALID = 0;
  static const int G_DBUS_MESSAGE_TYPE_METHOD_CALL = 1;
  static const int G_DBUS_MESSAGE_TYPE_METHOD_RETURN = 2;
  static const int G_DBUS_MESSAGE_TYPE_ERROR = 3;
  static const int G_DBUS_MESSAGE_TYPE_SIGNAL = 4;
}

/// GDBusMessageFlags:
/// @G_DBUS_MESSAGE_FLAGS_NONE: No flags set.
/// @G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: A reply is not expected.
/// @G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: The bus must not launch an
/// owner for the destination name in response to this message.
/// @G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: If set on a method
/// call, this flag means that the caller is prepared to wait for interactive
/// authorization. Since 2.46.
///
/// Message flags used in #GDBusMessage.
///
/// Since: 2.26
abstract class GDBusMessageFlags {
  static const int G_DBUS_MESSAGE_FLAGS_NONE = 0;
  static const int G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 1;
  static const int G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 2;
  static const int G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 4;
}

/// GDBusMessageHeaderField:
/// @G_DBUS_MESSAGE_HEADER_FIELD_INVALID: Not a valid header field.
/// @G_DBUS_MESSAGE_HEADER_FIELD_PATH: The object path.
/// @G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: The interface name.
/// @G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: The method or signal name.
/// @G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: The name of the error that occurred.
/// @G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL: The serial number the message is a reply to.
/// @G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: The name the message is intended for.
/// @G_DBUS_MESSAGE_HEADER_FIELD_SENDER: Unique name of the sender of the message (filled in by the bus).
/// @G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: The signature of the message body.
/// @G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS: The number of UNIX file descriptors that accompany the message.
///
/// Header fields used in #GDBusMessage.
///
/// Since: 2.26
abstract class GDBusMessageHeaderField {
  static const int G_DBUS_MESSAGE_HEADER_FIELD_INVALID = 0;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_PATH = 1;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE = 2;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_MEMBER = 3;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME = 4;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL = 5;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION = 6;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_SENDER = 7;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE = 8;
  static const int G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS = 9;
}

/// GDBusPropertyInfoFlags:
/// @G_DBUS_PROPERTY_INFO_FLAGS_NONE: No flags set.
/// @G_DBUS_PROPERTY_INFO_FLAGS_READABLE: Property is readable.
/// @G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: Property is writable.
///
/// Flags describing the access control of a D-Bus property.
///
/// Since: 2.26
abstract class GDBusPropertyInfoFlags {
  static const int G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0;
  static const int G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 1;
  static const int G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 2;
}

/// GDBusSubtreeFlags:
/// @G_DBUS_SUBTREE_FLAGS_NONE: No flags set.
/// @G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: Method calls to objects not in the enumerated range
/// will still be dispatched. This is useful if you want
/// to dynamically spawn objects in the subtree.
///
/// Flags passed to g_dbus_connection_register_subtree().
///
/// Since: 2.26
abstract class GDBusSubtreeFlags {
  static const int G_DBUS_SUBTREE_FLAGS_NONE = 0;
  static const int G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 1;
}

/// GDBusServerFlags:
/// @G_DBUS_SERVER_FLAGS_NONE: No flags set.
/// @G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: All #GDBusServer::new-connection
/// signals will run in separated dedicated threads (see signal for
/// details).
/// @G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: Allow the anonymous
/// authentication method.
/// @G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: Require the UID of the
/// peer to be the same as the UID of the server when authenticating. (Since: 2.68)
///
/// Flags used when creating a #GDBusServer.
///
/// Since: 2.26
abstract class GDBusServerFlags {
  static const int G_DBUS_SERVER_FLAGS_NONE = 0;
  static const int G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 1;
  static const int G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2;
  static const int G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 4;
}

/// GDBusSignalFlags:
/// @G_DBUS_SIGNAL_FLAGS_NONE: No flags set.
/// @G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch
/// D-Bus call for this signal subscription.  This gives you more control
/// over which match rules you add (but you must add them manually).
/// @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: Match first arguments that
/// contain a bus or interface name with the given namespace.
/// @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: Match first arguments that
/// contain an object path that is either equivalent to the given path,
/// or one of the paths is a subpath of the other.
///
/// Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().
///
/// Since: 2.26
abstract class GDBusSignalFlags {
  static const int G_DBUS_SIGNAL_FLAGS_NONE = 0;
  static const int G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 1;
  static const int G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 2;
  static const int G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 4;
}

/// GDBusSendMessageFlags:
/// @G_DBUS_SEND_MESSAGE_FLAGS_NONE: No flags set.
/// @G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: Do not automatically
/// assign a serial number from the #GDBusConnection object when
/// sending a message.
///
/// Flags used when sending #GDBusMessages on a #GDBusConnection.
///
/// Since: 2.26
abstract class GDBusSendMessageFlags {
  static const int G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0;
  static const int G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 1;
}

/// GCredentialsType:
/// @G_CREDENTIALS_TYPE_INVALID: Indicates an invalid native credential type.
/// @G_CREDENTIALS_TYPE_LINUX_UCRED: The native credentials type is a `struct ucred`.
/// @G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: The native credentials type is a `struct cmsgcred`.
/// @G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: The native credentials type is a `struct sockpeercred`. Added in 2.30.
/// @G_CREDENTIALS_TYPE_SOLARIS_UCRED: The native credentials type is a `ucred_t`. Added in 2.40.
/// @G_CREDENTIALS_TYPE_NETBSD_UNPCBID: The native credentials type is a `struct unpcbid`. Added in 2.42.
/// @G_CREDENTIALS_TYPE_APPLE_XUCRED: The native credentials type is a `struct xucred`. Added in 2.66.
/// @G_CREDENTIALS_TYPE_WIN32_PID: The native credentials type is a PID `DWORD`. Added in 2.72.
///
/// Enumeration describing different kinds of native credential types.
///
/// Since: 2.26
abstract class GCredentialsType {
  static const int G_CREDENTIALS_TYPE_INVALID = 0;
  static const int G_CREDENTIALS_TYPE_LINUX_UCRED = 1;
  static const int G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED = 2;
  static const int G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED = 3;
  static const int G_CREDENTIALS_TYPE_SOLARIS_UCRED = 4;
  static const int G_CREDENTIALS_TYPE_NETBSD_UNPCBID = 5;
  static const int G_CREDENTIALS_TYPE_APPLE_XUCRED = 6;
  static const int G_CREDENTIALS_TYPE_WIN32_PID = 7;
}

/// GDBusMessageByteOrder:
/// @G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: The byte order is big endian.
/// @G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: The byte order is little endian.
///
/// Enumeration used to describe the byte order of a D-Bus message.
///
/// Since: 2.26
abstract class GDBusMessageByteOrder {
  static const int G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN = 66;
  static const int G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 108;
}

/// GApplicationFlags:
/// @G_APPLICATION_FLAGS_NONE: Default
/// @G_APPLICATION_IS_SERVICE: Run as a service. In this mode, registration
/// fails if the service is already running, and the application
/// will initially wait up to 10 seconds for an initial activation
/// message to arrive.
/// @G_APPLICATION_IS_LAUNCHER: Don't try to become the primary instance.
/// @G_APPLICATION_HANDLES_OPEN: This application handles opening files (in
/// the primary instance). Note that this flag only affects the default
/// implementation of local_command_line(), and has no effect if
/// %G_APPLICATION_HANDLES_COMMAND_LINE is given.
/// See g_application_run() for details.
/// @G_APPLICATION_HANDLES_COMMAND_LINE: This application handles command line
/// arguments (in the primary instance). Note that this flag only affect
/// the default implementation of local_command_line().
/// See g_application_run() for details.
/// @G_APPLICATION_SEND_ENVIRONMENT: Send the environment of the
/// launching process to the primary instance. Set this flag if your
/// application is expected to behave differently depending on certain
/// environment variables. For instance, an editor might be expected
/// to use the `GIT_COMMITTER_NAME` environment variable
/// when editing a git commit message. The environment is available
/// to the #GApplication::command-line signal handler, via
/// g_application_command_line_getenv().
/// @G_APPLICATION_NON_UNIQUE: Make no attempts to do any of the typical
/// single-instance application negotiation, even if the application
/// ID is given.  The application neither attempts to become the
/// owner of the application ID nor does it check if an existing
/// owner already exists.  Everything occurs in the local process.
/// Since: 2.30.
/// @G_APPLICATION_CAN_OVERRIDE_APP_ID: Allow users to override the
/// application ID from the command line with `--gapplication-app-id`.
/// Since: 2.48
/// @G_APPLICATION_ALLOW_REPLACEMENT: Allow another instance to take over
/// the bus name. Since: 2.60
/// @G_APPLICATION_REPLACE: Take over from another instance. This flag is
/// usually set by passing `--gapplication-replace` on the commandline.
/// Since: 2.60
///
/// Flags used to define the behaviour of a #GApplication.
///
/// Since: 2.28
abstract class GApplicationFlags {
  static const int G_APPLICATION_FLAGS_NONE = 0;
  static const int G_APPLICATION_IS_SERVICE = 1;
  static const int G_APPLICATION_IS_LAUNCHER = 2;
  static const int G_APPLICATION_HANDLES_OPEN = 4;
  static const int G_APPLICATION_HANDLES_COMMAND_LINE = 8;
  static const int G_APPLICATION_SEND_ENVIRONMENT = 16;
  static const int G_APPLICATION_NON_UNIQUE = 32;
  static const int G_APPLICATION_CAN_OVERRIDE_APP_ID = 64;
  static const int G_APPLICATION_ALLOW_REPLACEMENT = 128;
  static const int G_APPLICATION_REPLACE = 256;
}

/// GTlsError:
/// @G_TLS_ERROR_UNAVAILABLE: No TLS provider is available
/// @G_TLS_ERROR_MISC: Miscellaneous TLS error
/// @G_TLS_ERROR_BAD_CERTIFICATE: The certificate presented could not
/// be parsed or failed validation.
/// @G_TLS_ERROR_NOT_TLS: The TLS handshake failed because the
/// peer does not seem to be a TLS server.
/// @G_TLS_ERROR_HANDSHAKE: The TLS handshake failed because the
/// peer's certificate was not acceptable.
/// @G_TLS_ERROR_CERTIFICATE_REQUIRED: The TLS handshake failed because
/// the server requested a client-side certificate, but none was
/// provided. See g_tls_connection_set_certificate().
/// @G_TLS_ERROR_EOF: The TLS connection was closed without proper
/// notice, which may indicate an attack. See
/// g_tls_connection_set_require_close_notify().
/// @G_TLS_ERROR_INAPPROPRIATE_FALLBACK: The TLS handshake failed
/// because the client sent the fallback SCSV, indicating a protocol
/// downgrade attack. Since: 2.60
/// @G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: The certificate failed
/// to load because a password was incorrect. Since: 2.72
///
/// An error code used with %G_TLS_ERROR in a #GError returned from a
/// TLS-related routine.
///
/// Since: 2.28
abstract class GTlsError {
  static const int G_TLS_ERROR_UNAVAILABLE = 0;
  static const int G_TLS_ERROR_MISC = 1;
  static const int G_TLS_ERROR_BAD_CERTIFICATE = 2;
  static const int G_TLS_ERROR_NOT_TLS = 3;
  static const int G_TLS_ERROR_HANDSHAKE = 4;
  static const int G_TLS_ERROR_CERTIFICATE_REQUIRED = 5;
  static const int G_TLS_ERROR_EOF = 6;
  static const int G_TLS_ERROR_INAPPROPRIATE_FALLBACK = 7;
  static const int G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD = 8;
}

/// GTlsCertificateFlags:
/// @G_TLS_CERTIFICATE_UNKNOWN_CA: The signing certificate authority is
/// not known.
/// @G_TLS_CERTIFICATE_BAD_IDENTITY: The certificate does not match the
/// expected identity of the site that it was retrieved from.
/// @G_TLS_CERTIFICATE_NOT_ACTIVATED: The certificate's activation time
/// is still in the future
/// @G_TLS_CERTIFICATE_EXPIRED: The certificate has expired
/// @G_TLS_CERTIFICATE_REVOKED: The certificate has been revoked
/// according to the #GTlsConnection's certificate revocation list.
/// @G_TLS_CERTIFICATE_INSECURE: The certificate's algorithm is
/// considered insecure.
/// @G_TLS_CERTIFICATE_GENERIC_ERROR: Some other error occurred validating
/// the certificate
/// @G_TLS_CERTIFICATE_VALIDATE_ALL: the combination of all of the above
/// flags
///
/// A set of flags describing TLS certification validation. This can be
/// used to describe why a particular certificate was rejected (for
/// example, in #GTlsConnection::accept-certificate).
///
/// GLib guarantees that if certificate verification fails, at least one
/// flag will be set, but it does not guarantee that all possible flags
/// will be set. Accordingly, you may not safely decide to ignore any
/// particular type of error. For example, it would be incorrect to mask
/// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
/// because this could potentially be the only error flag set even if
/// other problems exist with the certificate.
///
/// Since: 2.28
abstract class GTlsCertificateFlags {
  static const int G_TLS_CERTIFICATE_UNKNOWN_CA = 1;
  static const int G_TLS_CERTIFICATE_BAD_IDENTITY = 2;
  static const int G_TLS_CERTIFICATE_NOT_ACTIVATED = 4;
  static const int G_TLS_CERTIFICATE_EXPIRED = 8;
  static const int G_TLS_CERTIFICATE_REVOKED = 16;
  static const int G_TLS_CERTIFICATE_INSECURE = 32;
  static const int G_TLS_CERTIFICATE_GENERIC_ERROR = 64;
  static const int G_TLS_CERTIFICATE_VALIDATE_ALL = 127;
}

/// GTlsAuthenticationMode:
/// @G_TLS_AUTHENTICATION_NONE: client authentication not required
/// @G_TLS_AUTHENTICATION_REQUESTED: client authentication is requested
/// @G_TLS_AUTHENTICATION_REQUIRED: client authentication is required
///
/// The client authentication mode for a #GTlsServerConnection.
///
/// Since: 2.28
abstract class GTlsAuthenticationMode {
  static const int G_TLS_AUTHENTICATION_NONE = 0;
  static const int G_TLS_AUTHENTICATION_REQUESTED = 1;
  static const int G_TLS_AUTHENTICATION_REQUIRED = 2;
}

/// GTlsChannelBindingType:
/// @G_TLS_CHANNEL_BINDING_TLS_UNIQUE:
/// [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
/// type
/// @G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT:
/// [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
/// binding type
///
/// The type of TLS channel binding data to retrieve from #GTlsConnection
/// or #GDtlsConnection, as documented by RFC 5929. The
/// [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
/// binding type is not currently implemented.
///
/// Since: 2.66
abstract class GTlsChannelBindingType {
  static const int G_TLS_CHANNEL_BINDING_TLS_UNIQUE = 0;
  static const int G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT = 1;
}

/// GTlsChannelBindingError:
/// @G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED: Either entire binding
/// retrieval facility or specific binding type is not implemented in the
/// TLS backend.
/// @G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE: The handshake is not yet
/// complete on the connection which is a strong requirement for any existing
/// binding type.
/// @G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE: Handshake is complete but
/// binding data is not available. That normally indicates the TLS
/// implementation failed to provide the binding data. For example, some
/// implementations do not provide a peer certificate for resumed connections.
/// @G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED: Binding type is not supported
/// on the current connection. This error could be triggered when requesting
/// `tls-server-end-point` binding data for a certificate which has no hash
/// function or uses multiple hash functions.
/// @G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR: Any other backend error
/// preventing binding data retrieval.
///
/// An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to
/// indicate a TLS channel binding retrieval error.
///
/// Since: 2.66
abstract class GTlsChannelBindingError {
  static const int G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED = 0;
  static const int G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE = 1;
  static const int G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE = 2;
  static const int G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED = 3;
  static const int G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR = 4;
}

/// GTlsRehandshakeMode:
/// @G_TLS_REHANDSHAKE_NEVER: Never allow rehandshaking
/// @G_TLS_REHANDSHAKE_SAFELY: Allow safe rehandshaking only
/// @G_TLS_REHANDSHAKE_UNSAFELY: Allow unsafe rehandshaking
///
/// When to allow rehandshaking. See
/// g_tls_connection_set_rehandshake_mode().
///
/// Since: 2.28
///
/// Deprecated: 2.60. Changing the rehandshake mode is no longer
/// required for compatibility. Also, rehandshaking has been removed
/// from the TLS protocol in TLS 1.3.
abstract class GTlsRehandshakeMode {
  static const int G_TLS_REHANDSHAKE_NEVER = 0;
  static const int G_TLS_REHANDSHAKE_SAFELY = 1;
  static const int G_TLS_REHANDSHAKE_UNSAFELY = 2;
}

/// GTlsPasswordFlags:
/// @G_TLS_PASSWORD_NONE: No flags
/// @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.
/// @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been
/// wrong many times, and the user may not have many chances left.
/// @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get
/// this password right.
/// @G_TLS_PASSWORD_PKCS11_USER: For PKCS #11, the user PIN is required.
/// Since: 2.70.
/// @G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: For PKCS #11, the security officer
/// PIN is required. Since: 2.70.
/// @G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: For PKCS #11, the context-specific
/// PIN is required. Since: 2.70.
///
/// Various flags for the password.
///
/// Since: 2.30
abstract class _GTlsPasswordFlags {
  static const int G_TLS_PASSWORD_NONE = 0;
  static const int G_TLS_PASSWORD_RETRY = 2;
  static const int G_TLS_PASSWORD_MANY_TRIES = 4;
  static const int G_TLS_PASSWORD_FINAL_TRY = 8;
  static const int G_TLS_PASSWORD_PKCS11_USER = 16;
  static const int G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER = 32;
  static const int G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC = 64;
}

/// GTlsInteractionResult:
/// @G_TLS_INTERACTION_UNHANDLED: The interaction was unhandled (i.e. not
/// implemented).
/// @G_TLS_INTERACTION_HANDLED: The interaction completed, and resulting data
/// is available.
/// @G_TLS_INTERACTION_FAILED: The interaction has failed, or was cancelled.
/// and the operation should be aborted.
///
/// #GTlsInteractionResult is returned by various functions in #GTlsInteraction
/// when finishing an interaction request.
///
/// Since: 2.30
abstract class GTlsInteractionResult {
  static const int G_TLS_INTERACTION_UNHANDLED = 0;
  static const int G_TLS_INTERACTION_HANDLED = 1;
  static const int G_TLS_INTERACTION_FAILED = 2;
}

/// GDBusInterfaceSkeletonFlags:
/// @G_DBUS_INTERFACE_SKELETON_FLAGS_NONE: No flags set.
/// @G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD: Each method invocation is handled in
/// a thread dedicated to the invocation. This means that the method implementation can use blocking IO
/// without blocking any other part of the process. It also means that the method implementation must
/// use locking to access data structures used by other threads.
///
/// Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
///
/// Since: 2.30
abstract class GDBusInterfaceSkeletonFlags {
  static const int G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0;
  static const int
      G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1;
}

/// GDBusObjectManagerClientFlags:
/// @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE: No flags set.
/// @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START: If not set and the
/// manager is for a well-known name, then request the bus to launch
/// an owner for the name if no-one owns the name. This flag can only
/// be used in managers for well-known names.
///
/// Flags used when constructing a #GDBusObjectManagerClient.
///
/// Since: 2.30
abstract class GDBusObjectManagerClientFlags {
  static const int G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0;
  static const int G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 1;
}

/// GTlsDatabaseVerifyFlags:
/// @G_TLS_DATABASE_VERIFY_NONE: No verification flags
///
/// Flags for g_tls_database_verify_chain().
///
/// Since: 2.30
abstract class GTlsDatabaseVerifyFlags {
  static const int G_TLS_DATABASE_VERIFY_NONE = 0;
}

/// GTlsDatabaseLookupFlags:
/// @G_TLS_DATABASE_LOOKUP_NONE: No lookup flags
/// @G_TLS_DATABASE_LOOKUP_KEYPAIR: Restrict lookup to certificates that have
/// a private key.
///
/// Flags for g_tls_database_lookup_certificate_for_handle(),
/// g_tls_database_lookup_certificate_issuer(),
/// and g_tls_database_lookup_certificates_issued_by().
///
/// Since: 2.30
abstract class GTlsDatabaseLookupFlags {
  static const int G_TLS_DATABASE_LOOKUP_NONE = 0;
  static const int G_TLS_DATABASE_LOOKUP_KEYPAIR = 1;
}

/// GTlsCertificateRequestFlags:
/// @G_TLS_CERTIFICATE_REQUEST_NONE: No flags
///
/// Flags for g_tls_interaction_request_certificate(),
/// g_tls_interaction_request_certificate_async(), and
/// g_tls_interaction_invoke_request_certificate().
///
/// Since: 2.40
abstract class GTlsCertificateRequestFlags {
  static const int G_TLS_CERTIFICATE_REQUEST_NONE = 0;
}

/// GTlsProtocolVersion:
/// @G_TLS_PROTOCOL_VERSION_UNKNOWN: No protocol version or unknown protocol version
/// @G_TLS_PROTOCOL_VERSION_SSL_3_0: SSL 3.0, which is insecure and should not be used
/// @G_TLS_PROTOCOL_VERSION_TLS_1_0: TLS 1.0, which is insecure and should not be used
/// @G_TLS_PROTOCOL_VERSION_TLS_1_1: TLS 1.1, which is insecure and should not be used
/// @G_TLS_PROTOCOL_VERSION_TLS_1_2: TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
/// @G_TLS_PROTOCOL_VERSION_TLS_1_3: TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
/// @G_TLS_PROTOCOL_VERSION_DTLS_1_0: DTLS 1.0, which is insecure and should not be used
/// @G_TLS_PROTOCOL_VERSION_DTLS_1_2: DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
///
/// The TLS or DTLS protocol version used by a #GTlsConnection or
/// #GDtlsConnection. The integer values of these versions are sequential
/// to ensure newer known protocol versions compare greater than older
/// known versions. Any known DTLS protocol version will compare greater
/// than any SSL or TLS protocol version. The protocol version may be
/// %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
/// protocol version that GLib does not yet know about. This means that
/// it's possible for an unknown DTLS protocol version to compare less
/// than the TLS protocol versions.
///
/// Since: 2.70
abstract class GTlsProtocolVersion {
  static const int G_TLS_PROTOCOL_VERSION_UNKNOWN = 0;
  static const int G_TLS_PROTOCOL_VERSION_SSL_3_0 = 1;
  static const int G_TLS_PROTOCOL_VERSION_TLS_1_0 = 2;
  static const int G_TLS_PROTOCOL_VERSION_TLS_1_1 = 3;
  static const int G_TLS_PROTOCOL_VERSION_TLS_1_2 = 4;
  static const int G_TLS_PROTOCOL_VERSION_TLS_1_3 = 5;
  static const int G_TLS_PROTOCOL_VERSION_DTLS_1_0 = 201;
  static const int G_TLS_PROTOCOL_VERSION_DTLS_1_2 = 202;
}

/// GIOModuleScopeFlags:
/// @G_IO_MODULE_SCOPE_NONE: No module scan flags
/// @G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: When using this scope to load or
/// scan modules, automatically block a modules which has the same base
/// basename as previously loaded module.
///
/// Flags for use with g_io_module_scope_new().
///
/// Since: 2.30
abstract class GIOModuleScopeFlags {
  static const int G_IO_MODULE_SCOPE_NONE = 0;
  static const int G_IO_MODULE_SCOPE_BLOCK_DUPLICATES = 1;
}

/// GSocketClientEvent:
/// @G_SOCKET_CLIENT_RESOLVING: The client is doing a DNS lookup.
/// @G_SOCKET_CLIENT_RESOLVED: The client has completed a DNS lookup.
/// @G_SOCKET_CLIENT_CONNECTING: The client is connecting to a remote
/// host (either a proxy or the destination server).
/// @G_SOCKET_CLIENT_CONNECTED: The client has connected to a remote
/// host.
/// @G_SOCKET_CLIENT_PROXY_NEGOTIATING: The client is negotiating
/// with a proxy to connect to the destination server.
/// @G_SOCKET_CLIENT_PROXY_NEGOTIATED: The client has negotiated
/// with the proxy server.
/// @G_SOCKET_CLIENT_TLS_HANDSHAKING: The client is performing a
/// TLS handshake.
/// @G_SOCKET_CLIENT_TLS_HANDSHAKED: The client has performed a
/// TLS handshake.
/// @G_SOCKET_CLIENT_COMPLETE: The client is done with a particular
/// #GSocketConnectable.
///
/// Describes an event occurring on a #GSocketClient. See the
/// #GSocketClient::event signal for more details.
///
/// Additional values may be added to this type in the future.
///
/// Since: 2.32
abstract class GSocketClientEvent {
  static const int G_SOCKET_CLIENT_RESOLVING = 0;
  static const int G_SOCKET_CLIENT_RESOLVED = 1;
  static const int G_SOCKET_CLIENT_CONNECTING = 2;
  static const int G_SOCKET_CLIENT_CONNECTED = 3;
  static const int G_SOCKET_CLIENT_PROXY_NEGOTIATING = 4;
  static const int G_SOCKET_CLIENT_PROXY_NEGOTIATED = 5;
  static const int G_SOCKET_CLIENT_TLS_HANDSHAKING = 6;
  static const int G_SOCKET_CLIENT_TLS_HANDSHAKED = 7;
  static const int G_SOCKET_CLIENT_COMPLETE = 8;
}

/// GSocketListenerEvent:
/// @G_SOCKET_LISTENER_BINDING: The listener is about to bind a socket.
/// @G_SOCKET_LISTENER_BOUND: The listener has bound a socket.
/// @G_SOCKET_LISTENER_LISTENING: The listener is about to start
/// listening on this socket.
/// @G_SOCKET_LISTENER_LISTENED: The listener is now listening on
/// this socket.
///
/// Describes an event occurring on a #GSocketListener. See the
/// #GSocketListener::event signal for more details.
///
/// Additional values may be added to this type in the future.
///
/// Since: 2.46
abstract class GSocketListenerEvent {
  static const int G_SOCKET_LISTENER_BINDING = 0;
  static const int G_SOCKET_LISTENER_BOUND = 1;
  static const int G_SOCKET_LISTENER_LISTENING = 2;
  static const int G_SOCKET_LISTENER_LISTENED = 3;
}

/// GTestDBusFlags:
/// @G_TEST_DBUS_NONE: No flags.
///
/// Flags to define future #GTestDBus behaviour.
///
/// Since: 2.34
abstract class GTestDBusFlags {
  static const int G_TEST_DBUS_NONE = 0;
}

/// GSubprocessFlags:
/// @G_SUBPROCESS_FLAGS_NONE: No flags.
/// @G_SUBPROCESS_FLAGS_STDIN_PIPE: create a pipe for the stdin of the
/// spawned process that can be accessed with
/// g_subprocess_get_stdin_pipe().
/// @G_SUBPROCESS_FLAGS_STDIN_INHERIT: stdin is inherited from the
/// calling process.
/// @G_SUBPROCESS_FLAGS_STDOUT_PIPE: create a pipe for the stdout of the
/// spawned process that can be accessed with
/// g_subprocess_get_stdout_pipe().
/// @G_SUBPROCESS_FLAGS_STDOUT_SILENCE: silence the stdout of the spawned
/// process (ie: redirect to `/dev/null`).
/// @G_SUBPROCESS_FLAGS_STDERR_PIPE: create a pipe for the stderr of the
/// spawned process that can be accessed with
/// g_subprocess_get_stderr_pipe().
/// @G_SUBPROCESS_FLAGS_STDERR_SILENCE: silence the stderr of the spawned
/// process (ie: redirect to `/dev/null`).
/// @G_SUBPROCESS_FLAGS_STDERR_MERGE: merge the stderr of the spawned
/// process with whatever the stdout happens to be.  This is a good way
/// of directing both streams to a common log file, for example.
/// @G_SUBPROCESS_FLAGS_INHERIT_FDS: spawned processes will inherit the
/// file descriptors of their parent, unless those descriptors have
/// been explicitly marked as close-on-exec.  This flag has no effect
/// over the "standard" file descriptors (stdin, stdout, stderr).
/// @G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: if path searching is
/// needed when spawning the subprocess, use the `PATH` in the launcher
/// environment. (Since: 2.72)
///
/// Flags to define the behaviour of a #GSubprocess.
///
/// Note that the default for stdin is to redirect from `/dev/null`.  For
/// stdout and stderr the default are for them to inherit the
/// corresponding descriptor from the calling process.
///
/// Note that it is a programmer error to mix 'incompatible' flags.  For
/// example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
/// %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
///
/// Since: 2.40
abstract class GSubprocessFlags {
  static const int G_SUBPROCESS_FLAGS_NONE = 0;
  static const int G_SUBPROCESS_FLAGS_STDIN_PIPE = 1;
  static const int G_SUBPROCESS_FLAGS_STDIN_INHERIT = 2;
  static const int G_SUBPROCESS_FLAGS_STDOUT_PIPE = 4;
  static const int G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 8;
  static const int G_SUBPROCESS_FLAGS_STDERR_PIPE = 16;
  static const int G_SUBPROCESS_FLAGS_STDERR_SILENCE = 32;
  static const int G_SUBPROCESS_FLAGS_STDERR_MERGE = 64;
  static const int G_SUBPROCESS_FLAGS_INHERIT_FDS = 128;
  static const int G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP = 256;
}

/// GNotificationPriority:
/// @G_NOTIFICATION_PRIORITY_LOW: for notifications that do not require
/// immediate attention - typically used for contextual background
/// information, such as contact birthdays or local weather
/// @G_NOTIFICATION_PRIORITY_NORMAL: the default priority, to be used for the
/// majority of notifications (for example email messages, software updates,
/// completed download/sync operations)
/// @G_NOTIFICATION_PRIORITY_HIGH: for events that require more attention,
/// usually because responses are time-sensitive (for example chat and SMS
/// messages or alarms)
/// @G_NOTIFICATION_PRIORITY_URGENT: for urgent notifications, or notifications
/// that require a response in a short space of time (for example phone calls
/// or emergency warnings)
///
/// Priority levels for #GNotifications.
///
/// Since: 2.42
abstract class GNotificationPriority {
  static const int G_NOTIFICATION_PRIORITY_NORMAL = 0;
  static const int G_NOTIFICATION_PRIORITY_LOW = 1;
  static const int G_NOTIFICATION_PRIORITY_HIGH = 2;
  static const int G_NOTIFICATION_PRIORITY_URGENT = 3;
}

/// GNetworkConnectivity:
/// @G_NETWORK_CONNECTIVITY_LOCAL: The host is not configured with a
/// route to the Internet; it may or may not be connected to a local
/// network.
/// @G_NETWORK_CONNECTIVITY_LIMITED: The host is connected to a network, but
/// does not appear to be able to reach the full Internet, perhaps
/// due to upstream network problems.
/// @G_NETWORK_CONNECTIVITY_PORTAL: The host is behind a captive portal and
/// cannot reach the full Internet.
/// @G_NETWORK_CONNECTIVITY_FULL: The host is connected to a network, and
/// appears to be able to reach the full Internet.
///
/// The host's network connectivity state, as reported by #GNetworkMonitor.
///
/// Since: 2.44
abstract class GNetworkConnectivity {
  static const int G_NETWORK_CONNECTIVITY_LOCAL = 1;
  static const int G_NETWORK_CONNECTIVITY_LIMITED = 2;
  static const int G_NETWORK_CONNECTIVITY_PORTAL = 3;
  static const int G_NETWORK_CONNECTIVITY_FULL = 4;
}

/// GPollableReturn:
/// @G_POLLABLE_RETURN_FAILED: Generic error condition for when an operation fails.
/// @G_POLLABLE_RETURN_OK: The operation was successfully finished.
/// @G_POLLABLE_RETURN_WOULD_BLOCK: The operation would block.
///
/// Return value for various IO operations that signal errors via the
/// return value and not necessarily via a #GError.
///
/// This enum exists to be able to return errors to callers without having to
/// allocate a #GError. Allocating #GErrors can be quite expensive for
/// regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
///
/// In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
/// operation to give details about the error that happened.
///
/// Since: 2.60
abstract class GPollableReturn {
  static const int G_POLLABLE_RETURN_FAILED = 0;
  static const int G_POLLABLE_RETURN_OK = 1;
  static const int G_POLLABLE_RETURN_WOULD_BLOCK = -27;
}

/// GMemoryMonitorWarningLevel:
/// @G_MEMORY_MONITOR_WARNING_LEVEL_LOW: Memory on the device is low, processes
/// should free up unneeded resources (for example, in-memory caches) so they can
/// be used elsewhere.
/// @G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM: Same as @G_MEMORY_MONITOR_WARNING_LEVEL_LOW
/// but the device has even less free memory, so processes should try harder to free
/// up unneeded resources. If your process does not need to stay running, it is a
/// good time for it to quit.
/// @G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL: The system will soon start terminating
/// processes to reclaim memory, including background processes.
///
/// Memory availability warning levels.
///
/// Note that because new values might be added, it is recommended that applications check
/// #GMemoryMonitorWarningLevel as ranges, for example:
/// |[<!-- language="C" -->
/// if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
/// drop_caches ();
/// ]|
///
/// Since: 2.64
abstract class GMemoryMonitorWarningLevel {
  static const int G_MEMORY_MONITOR_WARNING_LEVEL_LOW = 50;
  static const int G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM = 100;
  static const int G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL = 255;
}

/// GAppLaunchContext:
///
/// Integrating the launch with the launching application. This is used to
/// handle for instance startup notification and launching the new application
/// on the same screen as the launching window.
final class _GAppLaunchContext extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GAppLaunchContextPrivate> priv;
}

typedef GAppLaunchContextPrivate = _GAppLaunchContextPrivate;

final class _GAppLaunchContextPrivate extends ffi.Opaque {}

final class _GAppInfo extends ffi.Opaque {}

final class _GAsyncResult extends ffi.Opaque {}

final class _GAsyncInitable extends ffi.Opaque {}

final class _GBufferedInputStream extends ffi.Struct {
  external GFilterInputStream parent_instance;

  external ffi.Pointer<GBufferedInputStreamPrivate> priv;
}

typedef GFilterInputStream = _GFilterInputStream;

final class _GFilterInputStream extends ffi.Struct {
  external GInputStream parent_instance;

  external ffi.Pointer<GInputStream> base_stream;
}

typedef GInputStream = _GInputStream;

final class _GInputStream extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GInputStreamPrivate> priv;
}

typedef GInputStreamPrivate = _GInputStreamPrivate;

final class _GInputStreamPrivate extends ffi.Opaque {}

typedef GBufferedInputStreamPrivate = _GBufferedInputStreamPrivate;

final class _GBufferedInputStreamPrivate extends ffi.Opaque {}

final class _GBufferedOutputStream extends ffi.Struct {
  external GFilterOutputStream parent_instance;

  external ffi.Pointer<GBufferedOutputStreamPrivate> priv;
}

typedef GFilterOutputStream = _GFilterOutputStream;

final class _GFilterOutputStream extends ffi.Struct {
  external GOutputStream parent_instance;

  external ffi.Pointer<GOutputStream> base_stream;
}

typedef GOutputStream = _GOutputStream;

final class _GOutputStream extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GOutputStreamPrivate> priv;
}

typedef GOutputStreamPrivate = _GOutputStreamPrivate;

final class _GOutputStreamPrivate extends ffi.Opaque {}

typedef GBufferedOutputStreamPrivate = _GBufferedOutputStreamPrivate;

final class _GBufferedOutputStreamPrivate extends ffi.Opaque {}

final class _GCancellable extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GCancellablePrivate> priv;
}

typedef GCancellablePrivate = _GCancellablePrivate;

final class _GCancellablePrivate extends ffi.Opaque {}

final class _GCharsetConverter extends ffi.Opaque {}

final class _GConverter extends ffi.Opaque {}

final class _GConverterInputStream extends ffi.Struct {
  external GFilterInputStream parent_instance;

  external ffi.Pointer<GConverterInputStreamPrivate> priv;
}

typedef GConverterInputStreamPrivate = _GConverterInputStreamPrivate;

final class _GConverterInputStreamPrivate extends ffi.Opaque {}

final class _GConverterOutputStream extends ffi.Struct {
  external GFilterOutputStream parent_instance;

  external ffi.Pointer<GConverterOutputStreamPrivate> priv;
}

typedef GConverterOutputStreamPrivate = _GConverterOutputStreamPrivate;

final class _GConverterOutputStreamPrivate extends ffi.Opaque {}

final class _GDatagramBased extends ffi.Opaque {}

final class _GDataInputStream extends ffi.Struct {
  external GBufferedInputStream parent_instance;

  external ffi.Pointer<GDataInputStreamPrivate> priv;
}

typedef GBufferedInputStream = _GBufferedInputStream;
typedef GDataInputStreamPrivate = _GDataInputStreamPrivate;

final class _GDataInputStreamPrivate extends ffi.Opaque {}

final class _GSimplePermission extends ffi.Opaque {}

final class _GZlibCompressor extends ffi.Opaque {}

final class _GZlibDecompressor extends ffi.Opaque {}

/// GSimpleActionGroup:
///
/// The #GSimpleActionGroup structure contains private data and should only be accessed using the provided API.
///
/// Since: 2.28
final class _GSimpleActionGroup extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GSimpleActionGroupPrivate> priv;
}

typedef GSimpleActionGroupPrivate = _GSimpleActionGroupPrivate;

final class _GSimpleActionGroupPrivate extends ffi.Opaque {}

final class _GRemoteActionGroup extends ffi.Opaque {}

final class _GDBusActionGroup extends ffi.Opaque {}

final class _GActionMap extends ffi.Opaque {}

final class _GActionGroup extends ffi.Opaque {}

final class _GPropertyAction extends ffi.Opaque {}

final class _GSimpleAction extends ffi.Opaque {}

final class _GAction extends ffi.Opaque {}

final class _GApplication extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GApplicationPrivate> priv;
}

typedef GApplicationPrivate = _GApplicationPrivate;

final class _GApplicationPrivate extends ffi.Opaque {}

final class _GApplicationCommandLine extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GApplicationCommandLinePrivate> priv;
}

typedef GApplicationCommandLinePrivate = _GApplicationCommandLinePrivate;

final class _GApplicationCommandLinePrivate extends ffi.Opaque {}

final class _GSettingsBackend extends ffi.Opaque {}

final class _GSettings extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GSettingsPrivate> priv;
}

typedef GSettingsPrivate = _GSettingsPrivate;

final class _GSettingsPrivate extends ffi.Opaque {}

final class _GPermission extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GPermissionPrivate> priv;
}

typedef GPermissionPrivate = _GPermissionPrivate;

final class _GPermissionPrivate extends ffi.Opaque {}

final class _GMenuModel extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GMenuModelPrivate> priv;
}

typedef GMenuModelPrivate = _GMenuModelPrivate;

final class _GMenuModelPrivate extends ffi.Opaque {}

final class _GNotification extends ffi.Opaque {}

final class _GDrive extends ffi.Opaque {}

final class _GFileEnumerator extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GFileEnumeratorPrivate> priv;
}

typedef GFileEnumeratorPrivate = _GFileEnumeratorPrivate;

final class _GFileEnumeratorPrivate extends ffi.Opaque {}

/// GFileMonitor:
///
/// Watches for changes to a file.
final class _GFileMonitor extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GFileMonitorPrivate> priv;
}

typedef GFileMonitorPrivate = _GFileMonitorPrivate;

final class _GFileMonitorPrivate extends ffi.Opaque {}

final class _GFile extends ffi.Opaque {}

final class _GFileInfo extends ffi.Opaque {}

final class _GFileAttributeMatcher extends ffi.Opaque {}

/// GFileAttributeInfo:
/// @name: the name of the attribute.
/// @type: the #GFileAttributeType type of the attribute.
/// @flags: a set of #GFileAttributeInfoFlags.
///
/// Information about a specific attribute.
final class _GFileAttributeInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  @ffi.Int32()
  external int type;

  @ffi.Int32()
  external int flags;
}

/// GFileAttributeInfoList:
/// @infos: an array of #GFileAttributeInfos.
/// @n_infos: the number of values in the array.
///
/// Acts as a lightweight registry for possible valid file attributes.
/// The registry stores Key-Value pair formats as #GFileAttributeInfos.
final class _GFileAttributeInfoList extends ffi.Struct {
  external ffi.Pointer<GFileAttributeInfo> infos;

  @ffi.Int()
  external int n_infos;
}

typedef GFileAttributeInfo = _GFileAttributeInfo;

final class _GFileDescriptorBased extends ffi.Opaque {}

final class _GFileInputStream extends ffi.Struct {
  external GInputStream parent_instance;

  external ffi.Pointer<GFileInputStreamPrivate> priv;
}

typedef GFileInputStreamPrivate = _GFileInputStreamPrivate;

final class _GFileInputStreamPrivate extends ffi.Opaque {}

final class _GFileOutputStream extends ffi.Struct {
  external GOutputStream parent_instance;

  external ffi.Pointer<GFileOutputStreamPrivate> priv;
}

typedef GFileOutputStreamPrivate = _GFileOutputStreamPrivate;

final class _GFileOutputStreamPrivate extends ffi.Opaque {}

final class _GFileIOStream extends ffi.Struct {
  external GIOStream parent_instance;

  external ffi.Pointer<GFileIOStreamPrivate> priv;
}

typedef GIOStream = _GIOStream;

/// GIOStream:
///
/// Base class for read-write streams.
final class _GIOStream extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GIOStreamPrivate> priv;
}

typedef GIOStreamPrivate = _GIOStreamPrivate;

final class _GIOStreamPrivate extends ffi.Opaque {}

typedef GFileIOStreamPrivate = _GFileIOStreamPrivate;

final class _GFileIOStreamPrivate extends ffi.Opaque {}

final class _GFileIcon extends ffi.Opaque {}

final class _GFilenameCompleter extends ffi.Opaque {}

final class _GIcon extends ffi.Opaque {}

final class _GInetAddress extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GInetAddressPrivate> priv;
}

typedef GInetAddressPrivate = _GInetAddressPrivate;

final class _GInetAddressPrivate extends ffi.Opaque {}

final class _GInetAddressMask extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GInetAddressMaskPrivate> priv;
}

typedef GInetAddressMaskPrivate = _GInetAddressMaskPrivate;

final class _GInetAddressMaskPrivate extends ffi.Opaque {}

final class _GInetSocketAddress extends ffi.Struct {
  external GSocketAddress parent_instance;

  external ffi.Pointer<GInetSocketAddressPrivate> priv;
}

typedef GSocketAddress = _GSocketAddress;

final class _GSocketAddress extends ffi.Struct {
  external GObject parent_instance;
}

typedef GInetSocketAddressPrivate = _GInetSocketAddressPrivate;

final class _GInetSocketAddressPrivate extends ffi.Opaque {}

final class _GNativeSocketAddress extends ffi.Struct {
  external GSocketAddress parent_instance;

  external ffi.Pointer<GNativeSocketAddressPrivate> priv;
}

typedef GNativeSocketAddressPrivate = _GNativeSocketAddressPrivate;

final class _GNativeSocketAddressPrivate extends ffi.Opaque {}

final class _GInitable extends ffi.Opaque {}

final class _GIOModule extends ffi.Opaque {}

final class _GIOExtensionPoint extends ffi.Opaque {}

final class _GIOExtension extends ffi.Opaque {}

final class _GIOSchedulerJob extends ffi.Opaque {}

final class _GIOStreamAdapter extends ffi.Opaque {}

final class _GLoadableIcon extends ffi.Opaque {}

final class _GBytesIcon extends ffi.Opaque {}

final class _GMemoryInputStream extends ffi.Struct {
  external GInputStream parent_instance;

  external ffi.Pointer<GMemoryInputStreamPrivate> priv;
}

typedef GMemoryInputStreamPrivate = _GMemoryInputStreamPrivate;

final class _GMemoryInputStreamPrivate extends ffi.Opaque {}

final class _GMemoryOutputStream extends ffi.Struct {
  external GOutputStream parent_instance;

  external ffi.Pointer<GMemoryOutputStreamPrivate> priv;
}

typedef GMemoryOutputStreamPrivate = _GMemoryOutputStreamPrivate;

final class _GMemoryOutputStreamPrivate extends ffi.Opaque {}

final class _GMount extends ffi.Opaque {}

final class _GMountOperation extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GMountOperationPrivate> priv;
}

typedef GMountOperationPrivate = _GMountOperationPrivate;

final class _GMountOperationPrivate extends ffi.Opaque {}

final class _GNetworkAddress extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GNetworkAddressPrivate> priv;
}

typedef GNetworkAddressPrivate = _GNetworkAddressPrivate;

final class _GNetworkAddressPrivate extends ffi.Opaque {}

final class _GNetworkMonitor extends ffi.Opaque {}

final class _GNetworkService extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GNetworkServicePrivate> priv;
}

typedef GNetworkServicePrivate = _GNetworkServicePrivate;

final class _GNetworkServicePrivate extends ffi.Opaque {}

final class _GSimpleIOStream extends ffi.Opaque {}

final class _GPollableInputStream extends ffi.Opaque {}

final class _GPollableOutputStream extends ffi.Opaque {}

final class _GResolver extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GResolverPrivate> priv;
}

typedef GResolverPrivate = _GResolverPrivate;

final class _GResolverPrivate extends ffi.Opaque {}

final class _GResource extends ffi.Opaque {}

final class _GSeekable extends ffi.Opaque {}

final class _GSimpleAsyncResult extends ffi.Opaque {}

final class _GSocket extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GSocketPrivate> priv;
}

typedef GSocketPrivate = _GSocketPrivate;

final class _GSocketPrivate extends ffi.Opaque {}

final class _GSocketControlMessage extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GSocketControlMessagePrivate> priv;
}

typedef GSocketControlMessagePrivate = _GSocketControlMessagePrivate;

final class _GSocketControlMessagePrivate extends ffi.Opaque {}

final class _GSocketClient extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GSocketClientPrivate> priv;
}

typedef GSocketClientPrivate = _GSocketClientPrivate;

final class _GSocketClientPrivate extends ffi.Opaque {}

final class _GSocketConnection extends ffi.Struct {
  external GIOStream parent_instance;

  external ffi.Pointer<GSocketConnectionPrivate> priv;
}

typedef GSocketConnectionPrivate = _GSocketConnectionPrivate;

final class _GSocketConnectionPrivate extends ffi.Opaque {}

final class _GSocketListener extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GSocketListenerPrivate> priv;
}

typedef GSocketListenerPrivate = _GSocketListenerPrivate;

final class _GSocketListenerPrivate extends ffi.Opaque {}

final class _GSocketService extends ffi.Struct {
  external GSocketListener parent_instance;

  external ffi.Pointer<GSocketServicePrivate> priv;
}

/// GSocketListener:
///
/// A helper class for network servers to listen for and accept connections.
///
/// Since: 2.22
typedef GSocketListener = _GSocketListener;
typedef GSocketServicePrivate = _GSocketServicePrivate;

final class _GSocketServicePrivate extends ffi.Opaque {}

final class _GSocketAddressEnumerator extends ffi.Struct {
  external GObject parent_instance;
}

final class _GSocketConnectable extends ffi.Opaque {}

final class _GSrvTarget extends ffi.Opaque {}

final class _GTask extends ffi.Opaque {}

final class _GTcpConnection extends ffi.Struct {
  external GSocketConnection parent_instance;

  external ffi.Pointer<GTcpConnectionPrivate> priv;
}

/// GSocketConnection:
///
/// A socket connection GIOStream object for connection-oriented sockets.
///
/// Since: 2.22
typedef GSocketConnection = _GSocketConnection;
typedef GTcpConnectionPrivate = _GTcpConnectionPrivate;

final class _GTcpConnectionPrivate extends ffi.Opaque {}

final class _GTcpWrapperConnection extends ffi.Struct {
  external GTcpConnection parent_instance;

  external ffi.Pointer<GTcpWrapperConnectionPrivate> priv;
}

/// GTcpConnection:
///
/// A #GSocketConnection for TCP/IP connections.
///
/// Since: 2.22
typedef GTcpConnection = _GTcpConnection;
typedef GTcpWrapperConnectionPrivate = _GTcpWrapperConnectionPrivate;

final class _GTcpWrapperConnectionPrivate extends ffi.Opaque {}

final class _GThreadedSocketService extends ffi.Struct {
  external GSocketService parent_instance;

  external ffi.Pointer<GThreadedSocketServicePrivate> priv;
}

/// GSocketService:
///
/// A helper class for handling accepting incoming connections in the
/// glib mainloop.
///
/// Since: 2.22
typedef GSocketService = _GSocketService;
typedef GThreadedSocketServicePrivate = _GThreadedSocketServicePrivate;

final class _GThreadedSocketServicePrivate extends ffi.Opaque {}

final class _GDtlsConnection extends ffi.Opaque {}

final class _GDtlsClientConnection extends ffi.Opaque {}

final class _GDtlsServerConnection extends ffi.Opaque {}

final class _GThemedIcon extends ffi.Opaque {}

final class _GTlsCertificate extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GTlsCertificatePrivate> priv;
}

typedef GTlsCertificatePrivate = _GTlsCertificatePrivate;

final class _GTlsCertificatePrivate extends ffi.Opaque {}

final class _GTlsClientConnection extends ffi.Opaque {}

final class _GTlsConnection extends ffi.Struct {
  external GIOStream parent_instance;

  external ffi.Pointer<GTlsConnectionPrivate> priv;
}

typedef GTlsConnectionPrivate = _GTlsConnectionPrivate;

final class _GTlsConnectionPrivate extends ffi.Opaque {}

final class _GTlsDatabase extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GTlsDatabasePrivate> priv;
}

typedef GTlsDatabasePrivate = _GTlsDatabasePrivate;

final class _GTlsDatabasePrivate extends ffi.Opaque {}

final class _GTlsFileDatabase extends ffi.Opaque {}

final class _GTlsInteraction extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GTlsInteractionPrivate> priv;
}

typedef GTlsInteractionPrivate = _GTlsInteractionPrivate;

final class _GTlsInteractionPrivate extends ffi.Opaque {}

final class _GTlsPassword extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GTlsPasswordPrivate> priv;
}

typedef GTlsPasswordPrivate = _GTlsPasswordPrivate;

final class _GTlsPasswordPrivate extends ffi.Opaque {}

final class _GTlsServerConnection extends ffi.Opaque {}

final class _GVfs extends ffi.Struct {
  external GObject parent_instance;
}

final class _GProxyResolver extends ffi.Opaque {}

final class _GProxy extends ffi.Opaque {}

final class _GProxyAddress extends ffi.Struct {
  external GInetSocketAddress parent_instance;

  external ffi.Pointer<GProxyAddressPrivate> priv;
}

typedef GInetSocketAddress = _GInetSocketAddress;
typedef GProxyAddressPrivate = _GProxyAddressPrivate;

final class _GProxyAddressPrivate extends ffi.Opaque {}

final class _GProxyAddressEnumerator extends ffi.Struct {
  external GSocketAddressEnumerator parent_instance;

  external ffi.Pointer<GProxyAddressEnumeratorPrivate> priv;
}

typedef GSocketAddressEnumerator = _GSocketAddressEnumerator;
typedef GProxyAddressEnumeratorPrivate = _GProxyAddressEnumeratorPrivate;

final class _GProxyAddressEnumeratorPrivate extends ffi.Opaque {}

final class _GVolume extends ffi.Opaque {}

final class _GVolumeMonitor extends ffi.Struct {
  external GObject parent_instance;

  external gpointer priv;
}

final class _GInputVector extends ffi.Struct {
  external gpointer buffer;

  @gsize()
  external int size;
}

final class _GInputMessage extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<GSocketAddress>> address;

  external ffi.Pointer<GInputVector> vectors;

  @guint()
  external int num_vectors;

  @gsize()
  external int bytes_received;

  @gint()
  external int flags;

  external ffi.Pointer<ffi.Pointer<ffi.Pointer<GSocketControlMessage>>>
      control_messages;

  external ffi.Pointer<guint> num_control_messages;
}

/// GInputVector:
/// @buffer: Pointer to a buffer where data will be written.
/// @size: the available size in @buffer.
///
/// Structure used for scatter/gather data input.
/// You generally pass in an array of #GInputVectors
/// and the operation will store the read data starting in the
/// first buffer, switching to the next as needed.
///
/// Since: 2.22
typedef GInputVector = _GInputVector;

/// GSocketControlMessage:
///
/// Base class for socket-type specific control messages that can be sent and
/// received over #GSocket.
typedef GSocketControlMessage = _GSocketControlMessage;

final class _GOutputVector extends ffi.Struct {
  external gconstpointer buffer;

  @gsize()
  external int size;
}

final class _GOutputMessage extends ffi.Struct {
  external ffi.Pointer<GSocketAddress> address;

  external ffi.Pointer<GOutputVector> vectors;

  @guint()
  external int num_vectors;

  @guint()
  external int bytes_sent;

  external ffi.Pointer<ffi.Pointer<GSocketControlMessage>> control_messages;

  @guint()
  external int num_control_messages;
}

/// GOutputVector:
/// @buffer: Pointer to a buffer of data to read.
/// @size: the size of @buffer.
///
/// Structure used for scatter/gather data output.
/// You generally pass in an array of #GOutputVectors
/// and the operation will use all the buffers as if they were
/// one buffer.
///
/// Since: 2.22
typedef GOutputVector = _GOutputVector;

final class _GCredentials extends ffi.Opaque {}

final class _GUnixCredentialsMessage extends ffi.Opaque {}

final class _GUnixFDList extends ffi.Opaque {}

final class _GDBusMessage extends ffi.Opaque {}

final class _GDBusConnection extends ffi.Opaque {}

/// GDBusProxy:
///
/// The #GDBusProxy structure contains only private data and
/// should only be accessed using the provided API.
///
/// Since: 2.26
final class _GDBusProxy extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GDBusProxyPrivate> priv;
}

typedef GDBusProxyPrivate = _GDBusProxyPrivate;

final class _GDBusProxyPrivate extends ffi.Opaque {}

final class _GDBusMethodInvocation extends ffi.Opaque {}

final class _GDBusServer extends ffi.Opaque {}

final class _GDBusAuthObserver extends ffi.Opaque {}

/// GDBusErrorEntry:
/// @error_code: An error code.
/// @dbus_error_name: The D-Bus error name to associate with @error_code.
///
/// Struct used in g_dbus_error_register_error_domain().
///
/// Since: 2.26
final class _GDBusErrorEntry extends ffi.Struct {
  @gint()
  external int error_code;

  external ffi.Pointer<gchar> dbus_error_name;
}

/// GDBusInterfaceVTable:
/// @method_call: Function for handling incoming method calls.
/// @get_property: Function for getting a property.
/// @set_property: Function for setting a property.
///
/// Virtual table for handling properties and method calls for a D-Bus
/// interface.
///
/// Since 2.38, if you want to handle getting/setting D-Bus properties
/// asynchronously, give %NULL as your get_property() or set_property()
/// function. The D-Bus call will be directed to your @method_call function,
/// with the provided @interface_name set to "org.freedesktop.DBus.Properties".
///
/// Ownership of the #GDBusMethodInvocation object passed to the
/// method_call() function is transferred to your handler; you must
/// call one of the methods of #GDBusMethodInvocation to return a reply
/// (possibly empty), or an error. These functions also take ownership
/// of the passed-in invocation object, so unless the invocation
/// object has otherwise been referenced, it will be then be freed.
/// Calling one of these functions may be done within your
/// method_call() implementation but it also can be done at a later
/// point to handle the method asynchronously.
///
/// The usual checks on the validity of the calls is performed. For
/// `Get` calls, an error is automatically returned if the property does
/// not exist or the permissions do not allow access. The same checks are
/// performed for `Set` calls, and the provided value is also checked for
/// being the correct type.
///
/// For both `Get` and `Set` calls, the #GDBusMethodInvocation
/// passed to the @method_call handler can be queried with
/// g_dbus_method_invocation_get_property_info() to get a pointer
/// to the #GDBusPropertyInfo of the property.
///
/// If you have readable properties specified in your interface info,
/// you must ensure that you either provide a non-%NULL @get_property()
/// function or provide implementations of both the `Get` and `GetAll`
/// methods on org.freedesktop.DBus.Properties interface in your @method_call
/// function. Note that the required return type of the `Get` call is
/// `(v)`, not the type of the property. `GetAll` expects a return value
/// of type `a{sv}`.
///
/// If you have writable properties specified in your interface info,
/// you must ensure that you either provide a non-%NULL @set_property()
/// function or provide an implementation of the `Set` call. If implementing
/// the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
///
/// Since: 2.26
final class _GDBusInterfaceVTable extends ffi.Struct {
  external GDBusInterfaceMethodCallFunc method_call;

  external GDBusInterfaceGetPropertyFunc get_property;

  external GDBusInterfaceSetPropertyFunc set_property;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> padding;
}

/// GDBusInterfaceMethodCallFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that the method was invoked on.
/// @interface_name: The D-Bus interface name the method was invoked on.
/// @method_name: The name of the method that was invoked.
/// @parameters: A #GVariant tuple with parameters.
/// @invocation: (transfer full): A #GDBusMethodInvocation object that must be used to return a value or error.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().
///
/// The type of the @method_call function in #GDBusInterfaceVTable.
///
/// Since: 2.26
typedef GDBusInterfaceMethodCallFunc
    = ffi.Pointer<ffi.NativeFunction<GDBusInterfaceMethodCallFuncFunction>>;
typedef GDBusInterfaceMethodCallFuncFunction = ffi.Void Function(
    ffi.Pointer<GDBusConnection> connection,
    ffi.Pointer<gchar> sender,
    ffi.Pointer<gchar> object_path,
    ffi.Pointer<gchar> interface_name,
    ffi.Pointer<gchar> method_name,
    ffi.Pointer<GVariant> parameters,
    ffi.Pointer<GDBusMethodInvocation> invocation,
    gpointer user_data);
typedef DartGDBusInterfaceMethodCallFuncFunction = void Function(
    ffi.Pointer<GDBusConnection> connection,
    ffi.Pointer<gchar> sender,
    ffi.Pointer<gchar> object_path,
    ffi.Pointer<gchar> interface_name,
    ffi.Pointer<gchar> method_name,
    ffi.Pointer<GVariant> parameters,
    ffi.Pointer<GDBusMethodInvocation> invocation,
    gpointer user_data);
typedef GDBusConnection = _GDBusConnection;
typedef GDBusMethodInvocation = _GDBusMethodInvocation;

/// GDBusInterfaceGetPropertyFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that the method was invoked on.
/// @interface_name: The D-Bus interface name for the property.
/// @property_name: The name of the property to get the value of.
/// @error: Return location for error.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().
///
/// The type of the @get_property function in #GDBusInterfaceVTable.
///
/// Returns: A #GVariant with the value for @property_name or %NULL if
/// @error is set. If the returned #GVariant is floating, it is
/// consumed - otherwise its reference count is decreased by one.
///
/// Since: 2.26
typedef GDBusInterfaceGetPropertyFunc
    = ffi.Pointer<ffi.NativeFunction<GDBusInterfaceGetPropertyFuncFunction>>;
typedef GDBusInterfaceGetPropertyFuncFunction = ffi.Pointer<GVariant> Function(
    ffi.Pointer<GDBusConnection> connection,
    ffi.Pointer<gchar> sender,
    ffi.Pointer<gchar> object_path,
    ffi.Pointer<gchar> interface_name,
    ffi.Pointer<gchar> property_name,
    ffi.Pointer<ffi.Pointer<GError>> error,
    gpointer user_data);

/// GDBusInterfaceSetPropertyFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that the method was invoked on.
/// @interface_name: The D-Bus interface name for the property.
/// @property_name: The name of the property to get the value of.
/// @value: The value to set the property to.
/// @error: Return location for error.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().
///
/// The type of the @set_property function in #GDBusInterfaceVTable.
///
/// Returns: %TRUE if the property was set to @value, %FALSE if @error is set.
///
/// Since: 2.26
typedef GDBusInterfaceSetPropertyFunc
    = ffi.Pointer<ffi.NativeFunction<GDBusInterfaceSetPropertyFuncFunction>>;
typedef GDBusInterfaceSetPropertyFuncFunction = gboolean Function(
    ffi.Pointer<GDBusConnection> connection,
    ffi.Pointer<gchar> sender,
    ffi.Pointer<gchar> object_path,
    ffi.Pointer<gchar> interface_name,
    ffi.Pointer<gchar> property_name,
    ffi.Pointer<GVariant> value,
    ffi.Pointer<ffi.Pointer<GError>> error,
    gpointer user_data);
typedef DartGDBusInterfaceSetPropertyFuncFunction = Dartgint Function(
    ffi.Pointer<GDBusConnection> connection,
    ffi.Pointer<gchar> sender,
    ffi.Pointer<gchar> object_path,
    ffi.Pointer<gchar> interface_name,
    ffi.Pointer<gchar> property_name,
    ffi.Pointer<GVariant> value,
    ffi.Pointer<ffi.Pointer<GError>> error,
    gpointer user_data);

/// GDBusSubtreeVTable:
/// @enumerate: Function for enumerating child nodes.
/// @introspect: Function for introspecting a child node.
/// @dispatch: Function for dispatching a remote call on a child node.
///
/// Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().
///
/// Since: 2.26
final class _GDBusSubtreeVTable extends ffi.Struct {
  external GDBusSubtreeEnumerateFunc enumerate;

  external GDBusSubtreeIntrospectFunc introspect;

  external GDBusSubtreeDispatchFunc dispatch;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> padding;
}

/// GDBusSubtreeEnumerateFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that was registered with g_dbus_connection_register_subtree().
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().
///
/// The type of the @enumerate function in #GDBusSubtreeVTable.
///
/// This function is called when generating introspection data and also
/// when preparing to dispatch incoming messages in the event that the
/// %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
/// specified (ie: to verify that the object path is valid).
///
/// Hierarchies are not supported; the items that you return should not
/// contain the `/` character.
///
/// The return value will be freed with g_strfreev().
///
/// Returns: (array zero-terminated=1) (transfer full): A newly allocated array of strings for node names that are children of @object_path.
///
/// Since: 2.26
typedef GDBusSubtreeEnumerateFunc
    = ffi.Pointer<ffi.NativeFunction<GDBusSubtreeEnumerateFuncFunction>>;
typedef GDBusSubtreeEnumerateFuncFunction
    = ffi.Pointer<ffi.Pointer<gchar>> Function(
        ffi.Pointer<GDBusConnection> connection,
        ffi.Pointer<gchar> sender,
        ffi.Pointer<gchar> object_path,
        gpointer user_data);

/// GDBusSubtreeIntrospectFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that was registered with g_dbus_connection_register_subtree().
/// @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().
///
/// The type of the @introspect function in #GDBusSubtreeVTable.
///
/// Subtrees are flat.  @node, if non-%NULL, is always exactly one
/// segment of the object path (ie: it never contains a slash).
///
/// This function should return %NULL to indicate that there is no object
/// at this node.
///
/// If this function returns non-%NULL, the return value is expected to
/// be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
/// structures describing the interfaces implemented by @node.  This
/// array will have g_dbus_interface_info_unref() called on each item
/// before being freed with g_free().
///
/// The difference between returning %NULL and an array containing zero
/// items is that the standard DBus interfaces will returned to the
/// remote introspector in the empty array case, but not in the %NULL
/// case.
///
/// Returns: (array zero-terminated=1) (nullable) (transfer full): A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.
///
/// Since: 2.26
typedef GDBusSubtreeIntrospectFunc
    = ffi.Pointer<ffi.NativeFunction<GDBusSubtreeIntrospectFuncFunction>>;
typedef GDBusSubtreeIntrospectFuncFunction
    = ffi.Pointer<ffi.Pointer<GDBusInterfaceInfo>> Function(
        ffi.Pointer<GDBusConnection> connection,
        ffi.Pointer<gchar> sender,
        ffi.Pointer<gchar> object_path,
        ffi.Pointer<gchar> node,
        gpointer user_data);
typedef GDBusInterfaceInfo = _GDBusInterfaceInfo;

/// GDBusInterfaceInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
/// @methods: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.
/// @signals: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.
/// @properties: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about a D-Bus interface.
///
/// Since: 2.26
final class _GDBusInterfaceInfo extends ffi.Struct {
  @gint()
  external int ref_count;

  external ffi.Pointer<gchar> name;

  external ffi.Pointer<ffi.Pointer<GDBusMethodInfo>> methods;

  external ffi.Pointer<ffi.Pointer<GDBusSignalInfo>> signals;

  external ffi.Pointer<ffi.Pointer<GDBusPropertyInfo>> properties;

  external ffi.Pointer<ffi.Pointer<GDBusAnnotationInfo>> annotations;
}

typedef GDBusMethodInfo = _GDBusMethodInfo;

/// GDBusMethodInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: The name of the D-Bus method, e.g. @RequestName.
/// @in_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.
/// @out_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about a method on an D-Bus interface.
///
/// Since: 2.26
final class _GDBusMethodInfo extends ffi.Struct {
  @gint()
  external int ref_count;

  external ffi.Pointer<gchar> name;

  external ffi.Pointer<ffi.Pointer<GDBusArgInfo>> in_args;

  external ffi.Pointer<ffi.Pointer<GDBusArgInfo>> out_args;

  external ffi.Pointer<ffi.Pointer<GDBusAnnotationInfo>> annotations;
}

typedef GDBusArgInfo = _GDBusArgInfo;

/// GDBusArgInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: Name of the argument, e.g. @unix_user_id.
/// @signature: D-Bus signature of the argument (a single complete type).
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about an argument for a method or a signal.
///
/// Since: 2.26
final class _GDBusArgInfo extends ffi.Struct {
  @gint()
  external int ref_count;

  external ffi.Pointer<gchar> name;

  external ffi.Pointer<gchar> signature;

  external ffi.Pointer<ffi.Pointer<GDBusAnnotationInfo>> annotations;
}

typedef GDBusAnnotationInfo = _GDBusAnnotationInfo;

/// GDBusAnnotationInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @key: The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
/// @value: The value of the annotation.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about an annotation.
///
/// Since: 2.26
final class _GDBusAnnotationInfo extends ffi.Struct {
  @gint()
  external int ref_count;

  external ffi.Pointer<gchar> key;

  external ffi.Pointer<gchar> value;

  external ffi.Pointer<ffi.Pointer<GDBusAnnotationInfo1>> annotations;
}

typedef GDBusAnnotationInfo1 = _GDBusAnnotationInfo;
typedef GDBusSignalInfo = _GDBusSignalInfo;

/// GDBusSignalInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: The name of the D-Bus signal, e.g. "NameOwnerChanged".
/// @args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about a signal on a D-Bus interface.
///
/// Since: 2.26
final class _GDBusSignalInfo extends ffi.Struct {
  @gint()
  external int ref_count;

  external ffi.Pointer<gchar> name;

  external ffi.Pointer<ffi.Pointer<GDBusArgInfo>> args;

  external ffi.Pointer<ffi.Pointer<GDBusAnnotationInfo>> annotations;
}

typedef GDBusPropertyInfo = _GDBusPropertyInfo;

/// GDBusPropertyInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: The name of the D-Bus property, e.g. "SupportedFilesystems".
/// @signature: The D-Bus signature of the property (a single complete type).
/// @flags: Access control flags for the property.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about a D-Bus property on a D-Bus interface.
///
/// Since: 2.26
final class _GDBusPropertyInfo extends ffi.Struct {
  @gint()
  external int ref_count;

  external ffi.Pointer<gchar> name;

  external ffi.Pointer<gchar> signature;

  @ffi.Int32()
  external int flags;

  external ffi.Pointer<ffi.Pointer<GDBusAnnotationInfo>> annotations;
}

/// GDBusSubtreeDispatchFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that was registered with g_dbus_connection_register_subtree().
/// @interface_name: The D-Bus interface name that the method call or property access is for.
/// @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.
/// @out_user_data: (nullable) (not optional): Return location for user data to pass to functions in the returned #GDBusInterfaceVTable.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().
///
/// The type of the @dispatch function in #GDBusSubtreeVTable.
///
/// Subtrees are flat.  @node, if non-%NULL, is always exactly one
/// segment of the object path (ie: it never contains a slash).
///
/// Returns: (nullable): A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.
///
/// Since: 2.26
typedef GDBusSubtreeDispatchFunc
    = ffi.Pointer<ffi.NativeFunction<GDBusSubtreeDispatchFuncFunction>>;
typedef GDBusSubtreeDispatchFuncFunction
    = ffi.Pointer<GDBusInterfaceVTable> Function(
        ffi.Pointer<GDBusConnection> connection,
        ffi.Pointer<gchar> sender,
        ffi.Pointer<gchar> object_path,
        ffi.Pointer<gchar> interface_name,
        ffi.Pointer<gchar> node,
        ffi.Pointer<gpointer> out_user_data,
        gpointer user_data);
typedef GDBusInterfaceVTable = _GDBusInterfaceVTable;

/// GDBusNodeInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @path: The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
/// @interfaces: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.
/// @nodes: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about nodes in a remote object hierarchy.
///
/// Since: 2.26
final class _GDBusNodeInfo extends ffi.Struct {
  @gint()
  external int ref_count;

  external ffi.Pointer<gchar> path;

  external ffi.Pointer<ffi.Pointer<GDBusInterfaceInfo>> interfaces;

  external ffi.Pointer<ffi.Pointer<GDBusNodeInfo>> nodes;

  external ffi.Pointer<ffi.Pointer<GDBusAnnotationInfo>> annotations;
}

typedef GDBusNodeInfo = _GDBusNodeInfo;

final class _GDBusInterface extends ffi.Opaque {}

/// GDBusInterfaceSkeleton:
///
/// The #GDBusInterfaceSkeleton structure contains private data and should
/// only be accessed using the provided API.
///
/// Since: 2.30
final class _GDBusInterfaceSkeleton extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GDBusInterfaceSkeletonPrivate> priv;
}

typedef GDBusInterfaceSkeletonPrivate = _GDBusInterfaceSkeletonPrivate;

final class _GDBusInterfaceSkeletonPrivate extends ffi.Opaque {}

final class _GDBusObject extends ffi.Opaque {}

/// GDBusObjectSkeleton:
///
/// The #GDBusObjectSkeleton structure contains private data and should only be
/// accessed using the provided API.
///
/// Since: 2.30
final class _GDBusObjectSkeleton extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GDBusObjectSkeletonPrivate> priv;
}

typedef GDBusObjectSkeletonPrivate = _GDBusObjectSkeletonPrivate;

final class _GDBusObjectSkeletonPrivate extends ffi.Opaque {}

/// GDBusObjectProxy:
///
/// The #GDBusObjectProxy structure contains private data and should
/// only be accessed using the provided API.
///
/// Since: 2.30
final class _GDBusObjectProxy extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GDBusObjectProxyPrivate> priv;
}

typedef GDBusObjectProxyPrivate = _GDBusObjectProxyPrivate;

final class _GDBusObjectProxyPrivate extends ffi.Opaque {}

final class _GDBusObjectManager extends ffi.Opaque {}

/// GDBusObjectManagerClient:
///
/// The #GDBusObjectManagerClient structure contains private data and should
/// only be accessed using the provided API.
///
/// Since: 2.30
final class _GDBusObjectManagerClient extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GDBusObjectManagerClientPrivate> priv;
}

typedef GDBusObjectManagerClientPrivate = _GDBusObjectManagerClientPrivate;

final class _GDBusObjectManagerClientPrivate extends ffi.Opaque {}

/// GDBusObjectManagerServer:
///
/// The #GDBusObjectManagerServer structure contains private data and should
/// only be accessed using the provided API.
///
/// Since: 2.30
final class _GDBusObjectManagerServer extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GDBusObjectManagerServerPrivate> priv;
}

typedef GDBusObjectManagerServerPrivate = _GDBusObjectManagerServerPrivate;

final class _GDBusObjectManagerServerPrivate extends ffi.Opaque {}

final class _GTestDBus extends ffi.Opaque {}

final class _GSubprocess extends ffi.Opaque {}

final class _GSubprocessLauncher extends ffi.Opaque {}

final class _GActionInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(ffi.Pointer<GAction> action)>> get_name;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GVariantType> Function(ffi.Pointer<GAction> action)>>
      get_parameter_type;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GVariantType> Function(ffi.Pointer<GAction> action)>>
      get_state_type;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GVariant> Function(ffi.Pointer<GAction> action)>>
      get_state_hint;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GAction> action)>>
      get_enabled;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GVariant> Function(ffi.Pointer<GAction> action)>>
      get_state;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GAction> action, ffi.Pointer<GVariant> value)>>
      change_state;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GAction> action,
              ffi.Pointer<GVariant> parameter)>> activate;
}

typedef GAction = _GAction;

final class _GActionGroupInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name)>> has_action;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<gchar>> Function(
              ffi.Pointer<GActionGroup> action_group)>> list_actions;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name)>> get_action_enabled;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVariantType> Function(
              ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name)>> get_action_parameter_type;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVariantType> Function(
              ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name)>> get_action_state_type;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVariant> Function(ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name)>> get_action_state_hint;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVariant> Function(ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name)>> get_action_state;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name,
              ffi.Pointer<GVariant> value)>> change_action_state;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name,
              ffi.Pointer<GVariant> parameter)>> activate_action;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name)>> action_added;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name)>> action_removed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name,
              gboolean enabled)>> action_enabled_changed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name,
              ffi.Pointer<GVariant> state)>> action_state_changed;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GActionGroup> action_group,
              ffi.Pointer<gchar> action_name,
              ffi.Pointer<gboolean> enabled,
              ffi.Pointer<ffi.Pointer<GVariantType>> parameter_type,
              ffi.Pointer<ffi.Pointer<GVariantType>> state_type,
              ffi.Pointer<ffi.Pointer<GVariant>> state_hint,
              ffi.Pointer<ffi.Pointer<GVariant>> state)>> query_action;
}

typedef GActionGroup = _GActionGroup;

final class _GActionMapInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GAction> Function(ffi.Pointer<GActionMap> action_map,
              ffi.Pointer<gchar> action_name)>> lookup_action;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GActionMap> action_map,
              ffi.Pointer<GAction> action)>> add_action;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GActionMap> action_map,
              ffi.Pointer<gchar> action_name)>> remove_action;
}

typedef GActionMap = _GActionMap;

final class _GActionEntry extends ffi.Struct {
  external ffi.Pointer<gchar> name;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAction> action,
              ffi.Pointer<GVariant> parameter, gpointer user_data)>> activate;

  external ffi.Pointer<gchar> parameter_type;

  external ffi.Pointer<gchar> state;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAction> action,
              ffi.Pointer<GVariant> value, gpointer user_data)>> change_state;

  @ffi.Array.multi([3])
  external ffi.Array<gsize> padding;
}

typedef GSimpleAction = _GSimpleAction;

final class _GAppLaunchContextClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GAppLaunchContext> context,
              ffi.Pointer<GAppInfo> info,
              ffi.Pointer<GList> files)>> get_display;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GAppLaunchContext> context,
              ffi.Pointer<GAppInfo> info,
              ffi.Pointer<GList> files)>> get_startup_notify_id;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GAppLaunchContext> context,
              ffi.Pointer<ffi.Char> startup_notify_id)>> launch_failed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GAppLaunchContext> context,
              ffi.Pointer<GAppInfo> info,
              ffi.Pointer<GVariant> platform_data)>> launched;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GAppLaunchContext> context,
              ffi.Pointer<GAppInfo> info,
              ffi.Pointer<GVariant> platform_data)>> launch_started;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;
}

typedef GAppLaunchContext = _GAppLaunchContext;
typedef GAppInfo = _GAppInfo;

final class _GAppInfoIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GAppInfo> Function(ffi.Pointer<GAppInfo> appinfo)>> dup;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GAppInfo> appinfo1,
              ffi.Pointer<GAppInfo> appinfo2)>> equal;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GAppInfo> appinfo)>>
      get_id;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GAppInfo> appinfo)>>
      get_name;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GAppInfo> appinfo)>>
      get_description;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GAppInfo> appinfo)>>
      get_executable;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GIcon> Function(ffi.Pointer<GAppInfo> appinfo)>> get_icon;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAppInfo> appinfo,
              ffi.Pointer<GList> files,
              ffi.Pointer<GAppLaunchContext> context,
              ffi.Pointer<ffi.Pointer<GError>> error)>> launch;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GAppInfo> appinfo)>>
      supports_uris;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GAppInfo> appinfo)>>
      supports_files;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAppInfo> appinfo,
              ffi.Pointer<GList> uris,
              ffi.Pointer<GAppLaunchContext> context,
              ffi.Pointer<ffi.Pointer<GError>> error)>> launch_uris;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GAppInfo> appinfo)>>
      should_show;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAppInfo> appinfo,
              ffi.Pointer<ffi.Char> content_type,
              ffi.Pointer<ffi.Pointer<GError>> error)>> set_as_default_for_type;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GAppInfo> appinfo,
                  ffi.Pointer<ffi.Char> extension1,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      set_as_default_for_extension;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAppInfo> appinfo,
              ffi.Pointer<ffi.Char> content_type,
              ffi.Pointer<ffi.Pointer<GError>> error)>> add_supports_type;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GAppInfo> appinfo)>>
      can_remove_supports_type;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAppInfo> appinfo,
              ffi.Pointer<ffi.Char> content_type,
              ffi.Pointer<ffi.Pointer<GError>> error)>> remove_supports_type;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GAppInfo> appinfo)>>
      can_delete;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GAppInfo> appinfo)>>
      do_delete;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GAppInfo> appinfo)>>
      get_commandline;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GAppInfo> appinfo)>>
      get_display_name;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GAppInfo> appinfo,
                  ffi.Pointer<ffi.Char> content_type,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      set_as_last_used_for_type;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<GAppInfo> appinfo)>> get_supported_types;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GAppInfo> appinfo,
              ffi.Pointer<GList> uris,
              ffi.Pointer<GAppLaunchContext> context,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> launch_uris_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAppInfo> appinfo,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> launch_uris_finish;
}

typedef GIcon = _GIcon;
typedef GCancellable = _GCancellable;

/// GAsyncReadyCallback:
/// @source_object: (nullable): the object the asynchronous operation was started with.
/// @res: a #GAsyncResult.
/// @user_data: user data passed to the callback.
///
/// Type definition for a function that will be called back when an asynchronous
/// operation within GIO has been completed. #GAsyncReadyCallback
/// callbacks from #GTask are guaranteed to be invoked in a later
/// iteration of the
/// [thread-default main context][g-main-context-push-thread-default]
/// where the #GTask was created. All other users of
/// #GAsyncReadyCallback must likewise call it asynchronously in a
/// later iteration of the main context.
///
/// The asynchronous operation is guaranteed to have held a reference to
/// @source_object from the time when the `*_async()` function was called, until
/// after this callback returns.
typedef GAsyncReadyCallback
    = ffi.Pointer<ffi.NativeFunction<GAsyncReadyCallbackFunction>>;
typedef GAsyncReadyCallbackFunction = ffi.Void Function(
    ffi.Pointer<GObject> source_object,
    ffi.Pointer<GAsyncResult> res,
    gpointer user_data);
typedef DartGAsyncReadyCallbackFunction = void Function(
    ffi.Pointer<GObject> source_object,
    ffi.Pointer<GAsyncResult> res,
    gpointer user_data);
typedef GAsyncResult = _GAsyncResult;

final class _GAppInfoMonitor extends ffi.Opaque {}

final class _GApplicationClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GApplication> application)>> startup;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GApplication> application)>> activate;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GApplication> application,
              ffi.Pointer<ffi.Pointer<GFile>> files,
              gint n_files,
              ffi.Pointer<gchar> hint)>> open;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GApplication> application,
              ffi.Pointer<GApplicationCommandLine> command_line)>> command_line;

  /// GApplicationClass::local_command_line:
  /// @application: a #GApplication
  /// @arguments: (inout) (array zero-terminated=1): array of command line arguments
  /// @exit_status: (out): exit status to fill after processing the command line.
  ///
  /// This virtual function is always invoked in the local instance. It
  /// gets passed a pointer to a %NULL-terminated copy of @argv and is
  /// expected to remove arguments that it handled (shifting up remaining
  /// arguments).
  ///
  /// The last argument to local_command_line() is a pointer to the @status
  /// variable which can used to set the exit status that is returned from
  /// g_application_run().
  ///
  /// See g_application_run() for more details on #GApplication startup.
  ///
  /// Returns: %TRUE if the commandline has been completely handled
  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GApplication> application,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<gchar>>> arguments,
              ffi.Pointer<ffi.Int> exit_status)>> local_command_line;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GApplication> application,
              ffi.Pointer<GVariant> platform_data)>> before_emit;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GApplication> application,
              ffi.Pointer<GVariant> platform_data)>> after_emit;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GApplication> application,
              ffi.Pointer<GVariantBuilder> builder)>> add_platform_data;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GApplication> application)>>
      quit_mainloop;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GApplication> application)>>
      run_mainloop;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GApplication> application)>> shutdown;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GApplication> application,
              ffi.Pointer<GDBusConnection> connection,
              ffi.Pointer<gchar> object_path,
              ffi.Pointer<ffi.Pointer<GError>> error)>> dbus_register;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GApplication> application,
              ffi.Pointer<GDBusConnection> connection,
              ffi.Pointer<gchar> object_path)>> dbus_unregister;

  external ffi.Pointer<
      ffi.NativeFunction<
          gint Function(ffi.Pointer<GApplication> application,
              ffi.Pointer<GVariantDict> options)>> handle_local_options;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GApplication> application)>> name_lost;

  @ffi.Array.multi([7])
  external ffi.Array<gpointer> padding;
}

typedef GApplication = _GApplication;

/// GFile:
///
/// A handle to an object implementing the #GFileIface interface.
/// Generally stores a location within the file system. Handles do not
/// necessarily represent files or directories that currently exist.
typedef GFile = _GFile;
typedef GApplicationCommandLine = _GApplicationCommandLine;
typedef GVariantBuilder = _GVariantBuilder;
typedef GVariantDict = _GVariantDict;

final class _GApplicationCommandLineClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GApplicationCommandLine> cmdline,
              ffi.Pointer<gchar> message)>> print_literal;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GApplicationCommandLine> cmdline,
              ffi.Pointer<gchar> message)>> printerr_literal;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GApplicationCommandLine> cmdline)>> get_stdin;

  @ffi.Array.multi([11])
  external ffi.Array<gpointer> padding;
}

/// GInitableIface:
/// @g_iface: The parent interface.
/// @init: Initializes the object.
///
/// Provides an interface for initializing object such that initialization
/// may fail.
///
/// Since: 2.22
final class _GInitableIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GInitable> initable,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> init;
}

typedef GInitable = _GInitable;

/// GAsyncInitableIface:
/// @g_iface: The parent interface.
/// @init_async: Starts initialization of the object.
/// @init_finish: Finishes initialization of the object.
///
/// Provides an interface for asynchronous initializing object such that
/// initialization may fail.
///
/// Since: 2.22
final class _GAsyncInitableIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GAsyncInitable> initable,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> init_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAsyncInitable> initable,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> init_finish;
}

typedef GAsyncInitable = _GAsyncInitable;

/// GAsyncResultIface:
/// @g_iface: The parent interface.
/// @get_user_data: Gets the user data passed to the callback.
/// @get_source_object: Gets the source object that issued the asynchronous operation.
/// @is_tagged: Checks if a result is tagged with a particular source.
///
/// Interface definition for #GAsyncResult.
final class _GAsyncResultIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<gpointer Function(ffi.Pointer<GAsyncResult> res)>>
      get_user_data;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GObject> Function(ffi.Pointer<GAsyncResult> res)>>
      get_source_object;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAsyncResult> res, gpointer source_tag)>> is_tagged;
}

final class _GInputStreamClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> read_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream> stream,
              gsize count,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> skip;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> read_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> read_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream> stream,
              gsize count,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> skip_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> skip_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> close_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

final class _GFilterInputStreamClass extends ffi.Struct {
  external GInputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;
}

/// GInputStream:
///
/// Base class for streaming input operations.
typedef GInputStreamClass = _GInputStreamClass;

final class _GBufferedInputStreamClass extends ffi.Struct {
  external GFilterInputStreamClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GBufferedInputStream> stream,
              gssize count,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> fill;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GBufferedInputStream> stream,
              gssize count,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> fill_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GBufferedInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> fill_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GFilterInputStream:
///
/// A base class for all input streams that work on an underlying stream.
typedef GFilterInputStreamClass = _GFilterInputStreamClass;

final class _GOutputStreamClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> write_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GInputStream> source,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> splice;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> flush;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> write_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> write_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GInputStream> source,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> splice_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> splice_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> flush_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> flush_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> close_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GOutputVector> vectors,
              gsize n_vectors,
              ffi.Pointer<gsize> bytes_written,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> writev_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GOutputVector> vectors,
              gsize n_vectors,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> writev_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<gsize> bytes_written,
              ffi.Pointer<ffi.Pointer<GError>> error)>> writev_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved7;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved8;
}

final class _GFilterOutputStreamClass extends ffi.Struct {
  external GOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;
}

/// GOutputStream:
///
/// Base class for writing output.
///
/// All classes derived from GOutputStream should implement synchronous
/// writing, splicing, flushing and closing streams, but may implement
/// asynchronous versions.
typedef GOutputStreamClass = _GOutputStreamClass;

final class _GBufferedOutputStreamClass extends ffi.Struct {
  external GFilterOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;
}

/// GFilterOutputStream:
///
/// A base class for all output streams that work on an underlying stream.
typedef GFilterOutputStreamClass = _GFilterOutputStreamClass;

final class _GCancellableClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GCancellable> cancellable)>> cancelled;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GConverterIface:
/// @g_iface: The parent interface.
/// @convert: Converts data.
/// @reset: Reverts the internal state of the converter to its initial state.
///
/// Provides an interface for converting data from one type
/// to another type. The conversion can be stateful
/// and may fail at any place.
///
/// Since: 2.24
final class _GConverterIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GConverter> converter,
              ffi.Pointer<ffi.Void> inbuf,
              gsize inbuf_size,
              ffi.Pointer<ffi.Void> outbuf,
              gsize outbuf_size,
              ffi.Int32 flags,
              ffi.Pointer<gsize> bytes_read,
              ffi.Pointer<gsize> bytes_written,
              ffi.Pointer<ffi.Pointer<GError>> error)>> convert;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GConverter> converter)>>
      reset;
}

typedef GConverter = _GConverter;

final class _GCharsetConverterClass extends ffi.Struct {
  external GObjectClass parent_class;
}

final class _GConverterInputStreamClass extends ffi.Struct {
  external GFilterInputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

final class _GConverterOutputStreamClass extends ffi.Struct {
  external GFilterOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

final class _GCredentialsClass extends ffi.Opaque {}

/// GDatagramBasedInterface:
/// @g_iface: The parent interface.
/// @receive_messages: Virtual method for g_datagram_based_receive_messages().
/// @send_messages: Virtual method for g_datagram_based_send_messages().
/// @create_source: Virtual method for g_datagram_based_create_source().
/// @condition_check: Virtual method for g_datagram_based_condition_check().
/// @condition_wait: Virtual method for
/// g_datagram_based_condition_wait().
///
/// Provides an interface for socket-like objects which have datagram semantics,
/// following the Berkeley sockets API. The interface methods are thin wrappers
/// around the corresponding virtual methods, and no pre-processing of inputs is
/// implemented — so implementations of this API must handle all functionality
/// documented in the interface methods.
///
/// Since: 2.48
final class _GDatagramBasedInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          gint Function(
              ffi.Pointer<GDatagramBased> datagram_based,
              ffi.Pointer<GInputMessage> messages,
              guint num_messages,
              gint flags,
              gint64 timeout,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> receive_messages;

  external ffi.Pointer<
      ffi.NativeFunction<
          gint Function(
              ffi.Pointer<GDatagramBased> datagram_based,
              ffi.Pointer<GOutputMessage> messages,
              guint num_messages,
              gint flags,
              gint64 timeout,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> send_messages;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSource> Function(
              ffi.Pointer<GDatagramBased> datagram_based,
              ffi.Int32 condition,
              ffi.Pointer<GCancellable> cancellable)>> create_source;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GDatagramBased> datagram_based,
              ffi.Int32 condition)>> condition_check;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDatagramBased> datagram_based,
              ffi.Int32 condition,
              gint64 timeout,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> condition_wait;
}

typedef GDatagramBased = _GDatagramBased;

/// GInputMessage:
/// @address: (optional) (out) (transfer full): return location
/// for a #GSocketAddress, or %NULL
/// @vectors: (array length=num_vectors) (out): pointer to an
/// array of input vectors
/// @num_vectors: the number of input vectors pointed to by @vectors
/// @bytes_received: (out): will be set to the number of bytes that have been
/// received
/// @flags: (out): collection of #GSocketMsgFlags for the received message,
/// outputted by the call
/// @control_messages: (array length=num_control_messages) (optional)
/// (out) (transfer full): return location for a
/// caller-allocated array of #GSocketControlMessages, or %NULL
/// @num_control_messages: (out) (optional): return location for the number of
/// elements in @control_messages
///
/// Structure used for scatter/gather data input when receiving multiple
/// messages or packets in one go. You generally pass in an array of empty
/// #GInputVectors and the operation will use all the buffers as if they
/// were one buffer, and will set @bytes_received to the total number of bytes
/// received across all #GInputVectors.
///
/// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
/// the POSIX sockets API (see `man 2 recvmmsg`).
///
/// If @address is non-%NULL then it is set to the source address the message
/// was received from, and the caller must free it afterwards.
///
/// If @control_messages is non-%NULL then it is set to an array of control
/// messages received with the message (if any), and the caller must free it
/// afterwards. @num_control_messages is set to the number of elements in
/// this array, which may be zero.
///
/// Flags relevant to this message will be returned in @flags. For example,
/// `MSG_EOR` or `MSG_TRUNC`.
///
/// Since: 2.48
typedef GInputMessage = _GInputMessage;

/// GOutputMessage:
/// @address: (nullable): a #GSocketAddress, or %NULL
/// @vectors: pointer to an array of output vectors
/// @num_vectors: the number of output vectors pointed to by @vectors.
/// @bytes_sent: initialize to 0. Will be set to the number of bytes
/// that have been sent
/// @control_messages: (array length=num_control_messages) (nullable): a pointer
/// to an array of #GSocketControlMessages, or %NULL.
/// @num_control_messages: number of elements in @control_messages.
///
/// Structure used for scatter/gather data output when sending multiple
/// messages or packets in one go. You generally pass in an array of
/// #GOutputVectors and the operation will use all the buffers as if they
/// were one buffer.
///
/// If @address is %NULL then the message is sent to the default receiver
/// (as previously set by g_socket_connect()).
///
/// Since: 2.44
typedef GOutputMessage = _GOutputMessage;

final class _GDataInputStreamClass extends ffi.Struct {
  external GBufferedInputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GBufferedInputStream:
///
/// Implements #GFilterInputStream with a sized input buffer.
typedef GBufferedInputStreamClass = _GBufferedInputStreamClass;

final class _GDataOutputStream extends ffi.Struct {
  external GFilterOutputStream parent_instance;

  external ffi.Pointer<GDataOutputStreamPrivate> priv;
}

typedef GDataOutputStreamPrivate = _GDataOutputStreamPrivate;

final class _GDataOutputStreamPrivate extends ffi.Opaque {}

final class _GDataOutputStreamClass extends ffi.Struct {
  external GFilterOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GDBusInterfaceIface:
/// @parent_iface: The parent interface.
/// @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_get_info().
/// @get_object: Gets the enclosing #GDBusObject. See g_dbus_interface_get_object().
/// @set_object: Sets the enclosing #GDBusObject. See g_dbus_interface_set_object().
/// @dup_object: Gets a reference to the enclosing #GDBusObject. See g_dbus_interface_dup_object(). Added in 2.32.
///
/// Base type for D-Bus interfaces.
///
/// Since: 2.30
final class _GDBusInterfaceIface extends ffi.Struct {
  external GTypeInterface parent_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDBusInterfaceInfo> Function(
              ffi.Pointer<GDBusInterface> interface_)>> get_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDBusObject> Function(
              ffi.Pointer<GDBusInterface> interface_)>> get_object;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GDBusInterface> interface_,
              ffi.Pointer<GDBusObject> object)>> set_object;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDBusObject> Function(
              ffi.Pointer<GDBusInterface> interface_)>> dup_object;
}

typedef GDBusInterface = _GDBusInterface;
typedef GDBusObject = _GDBusObject;

/// GDBusInterfaceSkeletonClass:
/// @parent_class: The parent class.
/// @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details.
/// @get_vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details.
/// @get_properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties().
/// @flush: Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush().
/// @g_authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.
///
/// Class structure for #GDBusInterfaceSkeleton.
///
/// Since: 2.30
final class _GDBusInterfaceSkeletonClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDBusInterfaceInfo> Function(
              ffi.Pointer<GDBusInterfaceSkeleton> interface_)>> get_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDBusInterfaceVTable> Function(
              ffi.Pointer<GDBusInterfaceSkeleton> interface_)>> get_vtable;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVariant> Function(
              ffi.Pointer<GDBusInterfaceSkeleton> interface_)>> get_properties;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDBusInterfaceSkeleton> interface_)>> flush;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> vfunc_padding;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GDBusInterfaceSkeleton> interface_,
                  ffi.Pointer<GDBusMethodInvocation> invocation)>>
      g_authorize_method;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> signal_padding;
}

typedef GDBusInterfaceSkeleton = _GDBusInterfaceSkeleton;

final class _GDBusMenuModel extends ffi.Opaque {}

/// GDBusObjectIface:
/// @parent_iface: The parent interface.
/// @get_object_path: Returns the object path. See g_dbus_object_get_object_path().
/// @get_interfaces: Returns all interfaces. See g_dbus_object_get_interfaces().
/// @get_interface: Returns an interface by name. See g_dbus_object_get_interface().
/// @interface_added: Signal handler for the #GDBusObject::interface-added signal.
/// @interface_removed: Signal handler for the #GDBusObject::interface-removed signal.
///
/// Base object type for D-Bus objects.
///
/// Since: 2.30
final class _GDBusObjectIface extends ffi.Struct {
  external GTypeInterface parent_iface;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<gchar> Function(ffi.Pointer<GDBusObject> object)>>
      get_object_path;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GList> Function(ffi.Pointer<GDBusObject> object)>>
      get_interfaces;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDBusInterface> Function(ffi.Pointer<GDBusObject> object,
              ffi.Pointer<gchar> interface_name)>> get_interface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GDBusObject> object,
              ffi.Pointer<GDBusInterface> interface_)>> interface_added;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GDBusObject> object,
              ffi.Pointer<GDBusInterface> interface_)>> interface_removed;
}

/// GDBusObjectManagerIface:
/// @parent_iface: The parent interface.
/// @get_object_path: Virtual function for g_dbus_object_manager_get_object_path().
/// @get_objects: Virtual function for g_dbus_object_manager_get_objects().
/// @get_object: Virtual function for g_dbus_object_manager_get_object().
/// @get_interface: Virtual function for g_dbus_object_manager_get_interface().
/// @object_added: Signal handler for the #GDBusObjectManager::object-added signal.
/// @object_removed: Signal handler for the #GDBusObjectManager::object-removed signal.
/// @interface_added: Signal handler for the #GDBusObjectManager::interface-added signal.
/// @interface_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.
///
/// Base type for D-Bus object managers.
///
/// Since: 2.30
final class _GDBusObjectManagerIface extends ffi.Struct {
  external GTypeInterface parent_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(
              ffi.Pointer<GDBusObjectManager> manager)>> get_object_path;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GDBusObjectManager> manager)>> get_objects;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDBusObject> Function(
              ffi.Pointer<GDBusObjectManager> manager,
              ffi.Pointer<gchar> object_path)>> get_object;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDBusInterface> Function(
              ffi.Pointer<GDBusObjectManager> manager,
              ffi.Pointer<gchar> object_path,
              ffi.Pointer<gchar> interface_name)>> get_interface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GDBusObjectManager> manager,
              ffi.Pointer<GDBusObject> object)>> object_added;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GDBusObjectManager> manager,
              ffi.Pointer<GDBusObject> object)>> object_removed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDBusObjectManager> manager,
              ffi.Pointer<GDBusObject> object,
              ffi.Pointer<GDBusInterface> interface_)>> interface_added;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDBusObjectManager> manager,
              ffi.Pointer<GDBusObject> object,
              ffi.Pointer<GDBusInterface> interface_)>> interface_removed;
}

typedef GDBusObjectManager = _GDBusObjectManager;

/// GDBusObjectManagerClientClass:
/// @parent_class: The parent class.
/// @interface_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.
/// @interface_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.
///
/// Class structure for #GDBusObjectManagerClient.
///
/// Since: 2.30
final class _GDBusObjectManagerClientClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDBusObjectManagerClient> manager,
              ffi.Pointer<GDBusObjectProxy> object_proxy,
              ffi.Pointer<GDBusProxy> interface_proxy,
              ffi.Pointer<gchar> sender_name,
              ffi.Pointer<gchar> signal_name,
              ffi.Pointer<GVariant> parameters)>> interface_proxy_signal;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GDBusObjectManagerClient> manager,
                  ffi.Pointer<GDBusObjectProxy> object_proxy,
                  ffi.Pointer<GDBusProxy> interface_proxy,
                  ffi.Pointer<GVariant> changed_properties,
                  ffi.Pointer<ffi.Pointer<gchar>> invalidated_properties)>>
      interface_proxy_properties_changed;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> padding;
}

typedef GDBusObjectManagerClient = _GDBusObjectManagerClient;
typedef GDBusObjectProxy = _GDBusObjectProxy;
typedef GDBusProxy = _GDBusProxy;

/// GDBusObjectManagerServerClass:
/// @parent_class: The parent class.
///
/// Class structure for #GDBusObjectManagerServer.
///
/// Since: 2.30
final class _GDBusObjectManagerServerClass extends ffi.Struct {
  external GObjectClass parent_class;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> padding;
}

/// GDBusObjectProxyClass:
/// @parent_class: The parent class.
///
/// Class structure for #GDBusObjectProxy.
///
/// Since: 2.30
final class _GDBusObjectProxyClass extends ffi.Struct {
  external GObjectClass parent_class;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> padding;
}

/// GDBusObjectSkeletonClass:
/// @parent_class: The parent class.
/// @authorize_method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.
///
/// Class structure for #GDBusObjectSkeleton.
///
/// Since: 2.30
final class _GDBusObjectSkeletonClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDBusObjectSkeleton> object,
              ffi.Pointer<GDBusInterfaceSkeleton> interface_,
              ffi.Pointer<GDBusMethodInvocation> invocation)>> authorize_method;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> padding;
}

typedef GDBusObjectSkeleton = _GDBusObjectSkeleton;

/// GDBusProxyClass:
/// @g_properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal.
/// @g_signal: Signal class handler for the #GDBusProxy::g-signal signal.
///
/// Class structure for #GDBusProxy.
///
/// Since: 2.26
final class _GDBusProxyClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GDBusProxy> proxy,
                  ffi.Pointer<GVariant> changed_properties,
                  ffi.Pointer<ffi.Pointer<gchar>> invalidated_properties)>>
      g_properties_changed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDBusProxy> proxy,
              ffi.Pointer<gchar> sender_name,
              ffi.Pointer<gchar> signal_name,
              ffi.Pointer<GVariant> parameters)>> g_signal;

  @ffi.Array.multi([32])
  external ffi.Array<gpointer> padding;
}

final class _GDebugController extends ffi.Opaque {}

/// GDebugControllerInterface:
/// @g_iface: The parent interface.
///
/// The virtual function table for #GDebugController.
///
/// Since: 2.72
final class _GDebugControllerInterface extends ffi.Struct {
  external GTypeInterface g_iface;
}

final class _GDebugControllerDBus extends ffi.Struct {
  external GObject parent_instance;
}

/// GDebugControllerDBusClass:
/// @parent_class: The parent class.
/// @authorize: Default handler for the #GDebugControllerDBus::authorize signal.
///
/// The virtual function table for #GDebugControllerDBus.
///
/// Since: 2.72
final class _GDebugControllerDBusClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GDebugControllerDBus> controller,
              ffi.Pointer<GDBusMethodInvocation> invocation)>> authorize;

  @ffi.Array.multi([12])
  external ffi.Array<gpointer> padding;
}

typedef GDebugControllerDBus = _GDebugControllerDBus;

final class _GDriveIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GDrive> drive)>>
      changed;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GDrive> drive)>>
      disconnected;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GDrive> drive)>>
      eject_button;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<GDrive> drive)>> get_name;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GIcon> Function(ffi.Pointer<GDrive> drive)>> get_icon;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      has_volumes;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(ffi.Pointer<GDrive> drive)>> get_volumes;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      is_media_removable;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      has_media;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      is_media_check_automatic;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      can_eject;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      can_poll_for_media;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDrive> drive,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> eject;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDrive> drive,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> eject_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDrive> drive,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> poll_for_media;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDrive> drive,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> poll_for_media_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDrive> drive, ffi.Pointer<ffi.Char> kind)>>
      get_identifier;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<GDrive> drive)>> enumerate_identifiers;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GDrive> drive)>>
      get_start_stop_type;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      can_start;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      can_start_degraded;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDrive> drive,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> start;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDrive> drive,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> start_finish;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      can_stop;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDrive> drive,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> stop;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDrive> drive,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> stop_finish;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GDrive> drive)>>
      stop_button;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDrive> drive,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> eject_with_operation;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDrive> drive,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      eject_with_operation_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(ffi.Pointer<GDrive> drive)>> get_sort_key;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GIcon> Function(ffi.Pointer<GDrive> drive)>>
      get_symbolic_icon;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GDrive> drive)>>
      is_removable;
}

/// GDrive:
///
/// Opaque drive object.
typedef GDrive = _GDrive;
typedef GMountOperation = _GMountOperation;

/// GDtlsConnectionInterface:
/// @g_iface: The parent interface.
/// @accept_certificate: Check whether to accept a certificate.
/// @handshake: Perform a handshake operation.
/// @handshake_async: Start an asynchronous handshake operation.
/// @handshake_finish: Finish an asynchronous handshake operation.
/// @shutdown: Shut down one or both directions of the connection.
/// @shutdown_async: Start an asynchronous shutdown operation.
/// @shutdown_finish: Finish an asynchronous shutdown operation.
/// @set_advertised_protocols: Set APLN protocol list (Since: 2.60)
/// @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.60)
/// @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)
///
/// Virtual method table for a #GDtlsConnection implementation.
///
/// Since: 2.48
final class _GDtlsConnectionInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDtlsConnection> connection,
              ffi.Pointer<GTlsCertificate> peer_cert,
              ffi.Int32 errors)>> accept_certificate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDtlsConnection> conn,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> handshake;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDtlsConnection> conn,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> handshake_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDtlsConnection> conn,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> handshake_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDtlsConnection> conn,
              gboolean shutdown_read,
              gboolean shutdown_write,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> shutdown;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDtlsConnection> conn,
              gboolean shutdown_read,
              gboolean shutdown_write,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> shutdown_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDtlsConnection> conn,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> shutdown_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GDtlsConnection> conn,
                  ffi.Pointer<ffi.Pointer<gchar>> protocols)>>
      set_advertised_protocols;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<gchar> Function(ffi.Pointer<GDtlsConnection> conn)>>
      get_negotiated_protocol;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GDtlsConnection> conn,
              ffi.Int32 type,
              ffi.Pointer<GByteArray> data,
              ffi.Pointer<ffi.Pointer<GError>> error)>> get_binding_data;
}

typedef GDtlsConnection = _GDtlsConnection;
typedef GTlsCertificate = _GTlsCertificate;
typedef GByteArray = _GByteArray;

/// GDtlsClientConnectionInterface:
/// @g_iface: The parent interface.
///
/// vtable for a #GDtlsClientConnection implementation.
///
/// Since: 2.48
final class _GDtlsClientConnectionInterface extends ffi.Struct {
  external GTypeInterface g_iface;
}

/// GDtlsServerConnectionInterface:
/// @g_iface: The parent interface.
///
/// vtable for a #GDtlsServerConnection implementation.
///
/// Since: 2.48
final class _GDtlsServerConnectionInterface extends ffi.Struct {
  external GTypeInterface g_iface;
}

/// GIconIface:
/// @g_iface: The parent interface.
/// @hash: A hash for a given #GIcon.
/// @equal: Checks if two #GIcons are equal.
/// @to_tokens: Serializes a #GIcon into tokens. The tokens must not
/// contain any whitespace. Don't implement if the #GIcon can't be
/// serialized (Since 2.20).
/// @from_tokens: Constructs a #GIcon from tokens. Set the #GError if
/// the tokens are malformed. Don't implement if the #GIcon can't be
/// serialized (Since 2.20).
/// @serialize: Serializes a #GIcon into a #GVariant. Since: 2.38
///
/// GIconIface is used to implement GIcon types for various
/// different systems. See #GThemedIcon and #GLoadableIcon for
/// examples of how to implement this interface.
final class _GIconIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi
      .Pointer<ffi.NativeFunction<guint Function(ffi.Pointer<GIcon> icon)>>
      hash;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GIcon> icon1, ffi.Pointer<GIcon> icon2)>> equal;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GIcon> icon,
              ffi.Pointer<GPtrArray> tokens,
              ffi.Pointer<gint> out_version)>> to_tokens;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GIcon> Function(
              ffi.Pointer<ffi.Pointer<gchar>> tokens,
              gint num_tokens,
              gint version,
              ffi.Pointer<ffi.Pointer<GError>> error)>> from_tokens;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVariant> Function(ffi.Pointer<GIcon> icon)>> serialize;
}

typedef GPtrArray = _GPtrArray;

final class _GEmblem extends ffi.Opaque {}

final class _GEmblemClass extends ffi.Opaque {}

final class _GEmblemedIcon extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GEmblemedIconPrivate> priv;
}

typedef GEmblemedIconPrivate = _GEmblemedIconPrivate;

final class _GEmblemedIconPrivate extends ffi.Opaque {}

final class _GEmblemedIconClass extends ffi.Struct {
  external GObjectClass parent_class;
}

/// GFileIface:
/// @g_iface: The parent interface.
/// @dup: Duplicates a #GFile.
/// @hash: Creates a hash of a #GFile.
/// @equal: Checks equality of two given #GFiles.
/// @is_native: Checks to see if a file is native to the system.
/// @has_uri_scheme: Checks to see if a #GFile has a given URI scheme.
/// @get_uri_scheme: Gets the URI scheme for a #GFile.
/// @get_basename: Gets the basename for a given #GFile.
/// @get_path: Gets the current path within a #GFile.
/// @get_uri: Gets a URI for the path within a #GFile.
/// @get_parse_name: Gets the parsed name for the #GFile.
/// @get_parent: Gets the parent directory for the #GFile.
/// @prefix_matches: Checks whether a #GFile contains a specified file.
/// @get_relative_path: Gets the path for a #GFile relative to a given path.
/// @resolve_relative_path: Resolves a relative path for a #GFile to an absolute path.
/// @get_child_for_display_name: Gets the child #GFile for a given display name.
/// @enumerate_children: Gets a #GFileEnumerator with the children of a #GFile.
/// @enumerate_children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile.
/// @enumerate_children_finish: Finishes asynchronously enumerating the children.
/// @query_info: Gets the #GFileInfo for a #GFile.
/// @query_info_async: Asynchronously gets the #GFileInfo for a #GFile.
/// @query_info_finish: Finishes an asynchronous query info operation.
/// @query_filesystem_info: Gets a #GFileInfo for the file system #GFile is on.
/// @query_filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on.
/// @query_filesystem_info_finish: Finishes asynchronously getting the file system info.
/// @find_enclosing_mount: Gets a #GMount for the #GFile.
/// @find_enclosing_mount_async: Asynchronously gets the #GMount for a #GFile.
/// @find_enclosing_mount_finish: Finishes asynchronously getting the volume.
/// @set_display_name: Sets the display name for a #GFile.
/// @set_display_name_async: Asynchronously sets a #GFile's display name.
/// @set_display_name_finish: Finishes asynchronously setting a #GFile's display name.
/// @query_settable_attributes: Returns a list of #GFileAttributeInfos that can be set.
/// @_query_settable_attributes_async: Asynchronously gets a list of #GFileAttributeInfos that can be set.
/// @_query_settable_attributes_finish: Finishes asynchronously querying settable attributes.
/// @query_writable_namespaces: Returns a list of #GFileAttributeInfo namespaces that are writable.
/// @_query_writable_namespaces_async: Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.
/// @_query_writable_namespaces_finish: Finishes asynchronously querying the writable namespaces.
/// @set_attribute: Sets a #GFileAttributeInfo.
/// @set_attributes_from_info: Sets a #GFileAttributeInfo with information from a #GFileInfo.
/// @set_attributes_async: Asynchronously sets a file's attributes.
/// @set_attributes_finish: Finishes setting a file's attributes asynchronously.
/// @read_fn: Reads a file asynchronously.
/// @read_async: Asynchronously reads a file.
/// @read_finish: Finishes asynchronously reading a file.
/// @append_to: Writes to the end of a file.
/// @append_to_async: Asynchronously writes to the end of a file.
/// @append_to_finish: Finishes an asynchronous file append operation.
/// @create: Creates a new file.
/// @create_async: Asynchronously creates a file.
/// @create_finish: Finishes asynchronously creating a file.
/// @replace: Replaces the contents of a file.
/// @replace_async: Asynchronously replaces the contents of a file.
/// @replace_finish: Finishes asynchronously replacing a file.
/// @delete_file: Deletes a file.
/// @delete_file_async: Asynchronously deletes a file.
/// @delete_file_finish: Finishes an asynchronous delete.
/// @trash: Sends a #GFile to the Trash location.
/// @trash_async: Asynchronously sends a #GFile to the Trash location.
/// @trash_finish: Finishes an asynchronous file trashing operation.
/// @make_directory: Makes a directory.
/// @make_directory_async: Asynchronously makes a directory.
/// @make_directory_finish: Finishes making a directory asynchronously.
/// @make_symbolic_link: (nullable): Makes a symbolic link. %NULL if symbolic
/// links are unsupported.
/// @_make_symbolic_link_async: Asynchronously makes a symbolic link
/// @_make_symbolic_link_finish: Finishes making a symbolic link asynchronously.
/// @copy: (nullable): Copies a file. %NULL if copying is unsupported, which will
/// cause `GFile` to use a fallback copy method where it reads from the
/// source and writes to the destination.
/// @copy_async: Asynchronously copies a file.
/// @copy_finish: Finishes an asynchronous copy operation.
/// @move: Moves a file.
/// @move_async: Asynchronously moves a file. Since: 2.72
/// @move_finish: Finishes an asynchronous move operation. Since: 2.72
/// @mount_mountable: Mounts a mountable object.
/// @mount_mountable_finish: Finishes a mounting operation.
/// @unmount_mountable: Unmounts a mountable object.
/// @unmount_mountable_finish: Finishes an unmount operation.
/// @eject_mountable: Ejects a mountable.
/// @eject_mountable_finish: Finishes an eject operation.
/// @mount_enclosing_volume: Mounts a specified location.
/// @mount_enclosing_volume_finish: Finishes mounting a specified location.
/// @monitor_dir: Creates a #GFileMonitor for the location.
/// @monitor_file: Creates a #GFileMonitor for the location.
/// @open_readwrite: Open file read/write. Since 2.22.
/// @open_readwrite_async: Asynchronously opens file read/write. Since 2.22.
/// @open_readwrite_finish: Finishes an asynchronous open read/write. Since 2.22.
/// @create_readwrite: Creates file read/write. Since 2.22.
/// @create_readwrite_async: Asynchronously creates file read/write. Since 2.22.
/// @create_readwrite_finish: Finishes an asynchronous creates read/write. Since 2.22.
/// @replace_readwrite: Replaces file read/write. Since 2.22.
/// @replace_readwrite_async: Asynchronously replaces file read/write. Since 2.22.
/// @replace_readwrite_finish: Finishes an asynchronous replace read/write. Since 2.22.
/// @start_mountable: Starts a mountable object. Since 2.22.
/// @start_mountable_finish: Finishes a start operation. Since 2.22.
/// @stop_mountable: Stops a mountable. Since 2.22.
/// @stop_mountable_finish: Finishes a stop operation. Since 2.22.
/// @supports_thread_contexts: a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.
/// @unmount_mountable_with_operation: Unmounts a mountable object using a #GMountOperation. Since 2.22.
/// @unmount_mountable_with_operation_finish: Finishes an unmount operation using a #GMountOperation. Since 2.22.
/// @eject_mountable_with_operation: Ejects a mountable object using a #GMountOperation. Since 2.22.
/// @eject_mountable_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.
/// @poll_mountable: Polls a mountable object for media changes. Since 2.22.
/// @poll_mountable_finish: Finishes a poll operation for media changes. Since 2.22.
/// @measure_disk_usage: Recursively measures the disk usage of @file. Since 2.38
/// @measure_disk_usage_async: Asynchronously recursively measures the disk usage of @file. Since 2.38
/// @measure_disk_usage_finish: Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38
///
/// An interface for writing VFS file handles.
final class _GFileIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Pointer<GFile> Function(ffi.Pointer<GFile> file)>>
      dup;

  external ffi
      .Pointer<ffi.NativeFunction<guint Function(ffi.Pointer<GFile> file)>>
      hash;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file1, ffi.Pointer<GFile> file2)>> equal;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GFile> file)>>
      is_native;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GFile> file, ffi.Pointer<ffi.Char> uri_scheme)>>
      has_uri_scheme;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GFile> file)>>
      get_uri_scheme;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GFile> file)>>
      get_basename;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<GFile> file)>> get_path;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<GFile> file)>> get_uri;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GFile> file)>>
      get_parse_name;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Pointer<GFile> Function(ffi.Pointer<GFile> file)>>
      get_parent;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GFile> prefix, ffi.Pointer<GFile> file)>>
      prefix_matches;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GFile> parent, ffi.Pointer<GFile> descendant)>>
      get_relative_path;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFile> Function(ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> relative_path)>> resolve_relative_path;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<ffi.Char> display_name,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      get_child_for_display_name;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileEnumerator> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> enumerate_children;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> enumerate_children_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFileEnumerator> Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GAsyncResult> res,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      enumerate_children_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> query_info_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_filesystem_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> query_filesystem_info_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFileInfo> Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GAsyncResult> res,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      query_filesystem_info_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GMount> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> find_enclosing_mount;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> find_enclosing_mount_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GMount> Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GAsyncResult> res,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      find_enclosing_mount_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFile> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> display_name,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> set_display_name;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> display_name,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> set_display_name_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFile> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> set_display_name_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFileAttributeInfoList> Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      query_settable_attributes;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      _query_settable_attributes_async;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      _query_settable_attributes_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFileAttributeInfoList> Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      query_writable_namespaces;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      _query_writable_namespaces_async;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      _query_writable_namespaces_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> attribute,
              ffi.Int32 type,
              gpointer value_p,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> set_attribute;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GFileInfo> info,
                  ffi.Int32 flags,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      set_attributes_from_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GFileInfo> info,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> set_attributes_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GFileInfo>> info,
              ffi.Pointer<ffi.Pointer<GError>> error)>> set_attributes_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInputStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> read_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> read_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInputStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> read_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileOutputStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> append_to;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> append_to_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileOutputStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> append_to_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileOutputStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> create;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> create_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileOutputStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> create_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileOutputStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> etag,
              gboolean make_backup,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> replace;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> etag,
              gboolean make_backup,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> replace_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileOutputStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> replace_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> delete_file;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> delete_file_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> delete_file_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> trash;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> trash_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> trash_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> make_directory;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> make_directory_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> make_directory_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> symlink_value,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> make_symbolic_link;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      _make_symbolic_link_async;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      _make_symbolic_link_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> source,
              ffi.Pointer<GFile> destination,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GFileProgressCallback progress_callback,
              gpointer progress_callback_data,
              ffi.Pointer<ffi.Pointer<GError>> error)>> copy;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> source,
              ffi.Pointer<GFile> destination,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GFileProgressCallback progress_callback,
              gpointer progress_callback_data,
              GAsyncReadyCallback callback,
              gpointer user_data)>> copy_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> copy_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> source,
              ffi.Pointer<GFile> destination,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GFileProgressCallback progress_callback,
              gpointer progress_callback_data,
              ffi.Pointer<ffi.Pointer<GError>> error)>> move;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> source,
              ffi.Pointer<GFile> destination,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GFileProgressCallback progress_callback,
              gpointer progress_callback_data,
              GAsyncReadyCallback callback,
              gpointer user_data)>> move_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> move_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> mount_mountable;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFile> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> mount_mountable_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> unmount_mountable;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      unmount_mountable_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> eject_mountable;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> eject_mountable_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> location,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> mount_enclosing_volume;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GFile> location,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      mount_enclosing_volume_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileMonitor> Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> monitor_dir;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileMonitor> Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> monitor_file;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileIOStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> open_readwrite;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> open_readwrite_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileIOStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> open_readwrite_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileIOStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> create_readwrite;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> create_readwrite_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileIOStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<GError>> error)>> create_readwrite_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileIOStream> Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> etag,
              gboolean make_backup,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> replace_readwrite;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<ffi.Char> etag,
              gboolean make_backup,
              ffi.Int32 flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> replace_readwrite_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFileIOStream> Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GAsyncResult> res,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      replace_readwrite_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> start_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> start_mountable;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> start_mountable_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> stop_mountable;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> stop_mountable_finish;

  @gboolean()
  external int supports_thread_contexts;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> unmount_mountable_with_operation;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      unmount_mountable_with_operation_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> eject_mountable_with_operation;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      eject_mountable_with_operation_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> poll_mountable;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> poll_mountable_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GFileMeasureProgressCallback progress_callback,
              gpointer progress_data,
              ffi.Pointer<guint64> disk_usage,
              ffi.Pointer<guint64> num_dirs,
              ffi.Pointer<guint64> num_files,
              ffi.Pointer<ffi.Pointer<GError>> error)>> measure_disk_usage;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFile> file,
              ffi.Int32 flags,
              gint io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GFileMeasureProgressCallback progress_callback,
              gpointer progress_data,
              GAsyncReadyCallback callback,
              gpointer user_data)>> measure_disk_usage_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GFile> file,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<guint64> disk_usage,
                  ffi.Pointer<guint64> num_dirs,
                  ffi.Pointer<guint64> num_files,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      measure_disk_usage_finish;
}

typedef GFileEnumerator = _GFileEnumerator;
typedef GFileInfo = _GFileInfo;

/// GMount:
///
/// A handle to an object implementing the #GMountIface interface.
typedef GMount = _GMount;
typedef GFileAttributeInfoList = _GFileAttributeInfoList;
typedef GFileInputStream = _GFileInputStream;
typedef GFileOutputStream = _GFileOutputStream;

/// GFileProgressCallback:
/// @current_num_bytes: the current number of bytes in the operation.
/// @total_num_bytes: the total number of bytes in the operation.
/// @user_data: user data passed to the callback.
///
/// When doing file operations that may take a while, such as moving
/// a file or copying a file, a progress callback is used to pass how
/// far along that operation is to the application.
typedef GFileProgressCallback
    = ffi.Pointer<ffi.NativeFunction<GFileProgressCallbackFunction>>;
typedef GFileProgressCallbackFunction = ffi.Void Function(
    goffset current_num_bytes, goffset total_num_bytes, gpointer user_data);
typedef DartGFileProgressCallbackFunction = void Function(
    Dartgint64 current_num_bytes,
    Dartgint64 total_num_bytes,
    gpointer user_data);
typedef goffset = gint64;
typedef GFileMonitor = _GFileMonitor;
typedef GFileIOStream = _GFileIOStream;

/// GFileMeasureProgressCallback:
/// @reporting: %TRUE if more reports will come
/// @current_size: the current cumulative size measurement
/// @num_dirs: the number of directories visited so far
/// @num_files: the number of non-directory files encountered
/// @user_data: the data passed to the original request for this callback
///
/// This callback type is used by g_file_measure_disk_usage() to make
/// periodic progress reports when measuring the amount of disk spaced
/// used by a directory.
///
/// These calls are made on a best-effort basis and not all types of
/// #GFile will support them.  At the minimum, however, one call will
/// always be made immediately.
///
/// In the case that there is no support, @reporting will be set to
/// %FALSE (and the other values undefined) and no further calls will be
/// made.  Otherwise, the @reporting will be %TRUE and the other values
/// all-zeros during the first (immediate) call.  In this way, you can
/// know which type of progress UI to show without a delay.
///
/// For g_file_measure_disk_usage() the callback is made directly.  For
/// g_file_measure_disk_usage_async() the callback is made via the
/// default main context of the calling thread (ie: the same way that the
/// final async result would be reported).
///
/// @current_size is in the same units as requested by the operation (see
/// %G_FILE_MEASURE_APPARENT_SIZE).
///
/// The frequency of the updates is implementation defined, but is
/// ideally about once every 200ms.
///
/// The last progress callback may or may not be equal to the final
/// result.  Always check the async result to get the final value.
///
/// Since: 2.38
typedef GFileMeasureProgressCallback
    = ffi.Pointer<ffi.NativeFunction<GFileMeasureProgressCallbackFunction>>;
typedef GFileMeasureProgressCallbackFunction = ffi.Void Function(
    gboolean reporting,
    guint64 current_size,
    guint64 num_dirs,
    guint64 num_files,
    gpointer user_data);
typedef DartGFileMeasureProgressCallbackFunction = void Function(
    Dartgint reporting,
    Dartguint64 current_size,
    Dartguint64 num_dirs,
    Dartguint64 num_files,
    gpointer user_data);

final class _GFileEnumeratorClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileEnumerator> enumerator,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> next_file;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileEnumerator> enumerator,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileEnumerator> enumerator,
              ffi.Int num_files,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> next_files_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GFileEnumerator> enumerator,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> next_files_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileEnumerator> enumerator,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> close_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileEnumerator> enumerator,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved7;
}

final class _GFileIconClass extends ffi.Opaque {}

final class _GFileInfoClass extends ffi.Opaque {}

final class _GFileInputStreamClass extends ffi.Struct {
  external GInputStreamClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          goffset Function(ffi.Pointer<GFileInputStream> stream)>> tell;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GFileInputStream> stream)>> can_seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileInputStream> stream,
              goffset offset,
              ffi.Int32 type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileInputStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileInputStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> query_info_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

final class _GIOStreamClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GIOStream> stream)>> get_input_stream;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GOutputStream> Function(
              ffi.Pointer<GIOStream> stream)>> get_output_stream;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GIOStream> stream,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GIOStream> stream,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> close_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GIOStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved7;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved8;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved9;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved10;
}

final class _GFileIOStreamClass extends ffi.Struct {
  external GIOStreamClass parent_class;

  external ffi.Pointer<
          ffi
          .NativeFunction<goffset Function(ffi.Pointer<GFileIOStream> stream)>>
      tell;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GFileIOStream> stream)>>
      can_seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileIOStream> stream,
              goffset offset,
              ffi.Int32 type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> seek;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GFileIOStream> stream)>>
      can_truncate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileIOStream> stream,
              goffset size,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> truncate_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileIOStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileIOStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> query_info_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileIOStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GFileIOStream> stream)>> get_etag;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

typedef GIOStreamClass = _GIOStreamClass;

final class _GFileMonitorClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileMonitor> monitor,
              ffi.Pointer<GFile> file,
              ffi.Pointer<GFile> other_file,
              ffi.Int32 event_type)>> changed;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GFileMonitor> monitor)>>
      cancel;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

final class _GFilenameCompleterClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GFilenameCompleter> filename_completer)>>
      got_completion_data;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;
}

typedef GFilenameCompleter = _GFilenameCompleter;

final class _GFileOutputStreamClass extends ffi.Struct {
  external GOutputStreamClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          goffset Function(ffi.Pointer<GFileOutputStream> stream)>> tell;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GFileOutputStream> stream)>> can_seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileOutputStream> stream,
              goffset offset,
              ffi.Int32 type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> seek;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GFileOutputStream> stream)>>
      can_truncate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileOutputStream> stream,
              goffset size,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> truncate_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileOutputStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileOutputStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> query_info_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GFileOutputStream> stream)>> get_etag;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

final class _GInetAddressClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<gchar> Function(ffi.Pointer<GInetAddress> address)>>
      to_string;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<guint8> Function(ffi.Pointer<GInetAddress> address)>>
      to_bytes;
}

typedef GInetAddress = _GInetAddress;

final class _GInetAddressMaskClass extends ffi.Struct {
  external GObjectClass parent_class;
}

final class _GSocketAddressClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GSocketAddress> address)>> get_family;

  external ffi.Pointer<
          ffi
          .NativeFunction<gssize Function(ffi.Pointer<GSocketAddress> address)>>
      get_native_size;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GSocketAddress> address,
              gpointer dest,
              gsize destlen,
              ffi.Pointer<ffi.Pointer<GError>> error)>> to_native;
}

final class _GInetSocketAddressClass extends ffi.Struct {
  external GSocketAddressClass parent_class;
}

typedef GSocketAddressClass = _GSocketAddressClass;

/// GModuleFlags:
/// @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when
/// needed. The default action is to bind all symbols when the module
/// is loaded.
/// @G_MODULE_BIND_LOCAL: specifies that symbols in the module should
/// not be added to the global name space. The default action on most
/// platforms is to place symbols in the module in the global name space,
/// which may cause conflicts with existing symbols.
/// @G_MODULE_BIND_MASK: mask for all flags.
///
/// Flags passed to g_module_open().
/// Note that these flags are not supported on all platforms.
abstract class GModuleFlags {
  static const int G_MODULE_BIND_LAZY = 1;
  static const int G_MODULE_BIND_LOCAL = 2;
  static const int G_MODULE_BIND_MASK = 3;
}

final class _GModule extends ffi.Opaque {}

/// GModuleError:
/// @G_MODULE_ERROR_FAILED: there was an error loading or opening a module file
/// @G_MODULE_ERROR_CHECK_FAILED: a module returned an error from its `g_module_check_init()` function
///
/// Errors returned by g_module_open_full().
///
/// Since: 2.70
abstract class GModuleError {
  static const int G_MODULE_ERROR_FAILED = 0;
  static const int G_MODULE_ERROR_CHECK_FAILED = 1;
}

final class _GIOModuleScope extends ffi.Opaque {}

final class _GIOModuleClass extends ffi.Opaque {}

final class _GListModel extends ffi.Opaque {}

final class _GListModelInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi
      .Pointer<ffi.NativeFunction<GType Function(ffi.Pointer<GListModel> list)>>
      get_item_type;

  external ffi
      .Pointer<ffi.NativeFunction<guint Function(ffi.Pointer<GListModel> list)>>
      get_n_items;

  external ffi.Pointer<
          ffi.NativeFunction<
              gpointer Function(ffi.Pointer<GListModel> list, guint position)>>
      get_item;
}

typedef GListModel = _GListModel;

final class _GListStore extends ffi.Opaque {}

final class GListStoreClass extends ffi.Struct {
  external GObjectClass parent_class;
}

/// GLoadableIconIface:
/// @g_iface: The parent interface.
/// @load: Loads an icon.
/// @load_async: Loads an icon asynchronously.
/// @load_finish: Finishes an asynchronous icon load.
///
/// Interface for icons that can be loaded as a stream.
final class _GLoadableIconIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GLoadableIcon> icon,
              ffi.Int size,
              ffi.Pointer<ffi.Pointer<ffi.Char>> type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> load;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GLoadableIcon> icon,
              ffi.Int size,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> load_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GLoadableIcon> icon,
              ffi.Pointer<GAsyncResult> res,
              ffi.Pointer<ffi.Pointer<ffi.Char>> type,
              ffi.Pointer<ffi.Pointer<GError>> error)>> load_finish;
}

typedef GLoadableIcon = _GLoadableIcon;

final class _GMemoryInputStreamClass extends ffi.Struct {
  external GInputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

final class _GMemoryMonitor extends ffi.Opaque {}

final class _GMemoryMonitorInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GMemoryMonitor> monitor, ffi.Int32 level)>>
      low_memory_warning;
}

typedef GMemoryMonitor = _GMemoryMonitor;

final class _GMemoryOutputStreamClass extends ffi.Struct {
  external GOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GMenuModelClass::get_item_attributes:
/// @model: the #GMenuModel to query
/// @item_index: The #GMenuItem to query
/// @attributes: (out) (element-type utf8 GLib.Variant): Attributes on the item
///
/// Gets all the attributes associated with the item in the menu model.
/// /
/// /**
/// GMenuModelClass::get_item_links:
/// @model: the #GMenuModel to query
/// @item_index: The #GMenuItem to query
/// @links: (out) (element-type utf8 Gio.MenuModel): Links from the item
///
/// Gets all the links associated with the item in the menu model.
final class _GMenuModelClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GMenuModel> model)>>
      is_mutable;

  external ffi
      .Pointer<ffi.NativeFunction<gint Function(ffi.Pointer<GMenuModel> model)>>
      get_n_items;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GMenuModel> model, gint item_index,
                  ffi.Pointer<ffi.Pointer<GHashTable>> attributes)>>
      get_item_attributes;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GMenuAttributeIter> Function(
                  ffi.Pointer<GMenuModel> model, gint item_index)>>
      iterate_item_attributes;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GVariant> Function(
                  ffi.Pointer<GMenuModel> model,
                  gint item_index,
                  ffi.Pointer<gchar> attribute,
                  ffi.Pointer<GVariantType> expected_type)>>
      get_item_attribute_value;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GMenuModel> model, gint item_index,
              ffi.Pointer<ffi.Pointer<GHashTable>> links)>> get_item_links;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GMenuLinkIter> Function(
                  ffi.Pointer<GMenuModel> model, gint item_index)>>
      iterate_item_links;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GMenuModel> Function(ffi.Pointer<GMenuModel> model,
              gint item_index, ffi.Pointer<gchar> link)>> get_item_link;
}

typedef GMenuModel = _GMenuModel;
typedef GMenuAttributeIter = _GMenuAttributeIter;

final class _GMenuAttributeIter extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GMenuAttributeIterPrivate> priv;
}

typedef GMenuAttributeIterPrivate = _GMenuAttributeIterPrivate;

final class _GMenuAttributeIterPrivate extends ffi.Opaque {}

typedef GMenuLinkIter = _GMenuLinkIter;

final class _GMenuLinkIter extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GMenuLinkIterPrivate> priv;
}

typedef GMenuLinkIterPrivate = _GMenuLinkIterPrivate;

final class _GMenuLinkIterPrivate extends ffi.Opaque {}

final class _GMenuAttributeIterClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GMenuAttributeIter> iter,
              ffi.Pointer<ffi.Pointer<gchar>> out_name,
              ffi.Pointer<ffi.Pointer<GVariant>> value)>> get_next;
}

final class _GMenuLinkIterClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GMenuLinkIter> iter,
              ffi.Pointer<ffi.Pointer<gchar>> out_link,
              ffi.Pointer<ffi.Pointer<GMenuModel>> value)>> get_next;
}

final class _GMenuItem extends ffi.Opaque {}

final class _GMenu extends ffi.Opaque {}

/// GMountIface:
/// @g_iface: The parent interface.
/// @changed: Changed signal that is emitted when the mount's state has changed.
/// @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
/// @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
/// @get_root: Gets a #GFile to the root directory of the #GMount.
/// @get_name: Gets a string containing the name of the #GMount.
/// @get_icon: Gets a #GIcon for the #GMount.
/// @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.
/// @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.
/// @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.
/// @can_unmount: Checks if a #GMount can be unmounted.
/// @can_eject: Checks if a #GMount can be ejected.
/// @unmount: Starts unmounting a #GMount.
/// @unmount_finish: Finishes an unmounting operation.
/// @eject: Starts ejecting a #GMount.
/// @eject_finish: Finishes an eject operation.
/// @remount: Starts remounting a #GMount.
/// @remount_finish: Finishes a remounting operation.
/// @guess_content_type: Starts guessing the type of the content of a #GMount.
/// See g_mount_guess_content_type() for more information on content
/// type guessing. This operation was added in 2.18.
/// @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.
/// @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18
/// @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.
/// @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.
/// @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.
/// @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.
/// @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.
/// @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.
/// @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.
///
/// Interface for implementing operations for mounts.
final class _GMountIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GMount> mount)>>
      changed;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GMount> mount)>>
      unmounted;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFile> Function(ffi.Pointer<GMount> mount)>> get_root;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<GMount> mount)>> get_name;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GIcon> Function(ffi.Pointer<GMount> mount)>> get_icon;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<GMount> mount)>> get_uuid;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVolume> Function(ffi.Pointer<GMount> mount)>> get_volume;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDrive> Function(ffi.Pointer<GMount> mount)>> get_drive;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GMount> mount)>>
      can_unmount;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GMount> mount)>>
      can_eject;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMount> mount,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> unmount;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GMount> mount,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> unmount_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMount> mount,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> eject;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GMount> mount,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> eject_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMount> mount,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> remount;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GMount> mount,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> remount_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMount> mount,
              gboolean force_rescan,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> guess_content_type;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<gchar>> Function(
                  ffi.Pointer<GMount> mount,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      guess_content_type_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<gchar>> Function(
              ffi.Pointer<GMount> mount,
              gboolean force_rescan,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> guess_content_type_sync;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GMount> mount)>>
      pre_unmount;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMount> mount,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> unmount_with_operation;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GMount> mount,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      unmount_with_operation_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMount> mount,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> eject_with_operation;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GMount> mount,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      eject_with_operation_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(ffi.Pointer<GMount> mount)>>
      get_default_location;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(ffi.Pointer<GMount> mount)>> get_sort_key;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GIcon> Function(ffi.Pointer<GMount> mount)>>
      get_symbolic_icon;
}

/// GVolume:
///
/// Opaque mountable volume object.
typedef GVolume = _GVolume;

final class _GMountOperationClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMountOperation> op,
              ffi.Pointer<ffi.Char> message,
              ffi.Pointer<ffi.Char> default_user,
              ffi.Pointer<ffi.Char> default_domain,
              ffi.Int32 flags)>> ask_password;

  /// GMountOperationClass::ask_question:
  /// @op: a #GMountOperation
  /// @message: string containing a message to display to the user
  /// @choices: (array zero-terminated=1) (element-type utf8): an array of
  /// strings for each possible choice
  ///
  /// Virtual implementation of #GMountOperation::ask-question.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMountOperation> op,
              ffi.Pointer<ffi.Char> message,
              ffi.Pointer<ffi.Pointer<ffi.Char>> choices)>> ask_question;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMountOperation> op, ffi.Int32 result)>> reply;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GMountOperation> op)>>
      aborted;

  /// GMountOperationClass::show_processes:
  /// @op: a #GMountOperation
  /// @message: string containing a message to display to the user
  /// @processes: (element-type GPid): an array of #GPid for processes blocking
  /// the operation
  /// @choices: (array zero-terminated=1) (element-type utf8): an array of
  /// strings for each possible choice
  ///
  /// Virtual implementation of #GMountOperation::show-processes.
  ///
  /// Since: 2.22
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMountOperation> op,
              ffi.Pointer<gchar> message,
              ffi.Pointer<GArray> processes,
              ffi.Pointer<ffi.Pointer<gchar>> choices)>> show_processes;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMountOperation> op,
              ffi.Pointer<gchar> message,
              gint64 time_left,
              gint64 bytes_left)>> show_unmount_progress;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved7;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved8;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved9;
}

typedef GArray = _GArray;

final class _GNativeSocketAddressClass extends ffi.Struct {
  external GSocketAddressClass parent_class;
}

final class _GVolumeMonitorClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GVolume> volume)>> volume_added;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GVolume> volume)>> volume_removed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GVolume> volume)>> volume_changed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GMount> mount)>> mount_added;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GMount> mount)>> mount_removed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GMount> mount)>> mount_pre_unmount;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GMount> mount)>> mount_changed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GDrive> drive)>> drive_connected;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GDrive> drive)>> drive_disconnected;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GDrive> drive)>> drive_changed;

  external ffi.Pointer<ffi.NativeFunction<gboolean Function()>> is_supported;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GList> Function(
                  ffi.Pointer<GVolumeMonitor> volume_monitor)>>
      get_connected_drives;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GVolumeMonitor> volume_monitor)>> get_volumes;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GVolumeMonitor> volume_monitor)>> get_mounts;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVolume> Function(
              ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<ffi.Char> uuid)>> get_volume_for_uuid;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GMount> Function(
              ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<ffi.Char> uuid)>> get_mount_for_uuid;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GVolume> Function(ffi.Pointer<GMount> mount,
              ffi.Pointer<GVolumeMonitor> volume_monitor)>> adopt_orphan_mount;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GDrive> drive)>> drive_eject_button;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVolumeMonitor> volume_monitor,
              ffi.Pointer<GDrive> drive)>> drive_stop_button;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;
}

typedef GVolumeMonitor = _GVolumeMonitor;

final class _GNativeVolumeMonitor extends ffi.Struct {
  external GVolumeMonitor parent_instance;
}

final class _GNativeVolumeMonitorClass extends ffi.Struct {
  external GVolumeMonitorClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GMount> Function(ffi.Pointer<ffi.Char> mount_path,
              ffi.Pointer<GCancellable> cancellable)>> get_mount_for_mount_path;
}

/// GVolumeMonitor:
///
/// A Volume Monitor that watches for volume events.
typedef GVolumeMonitorClass = _GVolumeMonitorClass;

final class _GNetworkAddressClass extends ffi.Struct {
  external GObjectClass parent_class;
}

final class _GNetworkMonitorInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GNetworkMonitor> monitor,
              gboolean network_available)>> network_changed;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GNetworkMonitor> monitor,
              ffi.Pointer<GSocketConnectable> connectable,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> can_reach;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GNetworkMonitor> monitor,
              ffi.Pointer<GSocketConnectable> connectable,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> can_reach_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GNetworkMonitor> monitor,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> can_reach_finish;
}

typedef GNetworkMonitor = _GNetworkMonitor;
typedef GSocketConnectable = _GSocketConnectable;

final class _GNetworkServiceClass extends ffi.Struct {
  external GObjectClass parent_class;
}

final class _GPermissionClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GPermission> permission,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> acquire;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GPermission> permission,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> acquire_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GPermission> permission,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> acquire_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GPermission> permission,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> release;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GPermission> permission,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> release_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GPermission> permission,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> release_finish;

  @ffi.Array.multi([16])
  external ffi.Array<gpointer> reserved;
}

typedef GPermission = _GPermission;

/// GPollableInputStreamInterface:
/// @g_iface: The parent interface.
/// @can_poll: Checks if the #GPollableInputStream instance is actually pollable
/// @is_readable: Checks if the stream is readable
/// @create_source: Creates a #GSource to poll the stream
/// @read_nonblocking: Does a non-blocking read or returns
/// %G_IO_ERROR_WOULD_BLOCK
///
/// The interface for pollable input streams.
///
/// The default implementation of @can_poll always returns %TRUE.
///
/// The default implementation of @read_nonblocking calls
/// g_pollable_input_stream_is_readable(), and then calls
/// g_input_stream_read() if it returns %TRUE. This means you only need
/// to override it if it is possible that your @is_readable
/// implementation may return %TRUE when the stream is not actually
/// readable.
///
/// Since: 2.28
final class _GPollableInputStreamInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableInputStream> stream)>>
      can_poll;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableInputStream> stream)>>
      is_readable;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSource> Function(
              ffi.Pointer<GPollableInputStream> stream,
              ffi.Pointer<GCancellable> cancellable)>> create_source;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GPollableInputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Pointer<ffi.Pointer<GError>> error)>> read_nonblocking;
}

typedef GPollableInputStream = _GPollableInputStream;

/// GPollableOutputStreamInterface:
/// @g_iface: The parent interface.
/// @can_poll: Checks if the #GPollableOutputStream instance is actually pollable
/// @is_writable: Checks if the stream is writable
/// @create_source: Creates a #GSource to poll the stream
/// @write_nonblocking: Does a non-blocking write or returns
/// %G_IO_ERROR_WOULD_BLOCK
/// @writev_nonblocking: Does a vectored non-blocking write, or returns
/// %G_POLLABLE_RETURN_WOULD_BLOCK
///
/// The interface for pollable output streams.
///
/// The default implementation of @can_poll always returns %TRUE.
///
/// The default implementation of @write_nonblocking calls
/// g_pollable_output_stream_is_writable(), and then calls
/// g_output_stream_write() if it returns %TRUE. This means you only
/// need to override it if it is possible that your @is_writable
/// implementation may return %TRUE when the stream is not actually
/// writable.
///
/// The default implementation of @writev_nonblocking calls
/// g_pollable_output_stream_write_nonblocking() for each vector, and converts
/// its return value and error (if set) to a #GPollableReturn. You should
/// override this where possible to avoid having to allocate a #GError to return
/// %G_IO_ERROR_WOULD_BLOCK.
///
/// Since: 2.28
final class _GPollableOutputStreamInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableOutputStream> stream)>>
      can_poll;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableOutputStream> stream)>>
      is_writable;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSource> Function(
              ffi.Pointer<GPollableOutputStream> stream,
              ffi.Pointer<GCancellable> cancellable)>> create_source;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GPollableOutputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Pointer<ffi.Pointer<GError>> error)>> write_nonblocking;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GPollableOutputStream> stream,
              ffi.Pointer<GOutputVector> vectors,
              gsize n_vectors,
              ffi.Pointer<gsize> bytes_written,
              ffi.Pointer<ffi.Pointer<GError>> error)>> writev_nonblocking;
}

typedef GPollableOutputStream = _GPollableOutputStream;

final class _GPowerProfileMonitor extends ffi.Opaque {}

final class _GPowerProfileMonitorInterface extends ffi.Struct {
  external GTypeInterface g_iface;
}

/// GProxyInterface:
/// @g_iface: The parent interface.
/// @connect: Connect to proxy server and wrap (if required) the #connection
/// to handle payload.
/// @connect_async: Same as connect() but asynchronous.
/// @connect_finish: Returns the result of connect_async()
/// @supports_hostname: Returns whether the proxy supports hostname lookups.
///
/// Provides an interface for handling proxy connection and payload.
///
/// Since: 2.26
final class _GProxyInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GIOStream> Function(
              ffi.Pointer<GProxy> proxy,
              ffi.Pointer<GIOStream> connection,
              ffi.Pointer<GProxyAddress> proxy_address,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> connect;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GProxy> proxy,
              ffi.Pointer<GIOStream> connection,
              ffi.Pointer<GProxyAddress> proxy_address,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> connect_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GIOStream> Function(
              ffi.Pointer<GProxy> proxy,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> connect_finish;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GProxy> proxy)>>
      supports_hostname;
}

typedef GProxy = _GProxy;
typedef GProxyAddress = _GProxyAddress;

final class _GProxyAddressClass extends ffi.Struct {
  external GInetSocketAddressClass parent_class;
}

typedef GInetSocketAddressClass = _GInetSocketAddressClass;

/// GSocketAddressEnumeratorClass:
/// @next: Virtual method for g_socket_address_enumerator_next().
/// @next_async: Virtual method for g_socket_address_enumerator_next_async().
/// @next_finish: Virtual method for g_socket_address_enumerator_next_finish().
///
/// Class structure for #GSocketAddressEnumerator.
final class _GSocketAddressEnumeratorClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSocketAddress> Function(
              ffi.Pointer<GSocketAddressEnumerator> enumerator,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> next;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GSocketAddressEnumerator> enumerator,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> next_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSocketAddress> Function(
              ffi.Pointer<GSocketAddressEnumerator> enumerator,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> next_finish;
}

/// GProxyAddressEnumeratorClass:
///
/// Class structure for #GProxyAddressEnumerator.
final class _GProxyAddressEnumeratorClass extends ffi.Struct {
  external GSocketAddressEnumeratorClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved7;
}

/// GSocketAddressEnumerator:
///
/// Enumerator type for objects that contain or generate
/// #GSocketAddress instances.
typedef GSocketAddressEnumeratorClass = _GSocketAddressEnumeratorClass;

final class _GProxyResolverInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GProxyResolver> resolver)>>
      is_supported;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<gchar>> Function(
              ffi.Pointer<GProxyResolver> resolver,
              ffi.Pointer<gchar> uri,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GProxyResolver> resolver,
              ffi.Pointer<gchar> uri,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<gchar>> Function(
              ffi.Pointer<GProxyResolver> resolver,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup_finish;
}

/// GProxyResolver:
///
/// A helper class to enumerate proxies base on URI.
///
/// Since: 2.26
typedef GProxyResolver = _GProxyResolver;

final class _GRemoteActionGroupInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GRemoteActionGroup> remote,
              ffi.Pointer<gchar> action_name,
              ffi.Pointer<GVariant> parameter,
              ffi.Pointer<GVariant> platform_data)>> activate_action_full;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GRemoteActionGroup> remote,
              ffi.Pointer<gchar> action_name,
              ffi.Pointer<GVariant> value,
              ffi.Pointer<GVariant> platform_data)>> change_action_state_full;
}

typedef GRemoteActionGroup = _GRemoteActionGroup;

final class _GResolverClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GResolver> resolver)>>
      reload;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<gchar> hostname,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup_by_name;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<gchar> hostname,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_by_name_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup_by_name_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<GInetAddress> address,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup_by_address;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<GInetAddress> address,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_by_address_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<gchar> Function(
                  ffi.Pointer<GResolver> resolver,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_by_address_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<gchar> rrname,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup_service;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<gchar> rrname,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_service_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup_service_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<gchar> rrname,
              ffi.Int32 record_type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup_records;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<gchar> rrname,
              ffi.Int32 record_type,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_records_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GList> Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> lookup_records_finish;

  /// GResolverClass::lookup_by_name_with_flags_async:
  /// @resolver: a #GResolver
  /// @hostname: the hostname to resolve
  /// @flags: extra #GResolverNameLookupFlags to modify the lookup
  /// @cancellable: (nullable): a #GCancellable
  /// @callback: (scope async): a #GAsyncReadyCallback to call when completed
  /// @user_data: (closure): data to pass to @callback
  ///
  /// Asynchronous version of GResolverClass::lookup_by_name_with_flags
  ///
  /// GResolverClass::lookup_by_name_with_flags_finish will be called to get
  /// the result.
  ///
  /// Since: 2.60
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GResolver> resolver,
              ffi.Pointer<gchar> hostname,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_by_name_with_flags_async;

  /// GResolverClass::lookup_by_name_with_flags_finish:
  /// @resolver: a #GResolver
  /// @result: a #GAsyncResult
  /// @error: (nullable): a pointer to a %NULL #GError
  ///
  /// Gets the result from GResolverClass::lookup_by_name_with_flags_async
  ///
  /// Returns: (element-type GInetAddress) (transfer full): List of #GInetAddress.
  /// Since: 2.60
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GList> Function(
                  ffi.Pointer<GResolver> resolver,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_by_name_with_flags_finish;

  /// GResolverClass::lookup_by_name_with_flags:
  /// @resolver: a #GResolver
  /// @hostname: the hostname to resolve
  /// @flags: extra #GResolverNameLookupFlags to modify the lookup
  /// @cancellable: (nullable): a #GCancellable
  /// @error: (nullable): a pointer to a %NULL #GError
  ///
  /// This is identical to GResolverClass::lookup_by_name except it takes
  /// @flags which modifies the behavior of the lookup. See #GResolverNameLookupFlags
  /// for more details.
  ///
  /// Returns: (element-type GInetAddress) (transfer full): List of #GInetAddress.
  /// Since: 2.60
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GList> Function(
                  ffi.Pointer<GResolver> resolver,
                  ffi.Pointer<gchar> hostname,
                  ffi.Int32 flags,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_by_name_with_flags;
}

typedef GResolver = _GResolver;

/// GResolverNameLookupFlags:
/// @G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT: default behavior (same as g_resolver_lookup_by_name())
/// @G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY: only resolve ipv4 addresses
/// @G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY: only resolve ipv6 addresses
///
/// Flags to modify lookup behavior.
///
/// Since: 2.60
abstract class GResolverNameLookupFlags {
  static const int G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT = 0;
  static const int G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY = 1;
  static const int G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY = 2;
}

final class _GStaticResource extends ffi.Struct {
  external ffi.Pointer<guint8> data;

  @gsize()
  external int data_len;

  external ffi.Pointer<GResource> resource;

  external ffi.Pointer<GStaticResource> next;

  external gpointer padding;
}

/// GResource:
///
/// A resource bundle.
///
/// Since: 2.32
typedef GResource = _GResource;
typedef GStaticResource = _GStaticResource;

/// GSeekableIface:
/// @g_iface: The parent interface.
/// @tell: Tells the current location within a stream.
/// @can_seek: Checks if seeking is supported by the stream.
/// @seek: Seeks to a location within a stream.
/// @can_truncate: Checks if truncation is supported by the stream.
/// @truncate_fn: Truncates a stream.
///
/// Provides an interface for implementing seekable functionality on I/O Streams.
final class _GSeekableIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<goffset Function(ffi.Pointer<GSeekable> seekable)>>
      tell;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GSeekable> seekable)>>
      can_seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GSeekable> seekable,
              goffset offset,
              ffi.Int32 type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> seek;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GSeekable> seekable)>>
      can_truncate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GSeekable> seekable,
              goffset offset,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> truncate_fn;
}

typedef GSeekable = _GSeekable;

final class _GSettingsSchemaSource extends ffi.Opaque {}

final class _GSettingsSchema extends ffi.Opaque {}

final class _GSettingsSchemaKey extends ffi.Opaque {}

final class _GSettingsClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GSettings> settings, ffi.Pointer<gchar> key)>>
      writable_changed;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GSettings> settings, ffi.Pointer<gchar> key)>>
      changed;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GSettings> settings, GQuark key)>>
      writable_change_event;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GSettings> settings,
              ffi.Pointer<GQuark> keys, gint n_keys)>> change_event;

  @ffi.Array.multi([20])
  external ffi.Array<gpointer> padding;
}

typedef GSettings = _GSettings;

/// GSettingsBindFlags:
/// @G_SETTINGS_BIND_DEFAULT: Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
/// @G_SETTINGS_BIND_GET: Update the #GObject property when the setting changes.
/// It is an error to use this flag if the property is not writable.
/// @G_SETTINGS_BIND_SET: Update the setting when the #GObject property changes.
/// It is an error to use this flag if the property is not readable.
/// @G_SETTINGS_BIND_NO_SENSITIVITY: Do not try to bind a "sensitivity" property to the writability of the setting
/// @G_SETTINGS_BIND_GET_NO_CHANGES: When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property
/// value initially from the setting, but do not listen for changes of the setting
/// @G_SETTINGS_BIND_INVERT_BOOLEAN: When passed to g_settings_bind(), uses a pair of mapping functions that invert
/// the boolean value when mapping between the setting and the property.  The setting and property must both
/// be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().
///
/// Flags used when creating a binding. These flags determine in which
/// direction the binding works. The default is to synchronize in both
/// directions.
abstract class GSettingsBindFlags {
  static const int G_SETTINGS_BIND_DEFAULT = 0;
  static const int G_SETTINGS_BIND_GET = 1;
  static const int G_SETTINGS_BIND_SET = 2;
  static const int G_SETTINGS_BIND_NO_SENSITIVITY = 4;
  static const int G_SETTINGS_BIND_GET_NO_CHANGES = 8;
  static const int G_SETTINGS_BIND_INVERT_BOOLEAN = 16;
}

final class _GSimpleActionGroupClass extends ffi.Struct {
  external GObjectClass parent_class;

  @ffi.Array.multi([12])
  external ffi.Array<gpointer> padding;
}

final class _GSimpleAsyncResultClass extends ffi.Opaque {}

final class _GSimpleProxyResolver extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GSimpleProxyResolverPrivate> priv;
}

typedef GSimpleProxyResolverPrivate = _GSimpleProxyResolverPrivate;

final class _GSimpleProxyResolverPrivate extends ffi.Opaque {}

final class _GSimpleProxyResolverClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

final class _GSocketClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved7;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved8;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved9;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved10;
}

final class _GSocketClientClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GSocketClient> client,
              ffi.Int32 event,
              ffi.Pointer<GSocketConnectable> connectable,
              ffi.Pointer<GIOStream> connection)>> event;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;
}

/// GSocketClient:
///
/// A helper class for network clients to make connections.
///
/// Since: 2.22
typedef GSocketClient = _GSocketClient;

/// GSocketConnectableIface:
/// @g_iface: The parent interface.
/// @enumerate: Creates a #GSocketAddressEnumerator
/// @proxy_enumerate: Creates a #GProxyAddressEnumerator
/// @to_string: Format the connectable’s address as a string for debugging.
/// Implementing this is optional. (Since: 2.48)
///
/// Provides an interface for returning a #GSocketAddressEnumerator
/// and #GProxyAddressEnumerator
final class _GSocketConnectableIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSocketAddressEnumerator> Function(
              ffi.Pointer<GSocketConnectable> connectable)>> enumerate;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSocketAddressEnumerator> Function(
              ffi.Pointer<GSocketConnectable> connectable)>> proxy_enumerate;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(
              ffi.Pointer<GSocketConnectable> connectable)>> to_string;
}

final class _GSocketConnectionClass extends ffi.Struct {
  external GIOStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;
}

/// GSocketControlMessageClass:
/// @get_size: gets the size of the message.
/// @get_level: gets the protocol of the message.
/// @get_type: gets the protocol specific type of the message.
/// @serialize: Writes out the message data.
/// @deserialize: Tries to deserialize a message.
///
/// Class structure for #GSocketControlMessage.
final class _GSocketControlMessageClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gsize Function(ffi.Pointer<GSocketControlMessage> message)>> get_size;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<GSocketControlMessage> message)>>
      get_level;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<GSocketControlMessage> message)>>
      get_type;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GSocketControlMessage> message, gpointer data)>>
      serialize;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GSocketControlMessage> Function(
                  ffi.Int level, ffi.Int type, gsize size, gpointer data)>>
      deserialize;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GSocketListenerClass:
/// @changed: virtual method called when the set of socket listened to changes
///
/// Class structure for #GSocketListener.
final class _GSocketListenerClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSocketListener> listener)>> changed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSocketListener> listener,
              ffi.Int32 event, ffi.Pointer<GSocket> socket)>> event;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;
}

/// GSocket:
///
/// A lowlevel network socket object.
///
/// Since: 2.22
typedef GSocket = _GSocket;

/// GSocketServiceClass:
/// @incoming: signal emitted when new connections are accepted
///
/// Class structure for #GSocketService.
final class _GSocketServiceClass extends ffi.Struct {
  external GSocketListenerClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GSocketService> service,
              ffi.Pointer<GSocketConnection> connection,
              ffi.Pointer<GObject> source_object)>> incoming;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;
}

typedef GSocketListenerClass = _GSocketListenerClass;

final class _GTaskClass extends ffi.Opaque {}

final class _GTcpConnectionClass extends ffi.Struct {
  external GSocketConnectionClass parent_class;
}

typedef GSocketConnectionClass = _GSocketConnectionClass;

final class _GTcpWrapperConnectionClass extends ffi.Struct {
  external GTcpConnectionClass parent_class;
}

typedef GTcpConnectionClass = _GTcpConnectionClass;

final class _GThemedIconClass extends ffi.Opaque {}

final class _GThreadedSocketServiceClass extends ffi.Struct {
  external GSocketServiceClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GThreadedSocketService> service,
              ffi.Pointer<GSocketConnection> connection,
              ffi.Pointer<GObject> source_object)>> run;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

typedef GSocketServiceClass = _GSocketServiceClass;

/// GThreadedSocketService:
///
/// A helper class for handling accepting incoming connections in the
/// glib mainloop and handling them in a thread.
///
/// Since: 2.22
typedef GThreadedSocketService = _GThreadedSocketService;

final class _GTlsBackend extends ffi.Opaque {}

/// GTlsBackendInterface:
/// @g_iface: The parent interface.
/// @supports_tls: returns whether the backend supports TLS.
/// @supports_dtls: returns whether the backend supports DTLS
/// @get_default_database: returns a default #GTlsDatabase instance.
/// @get_certificate_type: returns the #GTlsCertificate implementation type
/// @get_client_connection_type: returns the #GTlsClientConnection implementation type
/// @get_server_connection_type: returns the #GTlsServerConnection implementation type
/// @get_file_database_type: returns the #GTlsFileDatabase implementation type.
/// @get_dtls_client_connection_type: returns the #GDtlsClientConnection implementation type
/// @get_dtls_server_connection_type: returns the #GDtlsServerConnection implementation type
///
/// Provides an interface for describing TLS-related types.
///
/// Since: 2.28
final class _GTlsBackendInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GTlsBackend> backend)>>
      supports_tls;

  external ffi.Pointer<ffi.NativeFunction<GType Function()>>
      get_certificate_type;

  external ffi.Pointer<ffi.NativeFunction<GType Function()>>
      get_client_connection_type;

  external ffi.Pointer<ffi.NativeFunction<GType Function()>>
      get_server_connection_type;

  external ffi.Pointer<ffi.NativeFunction<GType Function()>>
      get_file_database_type;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GTlsDatabase> Function(
              ffi.Pointer<GTlsBackend> backend)>> get_default_database;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GTlsBackend> backend)>>
      supports_dtls;

  external ffi.Pointer<ffi.NativeFunction<GType Function()>>
      get_dtls_client_connection_type;

  external ffi.Pointer<ffi.NativeFunction<GType Function()>>
      get_dtls_server_connection_type;
}

typedef GTlsBackend = _GTlsBackend;
typedef GTlsDatabase = _GTlsDatabase;

final class _GTlsCertificateClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GTlsCertificate> cert,
              ffi.Pointer<GSocketConnectable> identity,
              ffi.Pointer<GTlsCertificate> trusted_ca)>> verify;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> padding;
}

/// GTlsConnectionClass:
/// @parent_class: The parent class.
/// @accept_certificate: Check whether to accept a certificate.
/// @handshake: Perform a handshake operation.
/// @handshake_async: Start an asynchronous handshake operation.
/// @handshake_finish: Finish an asynchronous handshake operation.
/// @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)
/// @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)
///
/// The class structure for the #GTlsConnection type.
///
/// Since: 2.28
final class _GTlsConnectionClass extends ffi.Struct {
  external GIOStreamClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GTlsConnection> connection,
              ffi.Pointer<GTlsCertificate> peer_cert,
              ffi.Int32 errors)>> accept_certificate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GTlsConnection> conn,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> handshake;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GTlsConnection> conn,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> handshake_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GTlsConnection> conn,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> handshake_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GTlsConnection> conn,
              ffi.Int32 type,
              ffi.Pointer<GByteArray> data,
              ffi.Pointer<ffi.Pointer<GError>> error)>> get_binding_data;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<gchar> Function(ffi.Pointer<GTlsConnection> conn)>>
      get_negotiated_protocol;

  @ffi.Array.multi([6])
  external ffi.Array<gpointer> padding;
}

typedef GTlsConnection = _GTlsConnection;

/// GTlsClientConnectionInterface:
/// @g_iface: The parent interface.
/// @copy_session_state: Copies session state from one #GTlsClientConnection to another.
///
/// vtable for a #GTlsClientConnection implementation.
///
/// Since: 2.26
final class _GTlsClientConnectionInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GTlsClientConnection> conn,
              ffi.Pointer<GTlsClientConnection> source)>> copy_session_state;
}

typedef GTlsClientConnection = _GTlsClientConnection;

final class _GTlsDatabaseClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GTlsDatabase> self,
              ffi.Pointer<GTlsCertificate> chain,
              ffi.Pointer<gchar> purpose,
              ffi.Pointer<GSocketConnectable> identity,
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> verify_chain;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GTlsDatabase> self,
              ffi.Pointer<GTlsCertificate> chain,
              ffi.Pointer<gchar> purpose,
              ffi.Pointer<GSocketConnectable> identity,
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> verify_chain_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GTlsDatabase> self,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> verify_chain_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<gchar> Function(ffi.Pointer<GTlsDatabase> self,
                  ffi.Pointer<GTlsCertificate> certificate)>>
      create_certificate_handle;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GTlsCertificate> Function(
                  ffi.Pointer<GTlsDatabase> self,
                  ffi.Pointer<gchar> handle,
                  ffi.Pointer<GTlsInteraction> interaction,
                  ffi.Int32 flags,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_certificate_for_handle;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GTlsDatabase> self,
              ffi.Pointer<gchar> handle,
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_certificate_for_handle_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GTlsCertificate> Function(
                  ffi.Pointer<GTlsDatabase> self,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_certificate_for_handle_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GTlsCertificate> Function(
                  ffi.Pointer<GTlsDatabase> self,
                  ffi.Pointer<GTlsCertificate> certificate,
                  ffi.Pointer<GTlsInteraction> interaction,
                  ffi.Int32 flags,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_certificate_issuer;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GTlsDatabase> self,
              ffi.Pointer<GTlsCertificate> certificate,
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_certificate_issuer_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GTlsCertificate> Function(
                  ffi.Pointer<GTlsDatabase> self,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_certificate_issuer_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GList> Function(
                  ffi.Pointer<GTlsDatabase> self,
                  ffi.Pointer<GByteArray> issuer_raw_dn,
                  ffi.Pointer<GTlsInteraction> interaction,
                  ffi.Int32 flags,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_certificates_issued_by;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GTlsDatabase> self,
              ffi.Pointer<GByteArray> issuer_raw_dn,
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> lookup_certificates_issued_by_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GList> Function(
                  ffi.Pointer<GTlsDatabase> self,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      lookup_certificates_issued_by_finish;

  @ffi.Array.multi([16])
  external ffi.Array<gpointer> padding;
}

typedef GTlsInteraction = _GTlsInteraction;

/// GTlsFileDatabaseInterface:
/// @g_iface: The parent interface.
///
/// Provides an interface for #GTlsFileDatabase implementations.
final class _GTlsFileDatabaseInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> padding;
}

final class _GTlsInteractionClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Pointer<GTlsPassword> password,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> ask_password;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Pointer<GTlsPassword> password,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> ask_password_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> ask_password_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Pointer<GTlsConnection> connection,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> request_certificate;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GTlsInteraction> interaction,
              ffi.Pointer<GTlsConnection> connection,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> request_certificate_async;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<GTlsInteraction> interaction,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      request_certificate_finish;

  @ffi.Array.multi([21])
  external ffi.Array<gpointer> padding;
}

typedef GTlsPassword = _GTlsPassword;

/// GTlsPasswordClass:
/// @get_value: virtual method for g_tls_password_get_value()
/// @set_value: virtual method for g_tls_password_set_value()
/// @get_default_warning: virtual method for g_tls_password_get_warning() if no
/// value has been set using g_tls_password_set_warning()
///
/// Class structure for #GTlsPassword.
final class _GTlsPasswordClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<guchar> Function(ffi.Pointer<GTlsPassword> password,
              ffi.Pointer<gsize> length)>> get_value;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GTlsPassword> password,
              ffi.Pointer<guchar> value,
              gssize length,
              GDestroyNotify destroy)>> set_value;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<gchar> Function(ffi.Pointer<GTlsPassword> password)>>
      get_default_warning;

  @ffi.Array.multi([4])
  external ffi.Array<gpointer> padding;
}

/// GTlsServerConnectionInterface:
/// @g_iface: The parent interface.
///
/// vtable for a #GTlsServerConnection implementation.
///
/// Since: 2.26
final class _GTlsServerConnectionInterface extends ffi.Struct {
  external GTypeInterface g_iface;
}

final class _GVfsClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi
      .Pointer<ffi.NativeFunction<gboolean Function(ffi.Pointer<GVfs> vfs)>>
      is_active;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(
                  ffi.Pointer<GVfs> vfs, ffi.Pointer<ffi.Char> path)>>
      get_file_for_path;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(
                  ffi.Pointer<GVfs> vfs, ffi.Pointer<ffi.Char> uri)>>
      get_file_for_uri;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<gchar>> Function(ffi.Pointer<GVfs> vfs)>>
      get_supported_uri_schemes;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(
                  ffi.Pointer<GVfs> vfs, ffi.Pointer<ffi.Char> parse_name)>>
      parse_name;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GVfs> vfs,
                  ffi.Pointer<ffi.Char> filename,
                  guint64 device,
                  ffi.Pointer<GFileAttributeMatcher> attribute_matcher,
                  ffi.Pointer<GFileInfo> info,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<gpointer> extra_data,
                  ffi.Pointer<GDestroyNotify> free_extra_data)>>
      local_file_add_info;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GVfs> vfs,
                  ffi.Pointer<GFileAttributeInfoList> list)>>
      add_writable_namespaces;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GVfs> vfs,
                  ffi.Pointer<ffi.Char> filename,
                  ffi.Pointer<GFileInfo> info,
                  ffi.Int32 flags,
                  ffi.Pointer<GCancellable> cancellable,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      local_file_set_attributes;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GVfs> vfs, ffi.Pointer<ffi.Char> filename)>>
      local_file_removed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GVfs> vfs, ffi.Pointer<ffi.Char> source,
              ffi.Pointer<ffi.Char> dest)>> local_file_moved;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GIcon> Function(
                  ffi.Pointer<GVfs> vfs, ffi.Pointer<GVariant> value)>>
      deserialize_icon;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;
}

typedef GVfs = _GVfs;

/// GFileAttributeMatcher:
///
/// Determines if a string matches a file attribute.
typedef GFileAttributeMatcher = _GFileAttributeMatcher;

final class _GVolumeIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GVolume> volume)>>
      changed;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GVolume> volume)>>
      removed;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GVolume> volume)>>
      get_name;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GIcon> Function(ffi.Pointer<GVolume> volume)>> get_icon;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GVolume> volume)>>
      get_uuid;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GDrive> Function(ffi.Pointer<GVolume> volume)>> get_drive;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GMount> Function(ffi.Pointer<GVolume> volume)>> get_mount;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GVolume> volume)>>
      can_mount;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GVolume> volume)>>
      can_eject;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GVolume> volume,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> mount_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GVolume> volume,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> mount_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GVolume> volume,
              ffi.Int32 flags,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> eject;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GVolume> volume,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> eject_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GVolume> volume, ffi.Pointer<ffi.Char> kind)>>
      get_identifier;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<GVolume> volume)>> enumerate_identifiers;

  external ffi.Pointer<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GVolume> volume)>>
      should_automount;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GFile> Function(ffi.Pointer<GVolume> volume)>>
      get_activation_root;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GVolume> volume,
              ffi.Int32 flags,
              ffi.Pointer<GMountOperation> mount_operation,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> eject_with_operation;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GVolume> volume,
                  ffi.Pointer<GAsyncResult> result,
                  ffi.Pointer<ffi.Pointer<GError>> error)>>
      eject_with_operation_finish;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<gchar> Function(ffi.Pointer<GVolume> volume)>>
      get_sort_key;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GIcon> Function(ffi.Pointer<GVolume> volume)>>
      get_symbolic_icon;
}

final class _GZlibCompressorClass extends ffi.Struct {
  external GObjectClass parent_class;
}

final class _GZlibDecompressorClass extends ffi.Struct {
  external GObjectClass parent_class;
}

/// FlatpakError:
/// @FLATPAK_ERROR_ALREADY_INSTALLED: App/runtime/remote is already installed
/// @FLATPAK_ERROR_NOT_INSTALLED: App/runtime is not installed
/// @FLATPAK_ERROR_ONLY_PULLED: App/runtime was only pulled into the local
/// repository but not installed.
/// @FLATPAK_ERROR_DIFFERENT_REMOTE: The App/Runtime is already installed, but from a different remote.
/// @FLATPAK_ERROR_ABORTED: The transaction was aborted (returned %TRUE in operation-error signal).
/// @FLATPAK_ERROR_SKIPPED: The App/Runtime install was skipped due to earlier errors.
/// @FLATPAK_ERROR_NEED_NEW_FLATPAK: The App/Runtime needs a more recent version of flatpak.
/// @FLATPAK_ERROR_REMOTE_NOT_FOUND: The specified remote was not found.
/// @FLATPAK_ERROR_RUNTIME_NOT_FOUND: A runtime needed for the app was not found.
/// @FLATPAK_ERROR_DOWNGRADE: The pulled commit is a downgrade, and a downgrade wasn't
/// specifically allowed. (Since: 1.0)
/// @FLATPAK_ERROR_INVALID_REF: A ref could not be parsed. (Since: 1.0.3)
/// @FLATPAK_ERROR_INVALID_DATA: Invalid data. (Since: 1.0.3)
/// @FLATPAK_ERROR_UNTRUSTED: Missing GPG key or signature. (Since: 1.0.3)
/// @FLATPAK_ERROR_SETUP_FAILED: Sandbox setup failed. (Since: 1.0.3)
/// @FLATPAK_ERROR_EXPORT_FAILED: Exporting data failed. (Since: 1.0.3)
/// @FLATPAK_ERROR_REMOTE_USED: Remote can't be uninstalled. (Since: 1.0.3)
/// @FLATPAK_ERROR_RUNTIME_USED: Runtime can't be uninstalled. (Since: 1.0.3)
/// @FLATPAK_ERROR_INVALID_NAME: Application, runtime or remote name is invalid. (Since: 1.0.3)
/// @FLATPAK_ERROR_OUT_OF_SPACE: More disk space needed. (Since: 1.2.0)
/// @FLATPAK_ERROR_WRONG_USER: An operation is being attempted by the wrong user (such as
/// root operating on a user installation). (Since: 1.2.0)
/// @FLATPAK_ERROR_NOT_CACHED: Cached data was requested, but it was not available. (Since: 1.4.0)
/// @FLATPAK_ERROR_REF_NOT_FOUND: The specified ref was not found. (Since: 1.4.0)
/// @FLATPAK_ERROR_PERMISSION_DENIED: An operation was not allowed by the administrative policy.
/// For example, an app is not allowed to be installed due
/// to not complying with the parental controls policy. (Since: 1.5.1)
/// @FLATPAK_ERROR_AUTHENTICATION_FAILED: An authentication operation failed, for example, no
/// correct password was supplied. (Since: 1.7.3)
/// @FLATPAK_ERROR_NOT_AUTHORIZED: An operation tried to access a ref, or information about it that it
/// was not authorized. For example, when succesfully authenticating with a
/// server but the user doesn't have permissions for a private ref. (Since: 1.7.3)
///
/// Error codes for library functions.
abstract class FlatpakError {
  static const int FLATPAK_ERROR_ALREADY_INSTALLED = 0;
  static const int FLATPAK_ERROR_NOT_INSTALLED = 1;
  static const int FLATPAK_ERROR_ONLY_PULLED = 2;
  static const int FLATPAK_ERROR_DIFFERENT_REMOTE = 3;
  static const int FLATPAK_ERROR_ABORTED = 4;
  static const int FLATPAK_ERROR_SKIPPED = 5;
  static const int FLATPAK_ERROR_NEED_NEW_FLATPAK = 6;
  static const int FLATPAK_ERROR_REMOTE_NOT_FOUND = 7;
  static const int FLATPAK_ERROR_RUNTIME_NOT_FOUND = 8;
  static const int FLATPAK_ERROR_DOWNGRADE = 9;
  static const int FLATPAK_ERROR_INVALID_REF = 10;
  static const int FLATPAK_ERROR_INVALID_DATA = 11;
  static const int FLATPAK_ERROR_UNTRUSTED = 12;
  static const int FLATPAK_ERROR_SETUP_FAILED = 13;
  static const int FLATPAK_ERROR_EXPORT_FAILED = 14;
  static const int FLATPAK_ERROR_REMOTE_USED = 15;
  static const int FLATPAK_ERROR_RUNTIME_USED = 16;
  static const int FLATPAK_ERROR_INVALID_NAME = 17;
  static const int FLATPAK_ERROR_OUT_OF_SPACE = 18;
  static const int FLATPAK_ERROR_WRONG_USER = 19;
  static const int FLATPAK_ERROR_NOT_CACHED = 20;
  static const int FLATPAK_ERROR_REF_NOT_FOUND = 21;
  static const int FLATPAK_ERROR_PERMISSION_DENIED = 22;
  static const int FLATPAK_ERROR_AUTHENTICATION_FAILED = 23;
  static const int FLATPAK_ERROR_NOT_AUTHORIZED = 24;
}

/// FlatpakPortalError:
/// @FLATPAK_PORTAL_ERROR_FAILED: General portal failure
/// @FLATPAK_PORTAL_ERROR_INVALID_ARGUMENT: An argument was invalid
/// @FLATPAK_PORTAL_ERROR_NOT_FOUND: The object was not found
/// @FLATPAK_PORTAL_ERROR_EXISTS: The object already exists
/// @FLATPAK_PORTAL_ERROR_NOT_ALLOWED: The call was not allowed
/// @FLATPAK_PORTAL_ERROR_CANCELLED: The call was cancelled by the user
/// @FLATPAK_PORTAL_ERROR_WINDOW_DESTROYED: The window was destroyed by the user
///
/// Error codes returned by portal calls.
abstract class FlatpakPortalError {
  static const int FLATPAK_PORTAL_ERROR_FAILED = 0;
  static const int FLATPAK_PORTAL_ERROR_INVALID_ARGUMENT = 1;
  static const int FLATPAK_PORTAL_ERROR_NOT_FOUND = 2;
  static const int FLATPAK_PORTAL_ERROR_EXISTS = 3;
  static const int FLATPAK_PORTAL_ERROR_NOT_ALLOWED = 4;
  static const int FLATPAK_PORTAL_ERROR_CANCELLED = 5;
  static const int FLATPAK_PORTAL_ERROR_WINDOW_DESTROYED = 6;
}

final class _FlatpakRef extends ffi.Struct {
  external GObject parent;
}

final class FlatpakRefClass extends ffi.Struct {
  external GObjectClass parent_class;
}

/// FlatpakRefKind:
/// @FLATPAK_REF_KIND_APP: An application
/// @FLATPAK_REF_KIND_RUNTIME: A runtime that applications can use.
///
/// The kind of artifact that a FlatpakRef refers to.
abstract class FlatpakRefKind {
  static const int FLATPAK_REF_KIND_APP = 0;
  static const int FLATPAK_REF_KIND_RUNTIME = 1;
}

typedef FlatpakRef = _FlatpakRef;

final class _FlatpakInstalledRef extends ffi.Struct {
  external FlatpakRef parent;
}

final class FlatpakInstalledRefClass extends ffi.Struct {
  external FlatpakRefClass parent_class;
}

typedef FlatpakInstalledRef = _FlatpakInstalledRef;
typedef GBytes = _GBytes;

final class _FlatpakRemoteRef extends ffi.Struct {
  external FlatpakRef parent;
}

final class FlatpakRemoteRefClass extends ffi.Struct {
  external FlatpakRefClass parent_class;
}

typedef FlatpakRemoteRef = _FlatpakRemoteRef;

final class _FlatpakRelatedRef extends ffi.Struct {
  external FlatpakRef parent;
}

final class FlatpakRelatedRefClass extends ffi.Struct {
  external FlatpakRefClass parent_class;
}

typedef FlatpakRelatedRef = _FlatpakRelatedRef;

final class _FlatpakBundleRef extends ffi.Struct {
  external FlatpakRef parent;
}

final class FlatpakBundleRefClass extends ffi.Struct {
  external FlatpakRefClass parent_class;
}

typedef FlatpakBundleRef = _FlatpakBundleRef;

/// FlatpakRemoteType:
/// @FLATPAK_REMOTE_TYPE_STATIC: Statically configured remote
/// @FLATPAK_REMOTE_TYPE_USB: Dynamically detected local pathname remote
/// @FLATPAK_REMOTE_TYPE_LAN: Dynamically detected network remote
///
/// Different types of @FlatpakRemote.
abstract class FlatpakRemoteType {
  static const int FLATPAK_REMOTE_TYPE_STATIC = 0;
  static const int FLATPAK_REMOTE_TYPE_USB = 1;
  static const int FLATPAK_REMOTE_TYPE_LAN = 2;
}

final class _FlatpakRemote extends ffi.Struct {
  external GObject parent;
}

final class FlatpakRemoteClass extends ffi.Struct {
  external GObjectClass parent_class;
}

typedef FlatpakRemote = _FlatpakRemote;

final class _FlatpakInstallation extends ffi.Struct {
  external GObject parent;
}

final class _FlatpakInstance extends ffi.Struct {
  external GObject parent;
}

final class FlatpakInstanceClass extends ffi.Struct {
  external GObjectClass parent_class;
}

typedef FlatpakInstance = _FlatpakInstance;
typedef GKeyFile = _GKeyFile;

final class FlatpakInstallationClass extends ffi.Struct {
  external GObjectClass parent_class;
}

/// FlatpakUpdateFlags:
/// @FLATPAK_UPDATE_FLAGS_NONE: Fetch remote builds and install the latest one (default)
/// @FLATPAK_UPDATE_FLAGS_NO_DEPLOY: Don't install any new builds that might be fetched
/// @FLATPAK_UPDATE_FLAGS_NO_PULL: Don't try to fetch new builds from the remote repo
/// @FLATPAK_UPDATE_FLAGS_NO_STATIC_DELTAS: Don't use static deltas when pulling
/// @FLATPAK_UPDATE_FLAGS_NO_PRUNE: Don't prune the local OSTree repository after updating (Since: 0.11.8)
/// @FLATPAK_UPDATE_FLAGS_NO_TRIGGERS: Don't call triggers after updating. If used,
/// the caller must later call flatpak_installation_run_triggers() to update
/// the exported files. (Since: 1.0.3)
///
/// Flags to alter the behavior of flatpak_installation_update().
abstract class FlatpakUpdateFlags {
  static const int FLATPAK_UPDATE_FLAGS_NONE = 0;
  static const int FLATPAK_UPDATE_FLAGS_NO_DEPLOY = 1;
  static const int FLATPAK_UPDATE_FLAGS_NO_PULL = 2;
  static const int FLATPAK_UPDATE_FLAGS_NO_STATIC_DELTAS = 4;
  static const int FLATPAK_UPDATE_FLAGS_NO_PRUNE = 8;
  static const int FLATPAK_UPDATE_FLAGS_NO_TRIGGERS = 16;
}

/// FlatpakInstallFlags:
/// @FLATPAK_INSTALL_FLAGS_NONE: Default
/// @FLATPAK_INSTALL_FLAGS_NO_STATIC_DELTAS: Don't use static deltas when pulling
/// @FLATPAK_INSTALL_FLAGS_NO_DEPLOY: Don't install any new builds that might be fetched
/// @FLATPAK_INSTALL_FLAGS_NO_PULL: Don't try to fetch new builds from the remote repo
/// @FLATPAK_INSTALL_FLAGS_NO_TRIGGERS: Don't call triggers after installing. If used,
/// the caller must later call flatpak_installation_run_triggers() to update
/// the exported files. (Since: 1.0.3)
///
/// Flags to alter the behavior of flatpak_installation_install_full().
abstract class FlatpakInstallFlags {
  static const int FLATPAK_INSTALL_FLAGS_NONE = 0;
  static const int FLATPAK_INSTALL_FLAGS_NO_STATIC_DELTAS = 1;
  static const int FLATPAK_INSTALL_FLAGS_NO_DEPLOY = 4;
  static const int FLATPAK_INSTALL_FLAGS_NO_PULL = 8;
  static const int FLATPAK_INSTALL_FLAGS_NO_TRIGGERS = 16;
}

/// FlatpakUninstallFlags:
/// @FLATPAK_UNINSTALL_FLAGS_NONE: Default
/// @FLATPAK_UNINSTALL_FLAGS_NO_PRUNE: Don't prune the local OSTree repository after uninstalling
/// @FLATPAK_UNINSTALL_FLAGS_NO_TRIGGERS: Don't call triggers after uninstalling. If used,
/// the caller must later call flatpak_installation_run_triggers() to update
/// the exported file. (Since: 1.0.3)
///
/// Flags to alter the behavior of flatpak_installation_uninstall_full().
///
/// Since: 0.11.8
abstract class FlatpakUninstallFlags {
  static const int FLATPAK_UNINSTALL_FLAGS_NONE = 0;
  static const int FLATPAK_UNINSTALL_FLAGS_NO_PRUNE = 1;
  static const int FLATPAK_UNINSTALL_FLAGS_NO_TRIGGERS = 2;
}

/// FlatpakLaunchFlags:
/// @FLATPAK_LAUNCH_FLAGS_NONE: Default
/// @FLATPAK_LAUNCH_FLAGS_DO_NOT_REAP: Do not reap the child. Use this if you want to wait
/// for the child with g_child_watch_add(). (Since: 1.1)
///
/// Flags to alter the behavior of flatpak_installation_launch_full().
abstract class FlatpakLaunchFlags {
  static const int FLATPAK_LAUNCH_FLAGS_NONE = 0;
  static const int FLATPAK_LAUNCH_FLAGS_DO_NOT_REAP = 1;
}

/// FlatpakQueryFlags:
/// @FLATPAK_QUERY_FLAGS_NONE: Default
/// @FLATPAK_QUERY_FLAGS_ONLY_CACHED: Don't do any network i/o, but only return cached data.
/// This can return stale data, or a #FLATPAK_ERROR_NOT_CACHED error, however it is a
/// lot more efficient if you're doing many requests.
/// @FLATPAK_QUERY_FLAGS_ONLY_SIDELOADED: Only list refs available from sideload
/// repos; see flatpak(1). (Since: 1.7)
/// @FLATPAK_QUERY_FLAGS_ALL_ARCHES: Include refs from all arches, not just the primary ones. (Since: 1.11.2)
///
/// Flags to alter the behavior of e.g flatpak_installation_list_remote_refs_sync_full().
///
/// Since: 1.3.3
abstract class FlatpakQueryFlags {
  static const int FLATPAK_QUERY_FLAGS_NONE = 0;
  static const int FLATPAK_QUERY_FLAGS_ONLY_CACHED = 1;
  static const int FLATPAK_QUERY_FLAGS_ONLY_SIDELOADED = 2;
  static const int FLATPAK_QUERY_FLAGS_ALL_ARCHES = 4;
}

/// FlatpakStorageType:
/// @FLATPAK_STORAGE_TYPE_DEFAULT: default
/// @FLATPAK_STORAGE_TYPE_HARD_DISK: installation is on a hard disk
/// @FLATPAK_STORAGE_TYPE_SDCARD: installation is on a SD card
/// @FLATPAK_STORAGE_TYPE_MMC: installation is on an MMC
/// @FLATPAK_STORAGE_TYPE_NETWORK: installation is on the network
///
/// Information about the storage of an installation.
///
/// Since: 0.6.15
abstract class FlatpakStorageType {
  static const int FLATPAK_STORAGE_TYPE_DEFAULT = 0;
  static const int FLATPAK_STORAGE_TYPE_HARD_DISK = 1;
  static const int FLATPAK_STORAGE_TYPE_SDCARD = 2;
  static const int FLATPAK_STORAGE_TYPE_MMC = 3;
  static const int FLATPAK_STORAGE_TYPE_NETWORK = 4;
}

typedef FlatpakInstallation = _FlatpakInstallation;

/// FlatpakProgressCallback:
/// @status: A status string, suitable for display
/// @progress: percentage of completion
/// @estimating: whether @progress is just an estimate
/// @user_data: User data passed to the caller
///
/// The progress callback is called repeatedly during long-running operations
/// such as installations or updates, and can be used to update progress information
/// in a user interface.
///
/// The callback occurs in the thread-default context of the caller.
typedef FlatpakProgressCallback
    = ffi.Pointer<ffi.NativeFunction<FlatpakProgressCallbackFunction>>;
typedef FlatpakProgressCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char> status,
    guint progress,
    gboolean estimating,
    gpointer user_data);
typedef DartFlatpakProgressCallbackFunction = void Function(
    ffi.Pointer<ffi.Char> status,
    Dartguint progress,
    Dartgint estimating,
    gpointer user_data);

/// FlatpakTransactionOperationType
/// @FLATPAK_TRANSACTION_OPERATION_INSTALL: Install a ref from a remote
/// @FLATPAK_TRANSACTION_OPERATION_UPDATE: Update an installed ref
/// @FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE: Install a bundle from a file
/// @FLATPAK_TRANSACTION_OPERATION_UNINSTALL: Uninstall a ref
/// @FLATPAK_TRANSACTION_OPERATION_LAST_TYPE: The (currently) last operation type
///
/// The type of a #FlatpakTransactionOperation.
abstract class FlatpakTransactionOperationType {
  static const int FLATPAK_TRANSACTION_OPERATION_INSTALL = 0;
  static const int FLATPAK_TRANSACTION_OPERATION_UPDATE = 1;
  static const int FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE = 2;
  static const int FLATPAK_TRANSACTION_OPERATION_UNINSTALL = 3;
  static const int FLATPAK_TRANSACTION_OPERATION_LAST_TYPE = 4;
}

/// FlatpakTransactionErrorDetails
/// @FLATPAK_TRANSACTION_ERROR_DETAILS_NON_FATAL: The operation failure was not fatal
///
/// The details for #FlatpakTransaction::operation-error.
abstract class FlatpakTransactionErrorDetails {
  static const int FLATPAK_TRANSACTION_ERROR_DETAILS_NON_FATAL = 1;
}

/// FlatpakTransactionResult
/// @FLATPAK_TRANSACTION_RESULT_NO_CHANGE: The update caused no changes
///
/// The details for #FlatpakTransaction::operation-done.
abstract class FlatpakTransactionResult {
  static const int FLATPAK_TRANSACTION_RESULT_NO_CHANGE = 1;
}

/// FlatpakTransactionRemoteReason
/// @FLATPAK_TRANSACTION_REMOTE_GENERIC_REPO: The remote specified in the flatpakref has other apps too
/// @FLATPAK_TRANSACTION_REMOTE_RUNTIME_DEPS: The remote has runtimes needed for the app
///
/// The reason for #FlatpakTransaction::add-new-remote.
abstract class FlatpakTransactionRemoteReason {
  static const int FLATPAK_TRANSACTION_REMOTE_GENERIC_REPO = 0;
  static const int FLATPAK_TRANSACTION_REMOTE_RUNTIME_DEPS = 1;
}

final class _FlatpakTransactionProgress extends ffi.Opaque {}

final class FlatpakTransactionProgressClass extends ffi.Struct {
  external GObjectClass parent_class;
}

final class _FlatpakTransactionOperation extends ffi.Opaque {}

final class FlatpakTransactionOperationClass extends ffi.Struct {
  external GObjectClass parent_class;
}

final class _FlatpakTransaction extends ffi.Struct {
  external GObject parent_instance;
}

final class _FlatpakTransactionClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<FlatpakTransactionOperation> operation,
              ffi.Pointer<FlatpakTransactionProgress> progress)>> new_operation;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<FlatpakTransactionOperation> operation,
              ffi.Pointer<ffi.Char> commit,
              ffi.Int32 details)>> operation_done;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<FlatpakTransactionOperation> operation,
              ffi.Pointer<GError> error,
              ffi.Int32 detail)>> operation_error;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<FlatpakTransaction> transaction,
                  ffi.Pointer<ffi.Char> for_ref,
                  ffi.Pointer<ffi.Char> runtime_ref,
                  ffi.Pointer<ffi.Pointer<ffi.Char>> remotes)>>
      choose_remote_for_ref;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<ffi.Char> ref,
              ffi.Pointer<ffi.Char> reason,
              ffi.Pointer<ffi.Char> rebase)>> end_of_lifed;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<FlatpakTransaction> transaction)>>
      ready;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Int32 reason,
              ffi.Pointer<ffi.Char> from_id,
              ffi.Pointer<ffi.Char> remote_name,
              ffi.Pointer<ffi.Char> url)>> add_new_remote;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> run;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<FlatpakTransaction> transaction,
                  ffi.Pointer<ffi.Char> remote,
                  ffi.Pointer<ffi.Char> ref,
                  ffi.Pointer<ffi.Char> reason,
                  ffi.Pointer<ffi.Char> rebased_to_ref,
                  ffi.Pointer<ffi.Pointer<ffi.Char>> previous_ids)>>
      end_of_lifed_with_rebase;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<ffi.Char> remote,
              ffi.Pointer<ffi.Char> url,
              ffi.Pointer<GVariant> options,
              guint id)>> webflow_start;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<GVariant> options, guint id)>> webflow_done;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<ffi.Char> remote,
              ffi.Pointer<ffi.Char> realm,
              ffi.Pointer<GVariant> options,
              guint id)>> basic_auth_start;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FlatpakTransaction> transaction,
              ffi.Pointer<ffi.Char> remote,
              ffi.Pointer<ffi.Char> authenticator_ref)>> install_authenticator;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<FlatpakTransaction> transaction)>>
      ready_pre_auth;

  @ffi.Array.multi([3])
  external ffi.Array<gpointer> padding;
}

typedef FlatpakTransaction = _FlatpakTransaction;
typedef FlatpakTransactionOperation = _FlatpakTransactionOperation;
typedef FlatpakTransactionProgress = _FlatpakTransactionProgress;

const int SI_ASYNCNL = -60;

const int SI_DETHREAD = -7;

const int SI_TKILL = -6;

const int SI_SIGIO = -5;

const int SI_ASYNCIO = -4;

const int SI_MESGQ = -3;

const int SI_TIMER = -2;

const int SI_QUEUE = -1;

const int SI_USER = 0;

const int SI_KERNEL = 128;

const int ILL_ILLOPC = 1;

const int ILL_ILLOPN = 2;

const int ILL_ILLADR = 3;

const int ILL_ILLTRP = 4;

const int ILL_PRVOPC = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int ILL_BADIADDR = 9;

const int FPE_INTDIV = 1;

const int FPE_INTOVF = 2;

const int FPE_FLTDIV = 3;

const int FPE_FLTOVF = 4;

const int FPE_FLTUND = 5;

const int FPE_FLTRES = 6;

const int FPE_FLTINV = 7;

const int FPE_FLTSUB = 8;

const int FPE_FLTUNK = 14;

const int FPE_CONDTRAP = 15;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int SEGV_BNDERR = 3;

const int SEGV_PKUERR = 4;

const int SEGV_ACCADI = 5;

const int SEGV_ADIDERR = 6;

const int SEGV_ADIPERR = 7;

const int SEGV_MTEAERR = 8;

const int SEGV_MTESERR = 9;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int BUS_MCEERR_AR = 4;

const int BUS_MCEERR_AO = 5;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SIGEV_SIGNAL = 0;

const int SIGEV_NONE = 1;

const int SIGEV_THREAD = 2;

const int SIGEV_THREAD_ID = 4;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 2;

const int DT_UNKNOWN = 0;

const int DT_FIFO = 1;

const int DT_CHR = 2;

const int DT_DIR = 4;

const int DT_BLK = 6;

const int DT_REG = 8;

const int DT_LNK = 10;

const int DT_SOCK = 12;

const int DT_WHT = 14;

const int PTHREAD_CREATE_JOINABLE = 0;

const int PTHREAD_CREATE_DETACHED = 1;

const int PTHREAD_MUTEX_TIMED_NP = 0;

const int PTHREAD_MUTEX_RECURSIVE_NP = 1;

const int PTHREAD_MUTEX_ERRORCHECK_NP = 2;

const int PTHREAD_MUTEX_ADAPTIVE_NP = 3;

const int PTHREAD_MUTEX_NORMAL = 0;

const int PTHREAD_MUTEX_RECURSIVE = 1;

const int PTHREAD_MUTEX_ERRORCHECK = 2;

const int PTHREAD_MUTEX_DEFAULT = 0;

const int PTHREAD_MUTEX_STALLED = 0;

const int PTHREAD_MUTEX_STALLED_NP = 0;

const int PTHREAD_MUTEX_ROBUST = 1;

const int PTHREAD_MUTEX_ROBUST_NP = 1;

const int PTHREAD_PRIO_NONE = 0;

const int PTHREAD_PRIO_INHERIT = 1;

const int PTHREAD_PRIO_PROTECT = 2;

const int PTHREAD_RWLOCK_PREFER_READER_NP = 0;

const int PTHREAD_RWLOCK_PREFER_WRITER_NP = 1;

const int PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2;

const int PTHREAD_RWLOCK_DEFAULT_NP = 0;

const int PTHREAD_INHERIT_SCHED = 0;

const int PTHREAD_EXPLICIT_SCHED = 1;

const int PTHREAD_SCOPE_SYSTEM = 0;

const int PTHREAD_SCOPE_PROCESS = 1;

const int PTHREAD_PROCESS_PRIVATE = 0;

const int PTHREAD_PROCESS_SHARED = 1;

const int PTHREAD_CANCEL_ENABLE = 0;

const int PTHREAD_CANCEL_DISABLE = 1;

const int PTHREAD_CANCEL_DEFERRED = 0;

const int PTHREAD_CANCEL_ASYNCHRONOUS = 1;

const int _PC_LINK_MAX = 0;

const int _PC_MAX_CANON = 1;

const int _PC_MAX_INPUT = 2;

const int _PC_NAME_MAX = 3;

const int _PC_PATH_MAX = 4;

const int _PC_PIPE_BUF = 5;

const int _PC_CHOWN_RESTRICTED = 6;

const int _PC_NO_TRUNC = 7;

const int _PC_VDISABLE = 8;

const int _PC_SYNC_IO = 9;

const int _PC_ASYNC_IO = 10;

const int _PC_PRIO_IO = 11;

const int _PC_SOCK_MAXBUF = 12;

const int _PC_FILESIZEBITS = 13;

const int _PC_REC_INCR_XFER_SIZE = 14;

const int _PC_REC_MAX_XFER_SIZE = 15;

const int _PC_REC_MIN_XFER_SIZE = 16;

const int _PC_REC_XFER_ALIGN = 17;

const int _PC_ALLOC_SIZE_MIN = 18;

const int _PC_SYMLINK_MAX = 19;

const int _PC_2_SYMLINKS = 20;

const int _SC_ARG_MAX = 0;

const int _SC_CHILD_MAX = 1;

const int _SC_CLK_TCK = 2;

const int _SC_NGROUPS_MAX = 3;

const int _SC_OPEN_MAX = 4;

const int _SC_STREAM_MAX = 5;

const int _SC_TZNAME_MAX = 6;

const int _SC_JOB_CONTROL = 7;

const int _SC_SAVED_IDS = 8;

const int _SC_REALTIME_SIGNALS = 9;

const int _SC_PRIORITY_SCHEDULING = 10;

const int _SC_TIMERS = 11;

const int _SC_ASYNCHRONOUS_IO = 12;

const int _SC_PRIORITIZED_IO = 13;

const int _SC_SYNCHRONIZED_IO = 14;

const int _SC_FSYNC = 15;

const int _SC_MAPPED_FILES = 16;

const int _SC_MEMLOCK = 17;

const int _SC_MEMLOCK_RANGE = 18;

const int _SC_MEMORY_PROTECTION = 19;

const int _SC_MESSAGE_PASSING = 20;

const int _SC_SEMAPHORES = 21;

const int _SC_SHARED_MEMORY_OBJECTS = 22;

const int _SC_AIO_LISTIO_MAX = 23;

const int _SC_AIO_MAX = 24;

const int _SC_AIO_PRIO_DELTA_MAX = 25;

const int _SC_DELAYTIMER_MAX = 26;

const int _SC_MQ_OPEN_MAX = 27;

const int _SC_MQ_PRIO_MAX = 28;

const int _SC_VERSION = 29;

const int _SC_PAGESIZE = 30;

const int _SC_RTSIG_MAX = 31;

const int _SC_SEM_NSEMS_MAX = 32;

const int _SC_SEM_VALUE_MAX = 33;

const int _SC_SIGQUEUE_MAX = 34;

const int _SC_TIMER_MAX = 35;

const int _SC_BC_BASE_MAX = 36;

const int _SC_BC_DIM_MAX = 37;

const int _SC_BC_SCALE_MAX = 38;

const int _SC_BC_STRING_MAX = 39;

const int _SC_COLL_WEIGHTS_MAX = 40;

const int _SC_EQUIV_CLASS_MAX = 41;

const int _SC_EXPR_NEST_MAX = 42;

const int _SC_LINE_MAX = 43;

const int _SC_RE_DUP_MAX = 44;

const int _SC_CHARCLASS_NAME_MAX = 45;

const int _SC_2_VERSION = 46;

const int _SC_2_C_BIND = 47;

const int _SC_2_C_DEV = 48;

const int _SC_2_FORT_DEV = 49;

const int _SC_2_FORT_RUN = 50;

const int _SC_2_SW_DEV = 51;

const int _SC_2_LOCALEDEF = 52;

const int _SC_PII = 53;

const int _SC_PII_XTI = 54;

const int _SC_PII_SOCKET = 55;

const int _SC_PII_INTERNET = 56;

const int _SC_PII_OSI = 57;

const int _SC_POLL = 58;

const int _SC_SELECT = 59;

const int _SC_UIO_MAXIOV = 60;

const int _SC_IOV_MAX = 60;

const int _SC_PII_INTERNET_STREAM = 61;

const int _SC_PII_INTERNET_DGRAM = 62;

const int _SC_PII_OSI_COTS = 63;

const int _SC_PII_OSI_CLTS = 64;

const int _SC_PII_OSI_M = 65;

const int _SC_T_IOV_MAX = 66;

const int _SC_THREADS = 67;

const int _SC_THREAD_SAFE_FUNCTIONS = 68;

const int _SC_GETGR_R_SIZE_MAX = 69;

const int _SC_GETPW_R_SIZE_MAX = 70;

const int _SC_LOGIN_NAME_MAX = 71;

const int _SC_TTY_NAME_MAX = 72;

const int _SC_THREAD_DESTRUCTOR_ITERATIONS = 73;

const int _SC_THREAD_KEYS_MAX = 74;

const int _SC_THREAD_STACK_MIN = 75;

const int _SC_THREAD_THREADS_MAX = 76;

const int _SC_THREAD_ATTR_STACKADDR = 77;

const int _SC_THREAD_ATTR_STACKSIZE = 78;

const int _SC_THREAD_PRIORITY_SCHEDULING = 79;

const int _SC_THREAD_PRIO_INHERIT = 80;

const int _SC_THREAD_PRIO_PROTECT = 81;

const int _SC_THREAD_PROCESS_SHARED = 82;

const int _SC_NPROCESSORS_CONF = 83;

const int _SC_NPROCESSORS_ONLN = 84;

const int _SC_PHYS_PAGES = 85;

const int _SC_AVPHYS_PAGES = 86;

const int _SC_ATEXIT_MAX = 87;

const int _SC_PASS_MAX = 88;

const int _SC_XOPEN_VERSION = 89;

const int _SC_XOPEN_XCU_VERSION = 90;

const int _SC_XOPEN_UNIX = 91;

const int _SC_XOPEN_CRYPT = 92;

const int _SC_XOPEN_ENH_I18N = 93;

const int _SC_XOPEN_SHM = 94;

const int _SC_2_CHAR_TERM = 95;

const int _SC_2_C_VERSION = 96;

const int _SC_2_UPE = 97;

const int _SC_XOPEN_XPG2 = 98;

const int _SC_XOPEN_XPG3 = 99;

const int _SC_XOPEN_XPG4 = 100;

const int _SC_CHAR_BIT = 101;

const int _SC_CHAR_MAX = 102;

const int _SC_CHAR_MIN = 103;

const int _SC_INT_MAX = 104;

const int _SC_INT_MIN = 105;

const int _SC_LONG_BIT = 106;

const int _SC_WORD_BIT = 107;

const int _SC_MB_LEN_MAX = 108;

const int _SC_NZERO = 109;

const int _SC_SSIZE_MAX = 110;

const int _SC_SCHAR_MAX = 111;

const int _SC_SCHAR_MIN = 112;

const int _SC_SHRT_MAX = 113;

const int _SC_SHRT_MIN = 114;

const int _SC_UCHAR_MAX = 115;

const int _SC_UINT_MAX = 116;

const int _SC_ULONG_MAX = 117;

const int _SC_USHRT_MAX = 118;

const int _SC_NL_ARGMAX = 119;

const int _SC_NL_LANGMAX = 120;

const int _SC_NL_MSGMAX = 121;

const int _SC_NL_NMAX = 122;

const int _SC_NL_SETMAX = 123;

const int _SC_NL_TEXTMAX = 124;

const int _SC_XBS5_ILP32_OFF32 = 125;

const int _SC_XBS5_ILP32_OFFBIG = 126;

const int _SC_XBS5_LP64_OFF64 = 127;

const int _SC_XBS5_LPBIG_OFFBIG = 128;

const int _SC_XOPEN_LEGACY = 129;

const int _SC_XOPEN_REALTIME = 130;

const int _SC_XOPEN_REALTIME_THREADS = 131;

const int _SC_ADVISORY_INFO = 132;

const int _SC_BARRIERS = 133;

const int _SC_BASE = 134;

const int _SC_C_LANG_SUPPORT = 135;

const int _SC_C_LANG_SUPPORT_R = 136;

const int _SC_CLOCK_SELECTION = 137;

const int _SC_CPUTIME = 138;

const int _SC_THREAD_CPUTIME = 139;

const int _SC_DEVICE_IO = 140;

const int _SC_DEVICE_SPECIFIC = 141;

const int _SC_DEVICE_SPECIFIC_R = 142;

const int _SC_FD_MGMT = 143;

const int _SC_FIFO = 144;

const int _SC_PIPE = 145;

const int _SC_FILE_ATTRIBUTES = 146;

const int _SC_FILE_LOCKING = 147;

const int _SC_FILE_SYSTEM = 148;

const int _SC_MONOTONIC_CLOCK = 149;

const int _SC_MULTI_PROCESS = 150;

const int _SC_SINGLE_PROCESS = 151;

const int _SC_NETWORKING = 152;

const int _SC_READER_WRITER_LOCKS = 153;

const int _SC_SPIN_LOCKS = 154;

const int _SC_REGEXP = 155;

const int _SC_REGEX_VERSION = 156;

const int _SC_SHELL = 157;

const int _SC_SIGNALS = 158;

const int _SC_SPAWN = 159;

const int _SC_SPORADIC_SERVER = 160;

const int _SC_THREAD_SPORADIC_SERVER = 161;

const int _SC_SYSTEM_DATABASE = 162;

const int _SC_SYSTEM_DATABASE_R = 163;

const int _SC_TIMEOUTS = 164;

const int _SC_TYPED_MEMORY_OBJECTS = 165;

const int _SC_USER_GROUPS = 166;

const int _SC_USER_GROUPS_R = 167;

const int _SC_2_PBS = 168;

const int _SC_2_PBS_ACCOUNTING = 169;

const int _SC_2_PBS_LOCATE = 170;

const int _SC_2_PBS_MESSAGE = 171;

const int _SC_2_PBS_TRACK = 172;

const int _SC_SYMLOOP_MAX = 173;

const int _SC_STREAMS = 174;

const int _SC_2_PBS_CHECKPOINT = 175;

const int _SC_V6_ILP32_OFF32 = 176;

const int _SC_V6_ILP32_OFFBIG = 177;

const int _SC_V6_LP64_OFF64 = 178;

const int _SC_V6_LPBIG_OFFBIG = 179;

const int _SC_HOST_NAME_MAX = 180;

const int _SC_TRACE = 181;

const int _SC_TRACE_EVENT_FILTER = 182;

const int _SC_TRACE_INHERIT = 183;

const int _SC_TRACE_LOG = 184;

const int _SC_LEVEL1_ICACHE_SIZE = 185;

const int _SC_LEVEL1_ICACHE_ASSOC = 186;

const int _SC_LEVEL1_ICACHE_LINESIZE = 187;

const int _SC_LEVEL1_DCACHE_SIZE = 188;

const int _SC_LEVEL1_DCACHE_ASSOC = 189;

const int _SC_LEVEL1_DCACHE_LINESIZE = 190;

const int _SC_LEVEL2_CACHE_SIZE = 191;

const int _SC_LEVEL2_CACHE_ASSOC = 192;

const int _SC_LEVEL2_CACHE_LINESIZE = 193;

const int _SC_LEVEL3_CACHE_SIZE = 194;

const int _SC_LEVEL3_CACHE_ASSOC = 195;

const int _SC_LEVEL3_CACHE_LINESIZE = 196;

const int _SC_LEVEL4_CACHE_SIZE = 197;

const int _SC_LEVEL4_CACHE_ASSOC = 198;

const int _SC_LEVEL4_CACHE_LINESIZE = 199;

const int _SC_IPV6 = 235;

const int _SC_RAW_SOCKETS = 236;

const int _SC_V7_ILP32_OFF32 = 237;

const int _SC_V7_ILP32_OFFBIG = 238;

const int _SC_V7_LP64_OFF64 = 239;

const int _SC_V7_LPBIG_OFFBIG = 240;

const int _SC_SS_REPL_MAX = 241;

const int _SC_TRACE_EVENT_NAME_MAX = 242;

const int _SC_TRACE_NAME_MAX = 243;

const int _SC_TRACE_SYS_MAX = 244;

const int _SC_TRACE_USER_EVENT_MAX = 245;

const int _SC_XOPEN_STREAMS = 246;

const int _SC_THREAD_ROBUST_PRIO_INHERIT = 247;

const int _SC_THREAD_ROBUST_PRIO_PROTECT = 248;

const int _SC_MINSIGSTKSZ = 249;

const int _SC_SIGSTKSZ = 250;

const int _CS_PATH = 0;

const int _CS_V6_WIDTH_RESTRICTED_ENVS = 1;

const int _CS_GNU_LIBC_VERSION = 2;

const int _CS_GNU_LIBPTHREAD_VERSION = 3;

const int _CS_V5_WIDTH_RESTRICTED_ENVS = 4;

const int _CS_V7_WIDTH_RESTRICTED_ENVS = 5;

const int _CS_LFS_CFLAGS = 1000;

const int _CS_LFS_LDFLAGS = 1001;

const int _CS_LFS_LIBS = 1002;

const int _CS_LFS_LINTFLAGS = 1003;

const int _CS_LFS64_CFLAGS = 1004;

const int _CS_LFS64_LDFLAGS = 1005;

const int _CS_LFS64_LIBS = 1006;

const int _CS_LFS64_LINTFLAGS = 1007;

const int _CS_XBS5_ILP32_OFF32_CFLAGS = 1100;

const int _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101;

const int _CS_XBS5_ILP32_OFF32_LIBS = 1102;

const int _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103;

const int _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104;

const int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105;

const int _CS_XBS5_ILP32_OFFBIG_LIBS = 1106;

const int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107;

const int _CS_XBS5_LP64_OFF64_CFLAGS = 1108;

const int _CS_XBS5_LP64_OFF64_LDFLAGS = 1109;

const int _CS_XBS5_LP64_OFF64_LIBS = 1110;

const int _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111;

const int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112;

const int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113;

const int _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114;

const int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115;

const int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116;

const int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117;

const int _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118;

const int _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119;

const int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120;

const int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121;

const int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122;

const int _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123;

const int _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124;

const int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125;

const int _CS_POSIX_V6_LP64_OFF64_LIBS = 1126;

const int _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127;

const int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131;

const int _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132;

const int _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133;

const int _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134;

const int _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135;

const int _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136;

const int _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137;

const int _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138;

const int _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139;

const int _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140;

const int _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141;

const int _CS_POSIX_V7_LP64_OFF64_LIBS = 1142;

const int _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143;

const int _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144;

const int _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145;

const int _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146;

const int _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147;

const int _CS_V6_ENV = 1148;

const int _CS_V7_ENV = 1149;

const int NULL = 0;

const int g_macro__has_attribute = 0;

const int g_macro__has_feature = 0;

const int g_macro__has_builtin = 0;

const int g_macro__has_extension = 0;

const String G_GNUC_FUNCTION = '';

const String G_GNUC_PRETTY_FUNCTION = '';

const int G_ANALYZER_ANALYZING = 0;

const String G_STRLOC = '/tmp/CSRNRS/temp_for_macros.hpp:53';

const int FALSE = 0;

const int TRUE = 1;

const int _LIBC_LIMITS_H_ = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_60559_BFP__ = 201404;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_IEC_60559_COMPLEX__ = 201404;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 35;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int MB_LEN_MAX = 16;

const int SCHAR_MAX = 127;

const int SHRT_MAX = 32767;

const int INT_MAX = 2147483647;

const int LONG_MAX = 9223372036854775807;

const int SCHAR_MIN = -128;

const int SHRT_MIN = -32768;

const int INT_MIN = -2147483648;

const int LONG_MIN = -9223372036854775808;

const int UCHAR_MAX = 255;

const int USHRT_MAX = 65535;

const int UINT_MAX = 4294967295;

const int ULONG_MAX = -1;

const int CHAR_BIT = 8;

const int CHAR_MIN = -128;

const int CHAR_MAX = 127;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int _BITS_POSIX1_LIM_H = 1;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_RE_DUP_MAX = 255;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int NGROUPS_MAX = 65536;

const int MAX_CANON = 255;

const int MAX_INPUT = 255;

const int NAME_MAX = 255;

const int PATH_MAX = 4096;

const int PIPE_BUF = 4096;

const int XATTR_NAME_MAX = 255;

const int XATTR_SIZE_MAX = 65536;

const int XATTR_LIST_MAX = 65536;

const int RTSIG_MAX = 32;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int PTHREAD_KEYS_MAX = 1024;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int AIO_PRIO_DELTA_MAX = 20;

const int DELAYTIMER_MAX = 2147483647;

const int TTY_NAME_MAX = 32;

const int LOGIN_NAME_MAX = 256;

const int HOST_NAME_MAX = 64;

const int MQ_PRIO_MAX = 32768;

const int SEM_VALUE_MAX = 2147483647;

const int SSIZE_MAX = 9223372036854775807;

const int _BITS_POSIX2_LIM_H = 1;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int COLL_WEIGHTS_MAX = 255;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int CHARCLASS_NAME_MAX = 2048;

const int RE_DUP_MAX = 32767;

const int FLT_EVAL_METHOD = 0;

const int FLT_RADIX = 2;

const int FLT_MANT_DIG = 24;

const int DBL_MANT_DIG = 53;

const int LDBL_MANT_DIG = 64;

const int DECIMAL_DIG = 21;

const int FLT_DIG = 6;

const int DBL_DIG = 15;

const int LDBL_DIG = 18;

const int FLT_MIN_EXP = -125;

const int DBL_MIN_EXP = -1021;

const int LDBL_MIN_EXP = -16381;

const int FLT_MIN_10_EXP = -37;

const int DBL_MIN_10_EXP = -307;

const int LDBL_MIN_10_EXP = -4931;

const int FLT_MAX_EXP = 128;

const int DBL_MAX_EXP = 1024;

const int LDBL_MAX_EXP = 16384;

const int FLT_MAX_10_EXP = 38;

const int DBL_MAX_10_EXP = 308;

const int LDBL_MAX_10_EXP = 4932;

const double FLT_MAX = 3.4028234663852886e+38;

const double DBL_MAX = 1.7976931348623157e+308;

const double LDBL_MAX = double.infinity;

const double FLT_EPSILON = 1.1920928955078125e-7;

const double DBL_EPSILON = 2.220446049250313e-16;

const double LDBL_EPSILON = 1.0842021724855044e-19;

const double FLT_MIN = 1.1754943508222875e-38;

const double DBL_MIN = 2.2250738585072014e-308;

const double LDBL_MIN = 0.0;

const double FLT_TRUE_MIN = 1.401298464324817e-45;

const double DBL_TRUE_MIN = 5e-324;

const double LDBL_TRUE_MIN = 0.0;

const int FLT_DECIMAL_DIG = 9;

const int DBL_DECIMAL_DIG = 17;

const int LDBL_DECIMAL_DIG = 21;

const int FLT_HAS_SUBNORM = 1;

const int DBL_HAS_SUBNORM = 1;

const int LDBL_HAS_SUBNORM = 1;

const double G_MINFLOAT = 1.1754943508222875e-38;

const double G_MAXFLOAT = 3.4028234663852886e+38;

const double G_MINDOUBLE = 2.2250738585072014e-308;

const double G_MAXDOUBLE = 1.7976931348623157e+308;

const int G_MINSHORT = -32768;

const int G_MAXSHORT = 32767;

const int G_MAXUSHORT = 65535;

const int G_MININT = -2147483648;

const int G_MAXINT = 2147483647;

const int G_MAXUINT = 4294967295;

const int G_MINLONG = -9223372036854775808;

const int G_MAXLONG = 9223372036854775807;

const int G_MAXULONG = -1;

const String G_GINT16_MODIFIER = 'h';

const String G_GINT16_FORMAT = 'hi';

const String G_GUINT16_FORMAT = 'hu';

const String G_GINT32_MODIFIER = '';

const String G_GINT32_FORMAT = 'i';

const String G_GUINT32_FORMAT = 'u';

const int G_HAVE_GINT64 = 1;

const String G_GINT64_MODIFIER = 'l';

const String G_GINT64_FORMAT = 'li';

const String G_GUINT64_FORMAT = 'lu';

const int GLIB_SIZEOF_VOID_P = 8;

const int GLIB_SIZEOF_LONG = 8;

const int GLIB_SIZEOF_SIZE_T = 8;

const int GLIB_SIZEOF_SSIZE_T = 8;

const String G_GSIZE_MODIFIER = 'l';

const String G_GSSIZE_MODIFIER = 'l';

const String G_GSIZE_FORMAT = 'lu';

const String G_GSSIZE_FORMAT = 'li';

const int G_MAXSIZE = -1;

const int G_MINSSIZE = -9223372036854775808;

const int G_MAXSSIZE = 9223372036854775807;

const int G_MINOFFSET = -9223372036854775808;

const int G_MAXOFFSET = 9223372036854775807;

const String G_GOFFSET_MODIFIER = 'l';

const String G_GOFFSET_FORMAT = 'li';

const String G_POLLFD_FORMAT = '%d';

const String G_GINTPTR_MODIFIER = 'l';

const String G_GINTPTR_FORMAT = 'li';

const String G_GUINTPTR_FORMAT = 'lu';

const int GLIB_MAJOR_VERSION = 2;

const int GLIB_MINOR_VERSION = 72;

const int GLIB_MICRO_VERSION = 4;

const int G_VA_COPY_AS_ARRAY = 1;

const int G_HAVE_ISO_VARARGS = 1;

const int G_HAVE_GROWING_STACK = 0;

const int G_HAVE_GNUC_VISIBILITY = 1;

const int G_HAVE_GNUC_VARARGS = 1;

const int G_BYTE_ORDER = 1234;

const String G_MODULE_SUFFIX = 'so';

const String G_PID_FORMAT = 'i';

const int GLIB_SYSDEF_AF_UNIX = 1;

const int GLIB_SYSDEF_AF_INET = 2;

const int GLIB_SYSDEF_AF_INET6 = 10;

const int GLIB_SYSDEF_MSG_OOB = 1;

const int GLIB_SYSDEF_MSG_PEEK = 2;

const int GLIB_SYSDEF_MSG_DONTROUTE = 4;

const int G_DIR_SEPARATOR = 47;

const String G_DIR_SEPARATOR_S = '/';

const int G_SEARCHPATH_SEPARATOR = 58;

const String G_SEARCHPATH_SEPARATOR_S = ':';

const int GLIB_VERSION_2_26 = 137728;

const int GLIB_VERSION_2_28 = 138240;

const int GLIB_VERSION_2_30 = 138752;

const int GLIB_VERSION_2_32 = 139264;

const int GLIB_VERSION_2_34 = 139776;

const int GLIB_VERSION_2_36 = 140288;

const int GLIB_VERSION_2_38 = 140800;

const int GLIB_VERSION_2_40 = 141312;

const int GLIB_VERSION_2_42 = 141824;

const int GLIB_VERSION_2_44 = 142336;

const int GLIB_VERSION_2_46 = 142848;

const int GLIB_VERSION_2_48 = 143360;

const int GLIB_VERSION_2_50 = 143872;

const int GLIB_VERSION_2_52 = 144384;

const int GLIB_VERSION_2_54 = 144896;

const int GLIB_VERSION_2_56 = 145408;

const int GLIB_VERSION_2_58 = 145920;

const int GLIB_VERSION_2_60 = 146432;

const int GLIB_VERSION_2_62 = 146944;

const int GLIB_VERSION_2_64 = 147456;

const int GLIB_VERSION_2_66 = 147968;

const int GLIB_VERSION_2_68 = 148480;

const int GLIB_VERSION_2_70 = 148992;

const int GLIB_VERSION_2_72 = 149504;

const int GLIB_VERSION_CUR_STABLE = 149504;

const int GLIB_VERSION_PREV_STABLE = 148992;

const int GLIB_VERSION_MIN_REQUIRED = 149504;

const int GLIB_VERSION_MAX_ALLOWED = 149504;

const int _TIME_H = 1;

const int _BITS_TIME_H = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 1;

const int CLOCK_PROCESS_CPUTIME_ID = 2;

const int CLOCK_THREAD_CPUTIME_ID = 3;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_REALTIME_COARSE = 5;

const int CLOCK_MONOTONIC_COARSE = 6;

const int CLOCK_BOOTTIME = 7;

const int CLOCK_REALTIME_ALARM = 8;

const int CLOCK_BOOTTIME_ALARM = 9;

const int CLOCK_TAI = 11;

const int TIMER_ABSTIME = 1;

const int __clock_t_defined = 1;

const int __time_t_defined = 1;

const int __struct_tm_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int __clockid_t_defined = 1;

const int __timer_t_defined = 1;

const int __itimerspec_defined = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int TIME_UTC = 1;

const int G_MININT8 = -128;

const int G_MAXINT8 = 127;

const int G_MAXUINT8 = 255;

const int G_MININT16 = -32768;

const int G_MAXINT16 = 32767;

const int G_MAXUINT16 = 65535;

const int G_MININT32 = -2147483648;

const int G_MAXINT32 = 2147483647;

const int G_MAXUINT32 = 4294967295;

const int G_MININT64 = -9223372036854775808;

const int G_MAXINT64 = 9223372036854775807;

const int G_MAXUINT64 = -1;

const double G_E = 2.718281828459045;

const double G_LN2 = 0.6931471805599453;

const double G_LN10 = 2.302585092994046;

const double G_PI = 3.141592653589793;

const double G_PI_2 = 1.5707963267948966;

const double G_PI_4 = 0.7853981633974483;

const double G_SQRT2 = 1.4142135623730951;

const int G_LITTLE_ENDIAN = 1234;

const int G_BIG_ENDIAN = 4321;

const int G_PDP_ENDIAN = 3412;

const int G_IEEE754_FLOAT_BIAS = 127;

const int G_IEEE754_DOUBLE_BIAS = 1023;

const double G_LOG_2_BASE_10 = 0.3010299956639812;

const int _STRING_H = 1;

const int _STRINGS_H = 1;

const int __GNUC_VA_LIST = 1;

const String G_OS_INFO_KEY_NAME = 'NAME';

const String G_OS_INFO_KEY_PRETTY_NAME = 'PRETTY_NAME';

const String G_OS_INFO_KEY_VERSION = 'VERSION';

const String G_OS_INFO_KEY_VERSION_CODENAME = 'VERSION_CODENAME';

const String G_OS_INFO_KEY_VERSION_ID = 'VERSION_ID';

const String G_OS_INFO_KEY_ID = 'ID';

const String G_OS_INFO_KEY_HOME_URL = 'HOME_URL';

const String G_OS_INFO_KEY_DOCUMENTATION_URL = 'DOCUMENTATION_URL';

const String G_OS_INFO_KEY_SUPPORT_URL = 'SUPPORT_URL';

const String G_OS_INFO_KEY_BUG_REPORT_URL = 'BUG_REPORT_URL';

const String G_OS_INFO_KEY_PRIVACY_POLICY_URL = 'PRIVACY_POLICY_URL';

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int _BITS_STDINT_INTN_H = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _ALLOCA_H = 1;

const int _BITS_SIGNUM_GENERIC_H = 1;

const int SIGINT = 2;

const int SIGILL = 4;

const int SIGABRT = 6;

const int SIGFPE = 8;

const int SIGSEGV = 11;

const int SIGTERM = 15;

const int SIGHUP = 1;

const int SIGQUIT = 3;

const int SIGTRAP = 5;

const int SIGKILL = 9;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGIO = 29;

const int SIGIOT = 6;

const int SIGCLD = 17;

const int _BITS_SIGNUM_ARCH_H = 1;

const int SIGSTKFLT = 16;

const int SIGPWR = 30;

const int SIGBUS = 7;

const int SIGSYS = 31;

const int SIGURG = 23;

const int SIGSTOP = 19;

const int SIGTSTP = 20;

const int SIGCONT = 18;

const int SIGCHLD = 17;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGPOLL = 29;

const int SIGXFSZ = 25;

const int SIGXCPU = 24;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGUSR1 = 10;

const int SIGUSR2 = 12;

const int SIGWINCH = 28;

const int __SIGRTMIN = 32;

const int __SIGRTMAX = 64;

const int _NSIG = 65;

const int __sig_atomic_t_defined = 1;

const int __siginfo_t_defined = 1;

const int __SI_MAX_SIZE = 128;

const int __SI_PAD_SIZE = 28;

const int _BITS_SIGINFO_ARCH_H = 1;

const int __SI_ERRNO_THEN_CODE = 1;

const int __SI_HAVE_SIGSYS = 1;

const int _BITS_SIGINFO_CONSTS_H = 1;

const int __SI_ASYNCIO_AFTER_SIGIO = 1;

const int SI_ASYNCNL1 = -60;

const int SI_DETHREAD1 = -7;

const int SI_TKILL1 = -6;

const int SI_SIGIO1 = -5;

const int SI_ASYNCIO1 = -4;

const int SI_MESGQ1 = -3;

const int SI_TIMER1 = -2;

const int SI_QUEUE1 = -1;

const int SI_USER1 = 0;

const int SI_KERNEL1 = 128;

const int ILL_ILLOPC1 = 1;

const int ILL_ILLOPN1 = 2;

const int ILL_ILLADR1 = 3;

const int ILL_ILLTRP1 = 4;

const int ILL_PRVOPC1 = 5;

const int ILL_PRVREG1 = 6;

const int ILL_COPROC1 = 7;

const int ILL_BADSTK1 = 8;

const int ILL_BADIADDR1 = 9;

const int FPE_INTDIV1 = 1;

const int FPE_INTOVF1 = 2;

const int FPE_FLTDIV1 = 3;

const int FPE_FLTOVF1 = 4;

const int FPE_FLTUND1 = 5;

const int FPE_FLTRES1 = 6;

const int FPE_FLTINV1 = 7;

const int FPE_FLTSUB1 = 8;

const int FPE_FLTUNK1 = 14;

const int FPE_CONDTRAP1 = 15;

const int SEGV_MAPERR1 = 1;

const int SEGV_ACCERR1 = 2;

const int SEGV_BNDERR1 = 3;

const int SEGV_PKUERR1 = 4;

const int SEGV_ACCADI1 = 5;

const int SEGV_ADIDERR1 = 6;

const int SEGV_ADIPERR1 = 7;

const int SEGV_MTEAERR1 = 8;

const int SEGV_MTESERR1 = 9;

const int BUS_ADRALN1 = 1;

const int BUS_ADRERR1 = 2;

const int BUS_OBJERR1 = 3;

const int BUS_MCEERR_AR1 = 4;

const int BUS_MCEERR_AO1 = 5;

const int CLD_EXITED1 = 1;

const int CLD_KILLED1 = 2;

const int CLD_DUMPED1 = 3;

const int CLD_TRAPPED1 = 4;

const int CLD_STOPPED1 = 5;

const int CLD_CONTINUED1 = 6;

const int POLL_IN1 = 1;

const int POLL_OUT1 = 2;

const int POLL_MSG1 = 3;

const int POLL_ERR1 = 4;

const int POLL_PRI1 = 5;

const int POLL_HUP1 = 6;

const int __sigevent_t_defined = 1;

const int __SIGEV_MAX_SIZE = 64;

const int __SIGEV_PAD_SIZE = 12;

const int _BITS_SIGEVENT_CONSTS_H = 1;

const int SIGEV_SIGNAL1 = 0;

const int SIGEV_NONE1 = 1;

const int SIGEV_THREAD1 = 2;

const int SIGEV_THREAD_ID1 = 4;

const int NSIG = 65;

const int _BITS_SIGACTION_H = 1;

const int SA_NOCLDSTOP = 1;

const int SA_NOCLDWAIT = 2;

const int SA_SIGINFO = 4;

const int SA_ONSTACK = 134217728;

const int SA_RESTART = 268435456;

const int SA_NODEFER = 1073741824;

const int SA_RESETHAND = 2147483648;

const int SA_INTERRUPT = 536870912;

const int SA_NOMASK = 1073741824;

const int SA_ONESHOT = 2147483648;

const int SA_STACK = 134217728;

const int SIG_BLOCK = 0;

const int SIG_UNBLOCK = 1;

const int SIG_SETMASK = 2;

const int _BITS_SIGCONTEXT_H = 1;

const int FP_XSTATE_MAGIC1 = 1179670611;

const int FP_XSTATE_MAGIC2 = 1179670597;

const int FP_XSTATE_MAGIC2_SIZE = 4;

const int __stack_t_defined = 1;

const int _SYS_UCONTEXT_H = 1;

const int __NGREG = 23;

const int NGREG = 23;

const int _BITS_SIGSTACK_H = 1;

const int _BITS_SS_FLAGS_H = 1;

const int SS_ONSTACK1 = 1;

const int SS_DISABLE1 = 2;

const int __sigstack_defined = 1;

const int _BITS_SIGTHREAD_H = 1;

const int G_TIME_SPAN_DAY = 86400000000;

const int G_TIME_SPAN_HOUR = 3600000000;

const int G_TIME_SPAN_MINUTE = 60000000;

const int G_TIME_SPAN_SECOND = 1000000;

const int G_TIME_SPAN_MILLISECOND = 1000;

const int G_DATALIST_FLAGS_MASK = 3;

const int G_DATE_BAD_JULIAN = 0;

const int G_DATE_BAD_DAY = 0;

const int G_DATE_BAD_YEAR = 0;

const int _DIRENT_H = 1;

const int _DIRENT_MATCHES_DIRENT64 = 1;

const int DT_UNKNOWN1 = 0;

const int DT_FIFO1 = 1;

const int DT_CHR1 = 2;

const int DT_DIR1 = 4;

const int DT_BLK1 = 6;

const int DT_REG1 = 8;

const int DT_LNK1 = 10;

const int DT_SOCK1 = 12;

const int DT_WHT1 = 14;

const int MAXNAMLEN = 255;

const int G_MEM_ALIGN = 8;

const int G_HOOK_FLAG_USER_SHIFT = 4;

const int G_PRIORITY_HIGH = -100;

const int G_PRIORITY_DEFAULT = 0;

const int G_PRIORITY_HIGH_IDLE = 100;

const int G_PRIORITY_DEFAULT_IDLE = 200;

const int G_PRIORITY_LOW = 300;

const int G_SOURCE_REMOVE = 0;

const int G_SOURCE_CONTINUE = 1;

const int G_UNICODE_COMBINING_MARK = 10;

const int G_UNICHAR_MAX_DECOMPOSITION_LENGTH = 18;

const String G_KEY_FILE_DESKTOP_GROUP = 'Desktop Entry';

const String G_KEY_FILE_DESKTOP_KEY_TYPE = 'Type';

const String G_KEY_FILE_DESKTOP_KEY_VERSION = 'Version';

const String G_KEY_FILE_DESKTOP_KEY_NAME = 'Name';

const String G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME = 'GenericName';

const String G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY = 'NoDisplay';

const String G_KEY_FILE_DESKTOP_KEY_COMMENT = 'Comment';

const String G_KEY_FILE_DESKTOP_KEY_ICON = 'Icon';

const String G_KEY_FILE_DESKTOP_KEY_HIDDEN = 'Hidden';

const String G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN = 'OnlyShowIn';

const String G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN = 'NotShowIn';

const String G_KEY_FILE_DESKTOP_KEY_TRY_EXEC = 'TryExec';

const String G_KEY_FILE_DESKTOP_KEY_EXEC = 'Exec';

const String G_KEY_FILE_DESKTOP_KEY_PATH = 'Path';

const String G_KEY_FILE_DESKTOP_KEY_TERMINAL = 'Terminal';

const String G_KEY_FILE_DESKTOP_KEY_MIME_TYPE = 'MimeType';

const String G_KEY_FILE_DESKTOP_KEY_CATEGORIES = 'Categories';

const String G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY = 'StartupNotify';

const String G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS = 'StartupWMClass';

const String G_KEY_FILE_DESKTOP_KEY_URL = 'URL';

const String G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE = 'DBusActivatable';

const String G_KEY_FILE_DESKTOP_KEY_ACTIONS = 'Actions';

const String G_KEY_FILE_DESKTOP_TYPE_APPLICATION = 'Application';

const String G_KEY_FILE_DESKTOP_TYPE_LINK = 'Link';

const String G_KEY_FILE_DESKTOP_TYPE_DIRECTORY = 'Directory';

const int G_LOG_LEVEL_USER_SHIFT = 8;

const int G_LOG_FATAL_MASK = 5;

const String G_OPTION_REMAINING = '';

const String G_CSET_A_2_Z = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

const String G_CSET_a_2_z = 'abcdefghijklmnopqrstuvwxyz';

const String G_CSET_DIGITS = '0123456789';

const String G_CSET_LATINC =
    '\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE';

const String G_CSET_LATINS =
    '\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF';

const String G_STR_DELIMITERS = '_-|> <.';

const int G_ASCII_DTOSTR_BUF_SIZE = 39;

const int _ERRNO_H = 1;

const int _BITS_ERRNO_H = 1;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int ENOTBLK = 15;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int EINVAL = 22;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int ETXTBSY = 26;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int ERANGE = 34;

const int EDEADLK = 35;

const int ENAMETOOLONG = 36;

const int ENOLCK = 37;

const int ENOSYS = 38;

const int ENOTEMPTY = 39;

const int ELOOP = 40;

const int EWOULDBLOCK = 11;

const int ENOMSG = 42;

const int EIDRM = 43;

const int ECHRNG = 44;

const int EL2NSYNC = 45;

const int EL3HLT = 46;

const int EL3RST = 47;

const int ELNRNG = 48;

const int EUNATCH = 49;

const int ENOCSI = 50;

const int EL2HLT = 51;

const int EBADE = 52;

const int EBADR = 53;

const int EXFULL = 54;

const int ENOANO = 55;

const int EBADRQC = 56;

const int EBADSLT = 57;

const int EDEADLOCK = 35;

const int EBFONT = 59;

const int ENOSTR = 60;

const int ENODATA = 61;

const int ETIME = 62;

const int ENOSR = 63;

const int ENONET = 64;

const int ENOPKG = 65;

const int EREMOTE = 66;

const int ENOLINK = 67;

const int EADV = 68;

const int ESRMNT = 69;

const int ECOMM = 70;

const int EPROTO = 71;

const int EMULTIHOP = 72;

const int EDOTDOT = 73;

const int EBADMSG = 74;

const int EOVERFLOW = 75;

const int ENOTUNIQ = 76;

const int EBADFD = 77;

const int EREMCHG = 78;

const int ELIBACC = 79;

const int ELIBBAD = 80;

const int ELIBSCN = 81;

const int ELIBMAX = 82;

const int ELIBEXEC = 83;

const int EILSEQ = 84;

const int ERESTART = 85;

const int ESTRPIPE = 86;

const int EUSERS = 87;

const int ENOTSOCK = 88;

const int EDESTADDRREQ = 89;

const int EMSGSIZE = 90;

const int EPROTOTYPE = 91;

const int ENOPROTOOPT = 92;

const int EPROTONOSUPPORT = 93;

const int ESOCKTNOSUPPORT = 94;

const int EOPNOTSUPP = 95;

const int EPFNOSUPPORT = 96;

const int EAFNOSUPPORT = 97;

const int EADDRINUSE = 98;

const int EADDRNOTAVAIL = 99;

const int ENETDOWN = 100;

const int ENETUNREACH = 101;

const int ENETRESET = 102;

const int ECONNABORTED = 103;

const int ECONNRESET = 104;

const int ENOBUFS = 105;

const int EISCONN = 106;

const int ENOTCONN = 107;

const int ESHUTDOWN = 108;

const int ETOOMANYREFS = 109;

const int ETIMEDOUT = 110;

const int ECONNREFUSED = 111;

const int EHOSTDOWN = 112;

const int EHOSTUNREACH = 113;

const int EALREADY = 114;

const int EINPROGRESS = 115;

const int ESTALE = 116;

const int EUCLEAN = 117;

const int ENOTNAM = 118;

const int ENAVAIL = 119;

const int EISNAM = 120;

const int EREMOTEIO = 121;

const int EDQUOT = 122;

const int ENOMEDIUM = 123;

const int EMEDIUMTYPE = 124;

const int ECANCELED = 125;

const int ENOKEY = 126;

const int EKEYEXPIRED = 127;

const int EKEYREVOKED = 128;

const int EKEYREJECTED = 129;

const int EOWNERDEAD = 130;

const int ENOTRECOVERABLE = 131;

const int ERFKILL = 132;

const int EHWPOISON = 133;

const int ENOTSUP = 95;

const String G_TEST_OPTION_ISOLATE_DIRS = 'isolate_dirs';

const int G_USEC_PER_SEC = 1000000;

const String G_URI_RESERVED_CHARS_GENERIC_DELIMITERS = ':/?#[]@';

const String G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = '!\$&\'()*+,;=';

const String G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT = '!\$&\'()*+,;=:@';

const String G_URI_RESERVED_CHARS_ALLOWED_IN_PATH = '!\$&\'()*+,;=:@/';

const String G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO = '!\$&\'()*+,;=:';

const int G_ALLOC_ONLY = 1;

const int G_ALLOC_AND_FREE = 2;

const int G_ALLOCATOR_LIST = 1;

const int G_ALLOCATOR_SLIST = 2;

const int G_ALLOCATOR_NODE = 3;

const int _PTHREAD_H = 1;

const int _SCHED_H = 1;

const int _BITS_SCHED_H = 1;

const int SCHED_OTHER = 0;

const int SCHED_FIFO = 1;

const int SCHED_RR = 2;

const int _BITS_TYPES_STRUCT_SCHED_PARAM = 1;

const int _BITS_CPU_SET_H = 1;

const int __CPU_SETSIZE = 1024;

const int __NCPUBITS = 64;

const int _BITS_SETJMP_H = 1;

const int __jmp_buf_tag_defined = 1;

const int PTHREAD_CREATE_JOINABLE1 = 0;

const int PTHREAD_CREATE_DETACHED1 = 1;

const int PTHREAD_INHERIT_SCHED1 = 0;

const int PTHREAD_EXPLICIT_SCHED1 = 1;

const int PTHREAD_SCOPE_SYSTEM1 = 0;

const int PTHREAD_SCOPE_PROCESS1 = 1;

const int PTHREAD_PROCESS_PRIVATE1 = 0;

const int PTHREAD_PROCESS_SHARED1 = 1;

const int PTHREAD_CANCEL_ENABLE1 = 0;

const int PTHREAD_CANCEL_DISABLE1 = 1;

const int PTHREAD_CANCEL_DEFERRED1 = 0;

const int PTHREAD_CANCEL_ASYNCHRONOUS1 = 1;

const int PTHREAD_ONCE_INIT = 0;

const int PTHREAD_BARRIER_SERIAL_THREAD = -1;

const int G_TYPE_FUNDAMENTAL_MAX = 1020;

const int G_TYPE_INVALID = 0;

const int G_TYPE_NONE = 4;

const int G_TYPE_INTERFACE = 8;

const int G_TYPE_CHAR = 12;

const int G_TYPE_UCHAR = 16;

const int G_TYPE_BOOLEAN = 20;

const int G_TYPE_INT = 24;

const int G_TYPE_UINT = 28;

const int G_TYPE_LONG = 32;

const int G_TYPE_ULONG = 36;

const int G_TYPE_INT64 = 40;

const int G_TYPE_UINT64 = 44;

const int G_TYPE_ENUM = 48;

const int G_TYPE_FLAGS = 52;

const int G_TYPE_FLOAT = 56;

const int G_TYPE_DOUBLE = 60;

const int G_TYPE_STRING = 64;

const int G_TYPE_POINTER = 68;

const int G_TYPE_BOXED = 72;

const int G_TYPE_PARAM = 76;

const int G_TYPE_OBJECT = 80;

const int G_TYPE_VARIANT = 84;

const int G_TYPE_FUNDAMENTAL_SHIFT = 2;

const int G_TYPE_RESERVED_GLIB_FIRST = 22;

const int G_TYPE_RESERVED_GLIB_LAST = 31;

const int G_TYPE_RESERVED_BSE_FIRST = 32;

const int G_TYPE_RESERVED_BSE_LAST = 48;

const int G_TYPE_RESERVED_USER_FIRST = 49;

const int G_TYPE_FLAG_RESERVED_ID_BIT = 1;

const int G_VALUE_NOCOPY_CONTENTS = 134217728;

const int G_VALUE_INTERNED_STRING = 268435456;

const int G_PARAM_STATIC_STRINGS = 224;

const int G_PARAM_MASK = 255;

const int G_PARAM_USER_SHIFT = 8;

const int G_SIGNAL_FLAGS_MASK = 511;

const int G_SIGNAL_MATCH_MASK = 63;

const int G_SIGNAL_TYPE_STATIC_SCOPE = 1;

const int _UNISTD_H = 1;

const int _POSIX_VERSION = 200809;

const int __POSIX2_THIS_VERSION = 200809;

const int _POSIX2_VERSION = 200809;

const int _POSIX2_C_VERSION = 200809;

const int _POSIX2_C_BIND = 200809;

const int _POSIX2_C_DEV = 200809;

const int _POSIX2_SW_DEV = 200809;

const int _POSIX2_LOCALEDEF = 200809;

const int _XOPEN_VERSION = 700;

const int _XOPEN_XCU_VERSION = 4;

const int _XOPEN_XPG2 = 1;

const int _XOPEN_XPG3 = 1;

const int _XOPEN_XPG4 = 1;

const int _XOPEN_UNIX = 1;

const int _XOPEN_ENH_I18N = 1;

const int _XOPEN_LEGACY = 1;

const int _BITS_POSIX_OPT_H = 1;

const int _POSIX_JOB_CONTROL = 1;

const int _POSIX_SAVED_IDS = 1;

const int _POSIX_PRIORITY_SCHEDULING = 200809;

const int _POSIX_SYNCHRONIZED_IO = 200809;

const int _POSIX_FSYNC = 200809;

const int _POSIX_MAPPED_FILES = 200809;

const int _POSIX_MEMLOCK = 200809;

const int _POSIX_MEMLOCK_RANGE = 200809;

const int _POSIX_MEMORY_PROTECTION = 200809;

const int _POSIX_CHOWN_RESTRICTED = 0;

const int _POSIX_VDISABLE = 0;

const int _POSIX_NO_TRUNC = 1;

const int _XOPEN_REALTIME = 1;

const int _XOPEN_REALTIME_THREADS = 1;

const int _XOPEN_SHM = 1;

const int _POSIX_THREADS = 200809;

const int _POSIX_REENTRANT_FUNCTIONS = 1;

const int _POSIX_THREAD_SAFE_FUNCTIONS = 200809;

const int _POSIX_THREAD_PRIORITY_SCHEDULING = 200809;

const int _POSIX_THREAD_ATTR_STACKSIZE = 200809;

const int _POSIX_THREAD_ATTR_STACKADDR = 200809;

const int _POSIX_THREAD_PRIO_INHERIT = 200809;

const int _POSIX_THREAD_PRIO_PROTECT = 200809;

const int _POSIX_THREAD_ROBUST_PRIO_INHERIT = 200809;

const int _POSIX_THREAD_ROBUST_PRIO_PROTECT = -1;

const int _POSIX_SEMAPHORES = 200809;

const int _POSIX_REALTIME_SIGNALS = 200809;

const int _POSIX_ASYNCHRONOUS_IO = 200809;

const int _POSIX_ASYNC_IO = 1;

const int _LFS_ASYNCHRONOUS_IO = 1;

const int _POSIX_PRIORITIZED_IO = 200809;

const int _LFS64_ASYNCHRONOUS_IO = 1;

const int _LFS_LARGEFILE = 1;

const int _LFS64_LARGEFILE = 1;

const int _LFS64_STDIO = 1;

const int _POSIX_SHARED_MEMORY_OBJECTS = 200809;

const int _POSIX_CPUTIME = 0;

const int _POSIX_THREAD_CPUTIME = 0;

const int _POSIX_REGEXP = 1;

const int _POSIX_READER_WRITER_LOCKS = 200809;

const int _POSIX_SHELL = 1;

const int _POSIX_TIMEOUTS = 200809;

const int _POSIX_SPIN_LOCKS = 200809;

const int _POSIX_SPAWN = 200809;

const int _POSIX_TIMERS = 200809;

const int _POSIX_BARRIERS = 200809;

const int _POSIX_MESSAGE_PASSING = 200809;

const int _POSIX_THREAD_PROCESS_SHARED = 200809;

const int _POSIX_MONOTONIC_CLOCK = 0;

const int _POSIX_CLOCK_SELECTION = 200809;

const int _POSIX_ADVISORY_INFO = 200809;

const int _POSIX_IPV6 = 200809;

const int _POSIX_RAW_SOCKETS = 200809;

const int _POSIX2_CHAR_TERM = 200809;

const int _POSIX_SPORADIC_SERVER = -1;

const int _POSIX_THREAD_SPORADIC_SERVER = -1;

const int _POSIX_TRACE = -1;

const int _POSIX_TRACE_EVENT_FILTER = -1;

const int _POSIX_TRACE_INHERIT = -1;

const int _POSIX_TRACE_LOG = -1;

const int _POSIX_TYPED_MEMORY_OBJECTS = -1;

const int _POSIX_V7_LPBIG_OFFBIG = -1;

const int _POSIX_V6_LPBIG_OFFBIG = -1;

const int _XBS5_LPBIG_OFFBIG = -1;

const int _POSIX_V7_LP64_OFF64 = 1;

const int _POSIX_V6_LP64_OFF64 = 1;

const int _XBS5_LP64_OFF64 = 1;

const String __ILP32_OFF32_CFLAGS = '-m32';

const String __ILP32_OFF32_LDFLAGS = '-m32';

const String __ILP32_OFFBIG_CFLAGS =
    '-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64';

const String __ILP32_OFFBIG_LDFLAGS = '-m32';

const String __LP64_OFF64_CFLAGS = '-m64';

const String __LP64_OFF64_LDFLAGS = '-m64';

const int STDIN_FILENO = 0;

const int STDOUT_FILENO = 1;

const int STDERR_FILENO = 2;

const int R_OK = 4;

const int W_OK = 2;

const int X_OK = 1;

const int F_OK = 0;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int L_SET = 0;

const int L_INCR = 1;

const int L_XTND = 2;

const int _PC_LINK_MAX1 = 0;

const int _PC_MAX_CANON1 = 1;

const int _PC_MAX_INPUT1 = 2;

const int _PC_NAME_MAX1 = 3;

const int _PC_PATH_MAX1 = 4;

const int _PC_PIPE_BUF1 = 5;

const int _PC_CHOWN_RESTRICTED1 = 6;

const int _PC_NO_TRUNC1 = 7;

const int _PC_VDISABLE1 = 8;

const int _PC_SYNC_IO1 = 9;

const int _PC_ASYNC_IO1 = 10;

const int _PC_PRIO_IO1 = 11;

const int _PC_SOCK_MAXBUF1 = 12;

const int _PC_FILESIZEBITS1 = 13;

const int _PC_REC_INCR_XFER_SIZE1 = 14;

const int _PC_REC_MAX_XFER_SIZE1 = 15;

const int _PC_REC_MIN_XFER_SIZE1 = 16;

const int _PC_REC_XFER_ALIGN1 = 17;

const int _PC_ALLOC_SIZE_MIN1 = 18;

const int _PC_SYMLINK_MAX1 = 19;

const int _PC_2_SYMLINKS1 = 20;

const int _SC_ARG_MAX1 = 0;

const int _SC_CHILD_MAX1 = 1;

const int _SC_CLK_TCK1 = 2;

const int _SC_NGROUPS_MAX1 = 3;

const int _SC_OPEN_MAX1 = 4;

const int _SC_STREAM_MAX1 = 5;

const int _SC_TZNAME_MAX1 = 6;

const int _SC_JOB_CONTROL1 = 7;

const int _SC_SAVED_IDS1 = 8;

const int _SC_REALTIME_SIGNALS1 = 9;

const int _SC_PRIORITY_SCHEDULING1 = 10;

const int _SC_TIMERS1 = 11;

const int _SC_ASYNCHRONOUS_IO1 = 12;

const int _SC_PRIORITIZED_IO1 = 13;

const int _SC_SYNCHRONIZED_IO1 = 14;

const int _SC_FSYNC1 = 15;

const int _SC_MAPPED_FILES1 = 16;

const int _SC_MEMLOCK1 = 17;

const int _SC_MEMLOCK_RANGE1 = 18;

const int _SC_MEMORY_PROTECTION1 = 19;

const int _SC_MESSAGE_PASSING1 = 20;

const int _SC_SEMAPHORES1 = 21;

const int _SC_SHARED_MEMORY_OBJECTS1 = 22;

const int _SC_AIO_LISTIO_MAX1 = 23;

const int _SC_AIO_MAX1 = 24;

const int _SC_AIO_PRIO_DELTA_MAX1 = 25;

const int _SC_DELAYTIMER_MAX1 = 26;

const int _SC_MQ_OPEN_MAX1 = 27;

const int _SC_MQ_PRIO_MAX1 = 28;

const int _SC_VERSION1 = 29;

const int _SC_PAGESIZE1 = 30;

const int _SC_PAGE_SIZE = 30;

const int _SC_RTSIG_MAX1 = 31;

const int _SC_SEM_NSEMS_MAX1 = 32;

const int _SC_SEM_VALUE_MAX1 = 33;

const int _SC_SIGQUEUE_MAX1 = 34;

const int _SC_TIMER_MAX1 = 35;

const int _SC_BC_BASE_MAX1 = 36;

const int _SC_BC_DIM_MAX1 = 37;

const int _SC_BC_SCALE_MAX1 = 38;

const int _SC_BC_STRING_MAX1 = 39;

const int _SC_COLL_WEIGHTS_MAX1 = 40;

const int _SC_EQUIV_CLASS_MAX1 = 41;

const int _SC_EXPR_NEST_MAX1 = 42;

const int _SC_LINE_MAX1 = 43;

const int _SC_RE_DUP_MAX1 = 44;

const int _SC_CHARCLASS_NAME_MAX1 = 45;

const int _SC_2_VERSION1 = 46;

const int _SC_2_C_BIND1 = 47;

const int _SC_2_C_DEV1 = 48;

const int _SC_2_FORT_DEV1 = 49;

const int _SC_2_FORT_RUN1 = 50;

const int _SC_2_SW_DEV1 = 51;

const int _SC_2_LOCALEDEF1 = 52;

const int _SC_PII1 = 53;

const int _SC_PII_XTI1 = 54;

const int _SC_PII_SOCKET1 = 55;

const int _SC_PII_INTERNET1 = 56;

const int _SC_PII_OSI1 = 57;

const int _SC_POLL1 = 58;

const int _SC_SELECT1 = 59;

const int _SC_UIO_MAXIOV1 = 60;

const int _SC_IOV_MAX1 = 60;

const int _SC_PII_INTERNET_STREAM1 = 61;

const int _SC_PII_INTERNET_DGRAM1 = 62;

const int _SC_PII_OSI_COTS1 = 63;

const int _SC_PII_OSI_CLTS1 = 64;

const int _SC_PII_OSI_M1 = 65;

const int _SC_T_IOV_MAX1 = 66;

const int _SC_THREADS1 = 67;

const int _SC_THREAD_SAFE_FUNCTIONS1 = 68;

const int _SC_GETGR_R_SIZE_MAX1 = 69;

const int _SC_GETPW_R_SIZE_MAX1 = 70;

const int _SC_LOGIN_NAME_MAX1 = 71;

const int _SC_TTY_NAME_MAX1 = 72;

const int _SC_THREAD_DESTRUCTOR_ITERATIONS1 = 73;

const int _SC_THREAD_KEYS_MAX1 = 74;

const int _SC_THREAD_STACK_MIN1 = 75;

const int _SC_THREAD_THREADS_MAX1 = 76;

const int _SC_THREAD_ATTR_STACKADDR1 = 77;

const int _SC_THREAD_ATTR_STACKSIZE1 = 78;

const int _SC_THREAD_PRIORITY_SCHEDULING1 = 79;

const int _SC_THREAD_PRIO_INHERIT1 = 80;

const int _SC_THREAD_PRIO_PROTECT1 = 81;

const int _SC_THREAD_PROCESS_SHARED1 = 82;

const int _SC_NPROCESSORS_CONF1 = 83;

const int _SC_NPROCESSORS_ONLN1 = 84;

const int _SC_PHYS_PAGES1 = 85;

const int _SC_AVPHYS_PAGES1 = 86;

const int _SC_ATEXIT_MAX1 = 87;

const int _SC_PASS_MAX1 = 88;

const int _SC_XOPEN_VERSION1 = 89;

const int _SC_XOPEN_XCU_VERSION1 = 90;

const int _SC_XOPEN_UNIX1 = 91;

const int _SC_XOPEN_CRYPT1 = 92;

const int _SC_XOPEN_ENH_I18N1 = 93;

const int _SC_XOPEN_SHM1 = 94;

const int _SC_2_CHAR_TERM1 = 95;

const int _SC_2_C_VERSION1 = 96;

const int _SC_2_UPE1 = 97;

const int _SC_XOPEN_XPG21 = 98;

const int _SC_XOPEN_XPG31 = 99;

const int _SC_XOPEN_XPG41 = 100;

const int _SC_CHAR_BIT1 = 101;

const int _SC_CHAR_MAX1 = 102;

const int _SC_CHAR_MIN1 = 103;

const int _SC_INT_MAX1 = 104;

const int _SC_INT_MIN1 = 105;

const int _SC_LONG_BIT1 = 106;

const int _SC_WORD_BIT1 = 107;

const int _SC_MB_LEN_MAX1 = 108;

const int _SC_NZERO1 = 109;

const int _SC_SSIZE_MAX1 = 110;

const int _SC_SCHAR_MAX1 = 111;

const int _SC_SCHAR_MIN1 = 112;

const int _SC_SHRT_MAX1 = 113;

const int _SC_SHRT_MIN1 = 114;

const int _SC_UCHAR_MAX1 = 115;

const int _SC_UINT_MAX1 = 116;

const int _SC_ULONG_MAX1 = 117;

const int _SC_USHRT_MAX1 = 118;

const int _SC_NL_ARGMAX1 = 119;

const int _SC_NL_LANGMAX1 = 120;

const int _SC_NL_MSGMAX1 = 121;

const int _SC_NL_NMAX1 = 122;

const int _SC_NL_SETMAX1 = 123;

const int _SC_NL_TEXTMAX1 = 124;

const int _SC_XBS5_ILP32_OFF321 = 125;

const int _SC_XBS5_ILP32_OFFBIG1 = 126;

const int _SC_XBS5_LP64_OFF641 = 127;

const int _SC_XBS5_LPBIG_OFFBIG1 = 128;

const int _SC_XOPEN_LEGACY1 = 129;

const int _SC_XOPEN_REALTIME1 = 130;

const int _SC_XOPEN_REALTIME_THREADS1 = 131;

const int _SC_ADVISORY_INFO1 = 132;

const int _SC_BARRIERS1 = 133;

const int _SC_BASE1 = 134;

const int _SC_C_LANG_SUPPORT1 = 135;

const int _SC_C_LANG_SUPPORT_R1 = 136;

const int _SC_CLOCK_SELECTION1 = 137;

const int _SC_CPUTIME1 = 138;

const int _SC_THREAD_CPUTIME1 = 139;

const int _SC_DEVICE_IO1 = 140;

const int _SC_DEVICE_SPECIFIC1 = 141;

const int _SC_DEVICE_SPECIFIC_R1 = 142;

const int _SC_FD_MGMT1 = 143;

const int _SC_FIFO1 = 144;

const int _SC_PIPE1 = 145;

const int _SC_FILE_ATTRIBUTES1 = 146;

const int _SC_FILE_LOCKING1 = 147;

const int _SC_FILE_SYSTEM1 = 148;

const int _SC_MONOTONIC_CLOCK1 = 149;

const int _SC_MULTI_PROCESS1 = 150;

const int _SC_SINGLE_PROCESS1 = 151;

const int _SC_NETWORKING1 = 152;

const int _SC_READER_WRITER_LOCKS1 = 153;

const int _SC_SPIN_LOCKS1 = 154;

const int _SC_REGEXP1 = 155;

const int _SC_REGEX_VERSION1 = 156;

const int _SC_SHELL1 = 157;

const int _SC_SIGNALS1 = 158;

const int _SC_SPAWN1 = 159;

const int _SC_SPORADIC_SERVER1 = 160;

const int _SC_THREAD_SPORADIC_SERVER1 = 161;

const int _SC_SYSTEM_DATABASE1 = 162;

const int _SC_SYSTEM_DATABASE_R1 = 163;

const int _SC_TIMEOUTS1 = 164;

const int _SC_TYPED_MEMORY_OBJECTS1 = 165;

const int _SC_USER_GROUPS1 = 166;

const int _SC_USER_GROUPS_R1 = 167;

const int _SC_2_PBS1 = 168;

const int _SC_2_PBS_ACCOUNTING1 = 169;

const int _SC_2_PBS_LOCATE1 = 170;

const int _SC_2_PBS_MESSAGE1 = 171;

const int _SC_2_PBS_TRACK1 = 172;

const int _SC_SYMLOOP_MAX1 = 173;

const int _SC_STREAMS1 = 174;

const int _SC_2_PBS_CHECKPOINT1 = 175;

const int _SC_V6_ILP32_OFF321 = 176;

const int _SC_V6_ILP32_OFFBIG1 = 177;

const int _SC_V6_LP64_OFF641 = 178;

const int _SC_V6_LPBIG_OFFBIG1 = 179;

const int _SC_HOST_NAME_MAX1 = 180;

const int _SC_TRACE1 = 181;

const int _SC_TRACE_EVENT_FILTER1 = 182;

const int _SC_TRACE_INHERIT1 = 183;

const int _SC_TRACE_LOG1 = 184;

const int _SC_LEVEL1_ICACHE_SIZE1 = 185;

const int _SC_LEVEL1_ICACHE_ASSOC1 = 186;

const int _SC_LEVEL1_ICACHE_LINESIZE1 = 187;

const int _SC_LEVEL1_DCACHE_SIZE1 = 188;

const int _SC_LEVEL1_DCACHE_ASSOC1 = 189;

const int _SC_LEVEL1_DCACHE_LINESIZE1 = 190;

const int _SC_LEVEL2_CACHE_SIZE1 = 191;

const int _SC_LEVEL2_CACHE_ASSOC1 = 192;

const int _SC_LEVEL2_CACHE_LINESIZE1 = 193;

const int _SC_LEVEL3_CACHE_SIZE1 = 194;

const int _SC_LEVEL3_CACHE_ASSOC1 = 195;

const int _SC_LEVEL3_CACHE_LINESIZE1 = 196;

const int _SC_LEVEL4_CACHE_SIZE1 = 197;

const int _SC_LEVEL4_CACHE_ASSOC1 = 198;

const int _SC_LEVEL4_CACHE_LINESIZE1 = 199;

const int _SC_IPV61 = 235;

const int _SC_RAW_SOCKETS1 = 236;

const int _SC_V7_ILP32_OFF321 = 237;

const int _SC_V7_ILP32_OFFBIG1 = 238;

const int _SC_V7_LP64_OFF641 = 239;

const int _SC_V7_LPBIG_OFFBIG1 = 240;

const int _SC_SS_REPL_MAX1 = 241;

const int _SC_TRACE_EVENT_NAME_MAX1 = 242;

const int _SC_TRACE_NAME_MAX1 = 243;

const int _SC_TRACE_SYS_MAX1 = 244;

const int _SC_TRACE_USER_EVENT_MAX1 = 245;

const int _SC_XOPEN_STREAMS1 = 246;

const int _SC_THREAD_ROBUST_PRIO_INHERIT1 = 247;

const int _SC_THREAD_ROBUST_PRIO_PROTECT1 = 248;

const int _SC_MINSIGSTKSZ1 = 249;

const int _SC_SIGSTKSZ1 = 250;

const int _CS_PATH1 = 0;

const int _CS_V6_WIDTH_RESTRICTED_ENVS1 = 1;

const int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = 1;

const int _CS_GNU_LIBC_VERSION1 = 2;

const int _CS_GNU_LIBPTHREAD_VERSION1 = 3;

const int _CS_V5_WIDTH_RESTRICTED_ENVS1 = 4;

const int _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS = 4;

const int _CS_V7_WIDTH_RESTRICTED_ENVS1 = 5;

const int _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS = 5;

const int _CS_LFS_CFLAGS1 = 1000;

const int _CS_LFS_LDFLAGS1 = 1001;

const int _CS_LFS_LIBS1 = 1002;

const int _CS_LFS_LINTFLAGS1 = 1003;

const int _CS_LFS64_CFLAGS1 = 1004;

const int _CS_LFS64_LDFLAGS1 = 1005;

const int _CS_LFS64_LIBS1 = 1006;

const int _CS_LFS64_LINTFLAGS1 = 1007;

const int _CS_XBS5_ILP32_OFF32_CFLAGS1 = 1100;

const int _CS_XBS5_ILP32_OFF32_LDFLAGS1 = 1101;

const int _CS_XBS5_ILP32_OFF32_LIBS1 = 1102;

const int _CS_XBS5_ILP32_OFF32_LINTFLAGS1 = 1103;

const int _CS_XBS5_ILP32_OFFBIG_CFLAGS1 = 1104;

const int _CS_XBS5_ILP32_OFFBIG_LDFLAGS1 = 1105;

const int _CS_XBS5_ILP32_OFFBIG_LIBS1 = 1106;

const int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS1 = 1107;

const int _CS_XBS5_LP64_OFF64_CFLAGS1 = 1108;

const int _CS_XBS5_LP64_OFF64_LDFLAGS1 = 1109;

const int _CS_XBS5_LP64_OFF64_LIBS1 = 1110;

const int _CS_XBS5_LP64_OFF64_LINTFLAGS1 = 1111;

const int _CS_XBS5_LPBIG_OFFBIG_CFLAGS1 = 1112;

const int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS1 = 1113;

const int _CS_XBS5_LPBIG_OFFBIG_LIBS1 = 1114;

const int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS1 = 1115;

const int _CS_POSIX_V6_ILP32_OFF32_CFLAGS1 = 1116;

const int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS1 = 1117;

const int _CS_POSIX_V6_ILP32_OFF32_LIBS1 = 1118;

const int _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS1 = 1119;

const int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS1 = 1120;

const int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS1 = 1121;

const int _CS_POSIX_V6_ILP32_OFFBIG_LIBS1 = 1122;

const int _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS1 = 1123;

const int _CS_POSIX_V6_LP64_OFF64_CFLAGS1 = 1124;

const int _CS_POSIX_V6_LP64_OFF64_LDFLAGS1 = 1125;

const int _CS_POSIX_V6_LP64_OFF64_LIBS1 = 1126;

const int _CS_POSIX_V6_LP64_OFF64_LINTFLAGS1 = 1127;

const int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS1 = 1128;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS1 = 1129;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS1 = 1130;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS1 = 1131;

const int _CS_POSIX_V7_ILP32_OFF32_CFLAGS1 = 1132;

const int _CS_POSIX_V7_ILP32_OFF32_LDFLAGS1 = 1133;

const int _CS_POSIX_V7_ILP32_OFF32_LIBS1 = 1134;

const int _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS1 = 1135;

const int _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS1 = 1136;

const int _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS1 = 1137;

const int _CS_POSIX_V7_ILP32_OFFBIG_LIBS1 = 1138;

const int _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS1 = 1139;

const int _CS_POSIX_V7_LP64_OFF64_CFLAGS1 = 1140;

const int _CS_POSIX_V7_LP64_OFF64_LDFLAGS1 = 1141;

const int _CS_POSIX_V7_LP64_OFF64_LIBS1 = 1142;

const int _CS_POSIX_V7_LP64_OFF64_LINTFLAGS1 = 1143;

const int _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS1 = 1144;

const int _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS1 = 1145;

const int _CS_POSIX_V7_LPBIG_OFFBIG_LIBS1 = 1146;

const int _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS1 = 1147;

const int _CS_V6_ENV1 = 1148;

const int _CS_V7_ENV1 = 1149;

const int _GETOPT_POSIX_H = 1;

const int _GETOPT_CORE_H = 1;

const int F_ULOCK = 0;

const int F_LOCK = 1;

const int F_TLOCK = 2;

const int F_TEST = 3;

const int G_DBUS_METHOD_INVOCATION_HANDLED = 1;

const int G_DBUS_METHOD_INVOCATION_UNHANDLED = 0;

const String G_DEBUG_CONTROLLER_EXTENSION_POINT_NAME = 'gio-debug-controller';

const String G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE = 'unix-device';

const String G_FILE_ATTRIBUTE_STANDARD_TYPE = 'standard::type';

const String G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN = 'standard::is-hidden';

const String G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP = 'standard::is-backup';

const String G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK = 'standard::is-symlink';

const String G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL = 'standard::is-virtual';

const String G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE = 'standard::is-volatile';

const String G_FILE_ATTRIBUTE_STANDARD_NAME = 'standard::name';

const String G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME = 'standard::display-name';

const String G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME = 'standard::edit-name';

const String G_FILE_ATTRIBUTE_STANDARD_COPY_NAME = 'standard::copy-name';

const String G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION = 'standard::description';

const String G_FILE_ATTRIBUTE_STANDARD_ICON = 'standard::icon';

const String G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON =
    'standard::symbolic-icon';

const String G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE = 'standard::content-type';

const String G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE =
    'standard::fast-content-type';

const String G_FILE_ATTRIBUTE_STANDARD_SIZE = 'standard::size';

const String G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE =
    'standard::allocated-size';

const String G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET =
    'standard::symlink-target';

const String G_FILE_ATTRIBUTE_STANDARD_TARGET_URI = 'standard::target-uri';

const String G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER = 'standard::sort-order';

const String G_FILE_ATTRIBUTE_ETAG_VALUE = 'etag::value';

const String G_FILE_ATTRIBUTE_ID_FILE = 'id::file';

const String G_FILE_ATTRIBUTE_ID_FILESYSTEM = 'id::filesystem';

const String G_FILE_ATTRIBUTE_ACCESS_CAN_READ = 'access::can-read';

const String G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE = 'access::can-write';

const String G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE = 'access::can-execute';

const String G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE = 'access::can-delete';

const String G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH = 'access::can-trash';

const String G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME = 'access::can-rename';

const String G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT = 'mountable::can-mount';

const String G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT = 'mountable::can-unmount';

const String G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT = 'mountable::can-eject';

const String G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE = 'mountable::unix-device';

const String G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE =
    'mountable::unix-device-file';

const String G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI = 'mountable::hal-udi';

const String G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START = 'mountable::can-start';

const String G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED =
    'mountable::can-start-degraded';

const String G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = 'mountable::can-stop';

const String G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE =
    'mountable::start-stop-type';

const String G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = 'mountable::can-poll';

const String G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC =
    'mountable::is-media-check-automatic';

const String G_FILE_ATTRIBUTE_TIME_MODIFIED = 'time::modified';

const String G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC = 'time::modified-usec';

const String G_FILE_ATTRIBUTE_TIME_ACCESS = 'time::access';

const String G_FILE_ATTRIBUTE_TIME_ACCESS_USEC = 'time::access-usec';

const String G_FILE_ATTRIBUTE_TIME_CHANGED = 'time::changed';

const String G_FILE_ATTRIBUTE_TIME_CHANGED_USEC = 'time::changed-usec';

const String G_FILE_ATTRIBUTE_TIME_CREATED = 'time::created';

const String G_FILE_ATTRIBUTE_TIME_CREATED_USEC = 'time::created-usec';

const String G_FILE_ATTRIBUTE_UNIX_DEVICE = 'unix::device';

const String G_FILE_ATTRIBUTE_UNIX_INODE = 'unix::inode';

const String G_FILE_ATTRIBUTE_UNIX_MODE = 'unix::mode';

const String G_FILE_ATTRIBUTE_UNIX_NLINK = 'unix::nlink';

const String G_FILE_ATTRIBUTE_UNIX_UID = 'unix::uid';

const String G_FILE_ATTRIBUTE_UNIX_GID = 'unix::gid';

const String G_FILE_ATTRIBUTE_UNIX_RDEV = 'unix::rdev';

const String G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE = 'unix::block-size';

const String G_FILE_ATTRIBUTE_UNIX_BLOCKS = 'unix::blocks';

const String G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT = 'unix::is-mountpoint';

const String G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE = 'dos::is-archive';

const String G_FILE_ATTRIBUTE_DOS_IS_SYSTEM = 'dos::is-system';

const String G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT = 'dos::is-mountpoint';

const String G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG = 'dos::reparse-point-tag';

const String G_FILE_ATTRIBUTE_OWNER_USER = 'owner::user';

const String G_FILE_ATTRIBUTE_OWNER_USER_REAL = 'owner::user-real';

const String G_FILE_ATTRIBUTE_OWNER_GROUP = 'owner::group';

const String G_FILE_ATTRIBUTE_THUMBNAIL_PATH = 'thumbnail::path';

const String G_FILE_ATTRIBUTE_THUMBNAILING_FAILED = 'thumbnail::failed';

const String G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID = 'thumbnail::is-valid';

const String G_FILE_ATTRIBUTE_PREVIEW_ICON = 'preview::icon';

const String G_FILE_ATTRIBUTE_FILESYSTEM_SIZE = 'filesystem::size';

const String G_FILE_ATTRIBUTE_FILESYSTEM_FREE = 'filesystem::free';

const String G_FILE_ATTRIBUTE_FILESYSTEM_USED = 'filesystem::used';

const String G_FILE_ATTRIBUTE_FILESYSTEM_TYPE = 'filesystem::type';

const String G_FILE_ATTRIBUTE_FILESYSTEM_READONLY = 'filesystem::readonly';

const String G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW =
    'filesystem::use-preview';

const String G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE = 'filesystem::remote';

const String G_FILE_ATTRIBUTE_GVFS_BACKEND = 'gvfs::backend';

const String G_FILE_ATTRIBUTE_SELINUX_CONTEXT = 'selinux::context';

const String G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT = 'trash::item-count';

const String G_FILE_ATTRIBUTE_TRASH_ORIG_PATH = 'trash::orig-path';

const String G_FILE_ATTRIBUTE_TRASH_DELETION_DATE = 'trash::deletion-date';

const String G_FILE_ATTRIBUTE_RECENT_MODIFIED = 'recent::modified';

const String G_MEMORY_MONITOR_EXTENSION_POINT_NAME = 'gio-memory-monitor';

const String G_MENU_ATTRIBUTE_ACTION = 'action';

const String G_MENU_ATTRIBUTE_ACTION_NAMESPACE = 'action-namespace';

const String G_MENU_ATTRIBUTE_TARGET = 'target';

const String G_MENU_ATTRIBUTE_LABEL = 'label';

const String G_MENU_ATTRIBUTE_ICON = 'icon';

const String G_MENU_LINK_SUBMENU = 'submenu';

const String G_MENU_LINK_SECTION = 'section';

const String G_VOLUME_MONITOR_EXTENSION_POINT_NAME = 'gio-volume-monitor';

const String G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME =
    'gio-native-volume-monitor';

const String G_NETWORK_MONITOR_EXTENSION_POINT_NAME = 'gio-network-monitor';

const String G_POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME =
    'gio-power-profile-monitor';

const String G_PROXY_EXTENSION_POINT_NAME = 'gio-proxy';

const String G_PROXY_RESOLVER_EXTENSION_POINT_NAME = 'gio-proxy-resolver';

const String G_TLS_BACKEND_EXTENSION_POINT_NAME = 'gio-tls-backend';

const String G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER = '1.3.6.1.5.5.7.3.1';

const String G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT = '1.3.6.1.5.5.7.3.2';

const String G_VFS_EXTENSION_POINT_NAME = 'gio-vfs';

const String G_VOLUME_IDENTIFIER_KIND_HAL_UDI = 'hal-udi';

const String G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE = 'unix-device';

const String G_VOLUME_IDENTIFIER_KIND_LABEL = 'label';

const String G_VOLUME_IDENTIFIER_KIND_UUID = 'uuid';

const String G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT = 'nfs-mount';

const String G_VOLUME_IDENTIFIER_KIND_CLASS = 'class';

const int FLATPAK_MAJOR_VERSION = 1;

const int FLATPAK_MINOR_VERSION = 12;

const int FLATPAK_MICRO_VERSION = 7;
